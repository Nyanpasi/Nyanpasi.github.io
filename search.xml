<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django项目部署</title>
    <url>/2019/10/20/Django%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>使用Docker部署Django项目, 一共四个容器</p>
<ol>
<li>MySQL容器</li>
<li>Redis容器</li>
<li>uWSGI容器</li>
<li>Nginx容器</li>
</ol>
<hr>
<a id="more"></a>

<h3 id="MySQL容器"><a href="#MySQL容器" class="headerlink" title="MySQL容器"></a>MySQL容器</h3><p>鉴于Django2.2+和MySQL8.0+版本在某些情况下不兼容, 所以使用MySQL5.7版本</p>
<p>由于在开发时直接使用该容器, 而且MySQL默认使用密码比较安全, 所以映射至外部端口.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=your-password mysql:5.7</span><br></pre></td></tr></table></figure>

<p>然后进入容器, 执行命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql /bin/bash</span><br></pre></td></tr></table></figure>

<p>登陆MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>创建数据表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE django-db DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p>退出容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Redis容器"><a href="#Redis容器" class="headerlink" title="Redis容器"></a>Redis容器</h3><p>Redis容器不使用密码, 所以不映射至宿主机端口, 只允许通过<strong>容器间通信</strong>进行访问.</p>
<p>在创建Redis容器时, 暴露6379端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis --expose 6379 redis</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="uWSGI容器"><a href="#uWSGI容器" class="headerlink" title="uWSGI容器"></a>uWSGI容器</h3><p>Django运行需要使用多个第三方库, 所以必须通过建立镜像的方式, 构建python环境.</p>
<p>在部署前, 首先进行静态资源的收集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage collectstatic</span><br></pre></td></tr></table></figure>

<p>假设所有静态资源被收集到项目根目录下的<code>static</code>文件夹和<code>media</code>文件夹.</p>
<p>首先编写<code>Dockerfile</code>, Django项目名为<code>webapp</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM python:3.6.6</span><br><span class="line">WORKDIR /usr/src/webapp</span><br><span class="line">COPY requirements.txt ./</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">EXPOSE 8001</span><br><span class="line">CMD uwsgi --socket :8001 --<span class="built_in">chdir</span> /usr/src/webapp --wsgi-file webapp/wsgi.py</span><br></pre></td></tr></table></figure>

<p>启动uWSGI时为socket模式, 意味着使用uwsgi协议与前端服务器Nginx进行通信</p>
<p>容器主进程命令使用CMD指定, 以便在<code>run</code>时重写命令, 测试其能否通过HTTP协议正常运行.</p>
<p>将其放置于某个空文件夹下, 并编写python所需的第三方包列表<code>requirements.txt</code>, 放置在同一目录下, 之后构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t uwsgi-image .</span><br></pre></td></tr></table></figure>

<p>在初次启动uWSGI容器时</p>
<ol>
<li>通过<code>Bind-Mount</code>的形式, 将webapp映射至容器内目录, 这样可以在宿主机上更改代码.</li>
<li>重写启动指令, 以http模式启动uWSGI, 以方便直接测试uwsgi的正确运行.</li>
</ol>
<p>假设webapp源码置于宿主机根目录下, 通过已构建的镜像运行容器:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --rm --name uwsgi -p 8001:8001 --link redis -v /webapp:/usr/src/webapp webapp-image uwsgi --http :8001 --<span class="built_in">chdir</span> /usr/src/webapp --wsgi-file webapp/wsgi.py</span><br></pre></td></tr></table></figure>

<p>当使用<code>--link</code>命令之后, 会在当前容器内生成路由,在Django项目源码内, 所有对redis实例的访问, 均将ip地址替换为<code>redis</code>, 即redis容器的容器名, 会自动链接至redis容器, 例如缓存部分应该这样设置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">"default"</span>: &#123;</span><br><span class="line">        <span class="string">"BACKEND"</span>: <span class="string">"django_redis.cache.RedisCache"</span>,</span><br><span class="line">        <span class="string">"LOCATION"</span>: <span class="string">"redis://redis/0"</span>, <span class="comment"># 此处</span></span><br><span class="line">        <span class="string">"OPTIONS"</span>: &#123;</span><br><span class="line">            <span class="string">"CLIENT_CLASS"</span>: <span class="string">"django_redis.client.DefaultClient"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"KEY_PREFIX"</span>: <span class="string">"webapp"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而数据库部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'HOST'</span>: <span class="string">'your-mysql-container-name-if-linked'</span>,</span><br></pre></td></tr></table></figure>

<p>之后在宿主机上访问本机8001端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget 127.0.0.1:8001</span><br></pre></td></tr></table></figure>

<p>或者直接通过浏览器访问远程主机, 确保运行正常.</p>
<hr>
<p>如果不能正常, 可以直接进入该容器, 尝试运行Django自带的WSGI服务器, 用以检查Django项目的完整性:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it uwsgi /bin/bash</span><br><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p>测试缓存能否正常工作</p>
<p>进入shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure>

<p>访问缓存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line">cache.set(<span class="string">'my_key'</span>, <span class="string">'hello, world!'</span>, <span class="number">30</span>)</span><br><span class="line">cache.get(<span class="string">'my_key'</span>)</span><br></pre></td></tr></table></figure>

<p>如果使用的数据库是新建立的, 还需要进行数据库同步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations &amp;&amp; python manage.py migrate</span><br></pre></td></tr></table></figure>

<hr>
<p>在测试访问一切正常后, 停止该容器, 接下来让uWSGI以socket模式运行, 并取消容器与宿主机之间的映射端口, 只允许通过容器间通信进行访问.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name uwsgi --expose 8001 --link redis -v /webapp:/usr/src/webapp uwsgi-image</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Nginx容器"><a href="#Nginx容器" class="headerlink" title="Nginx容器"></a>Nginx容器</h3><p>Nginx容器作为前端服务器, 主要提供三个功能</p>
<ol>
<li>将vue项目的index.html直接返回给客户端</li>
<li>处理任何静态资源请求</li>
<li>以uwsgi协议转发请求至uwsgi容器</li>
</ol>
<p>首先编写Nginx配置文件<code>nginx.conf</code>, 置于宿主机<code>/nginx/</code>目录下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> root;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>    mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line">    <span class="attribute">gzip</span>                  <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> uwsgi &#123;</span><br><span class="line">        <span class="attribute">server</span> uwsgi:<span class="number">8001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">root</span> /nginx/home;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /media &#123;</span><br><span class="line">            <span class="attribute">root</span> /;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /static &#123;</span><br><span class="line">            <span class="attribute">root</span> /;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /api &#123;</span><br><span class="line">            <span class="attribute">uwsgi_pass</span> uwsgi;</span><br><span class="line">            <span class="attribute">include</span> uwsgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意配置中, 上游服务器使用uWSGI容器名<code>uwsgi</code>, 由Docker进行连接, 其次将vue项目build之后的index.html设为Nginx的首页文件.</p>
<p>假设vue项目的index.html置于宿主机<code>/vueproject/</code>目录下, 在运行nginx容器时将其映射至容器内指定的nginx首页文件位置.<br>并且由nginx处理静态资源请求, 所以将django项目的static文件夹和media文件夹也映射至配置文件指定的位置, 容器内根目录下:</p>
<p>首先测试配置文件的正确性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm --name nginx -p 80:80 --link uwsgi -v /vueproject:/nginx/home nginx -v /nginx/nginx.conf:/etc/nginx/nginx.conf:ro -v /webapp/static:/static -v /webapp/media:/media nginx nginx -t</span><br></pre></td></tr></table></figure>

<p>然后在前台启动nginx容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm --name nginx -p 80:80 --link uwsgi -v /vueproject:/nginx/home -v /nginx/nginx.conf:/etc/nginx/nginx.conf:ro -v /webapp/static:/static -v /webapp/media:/media nginx</span><br></pre></td></tr></table></figure>

<p>使用浏览器进行访问, 确认正常运行后将容器在后台启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 --link uwsgi -v /vueproject:/nginx/home -v /nginx/nginx.conf:/etc/nginx/nginx.conf:ro -v /webapp/static:/static -v /webapp/media:/media nginx</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Django</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>26. 设置 Settings</title>
    <url>/2019/10/03/26.%20%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>命名空间是一个很好的主意, 发扬光大吧!   – python之禅</p>
</blockquote>
<p>REST-framework的设置的命名空间被包含在单个Django设置项中, 即<code>REST_FRAMEWORK</code>.</p>
<p>例如, 在Django项目的<code>settings.py</code>文件中, 可能包含如下内容:</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="访问设置项"><a href="#访问设置项" class="headerlink" title="访问设置项"></a>访问设置项</h3><p>如果需要在项目中访问REST-framework的设置项的值, 需要使用<code>api_settings</code>对象, 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.settings <span class="keyword">import</span> api_settings</span><br><span class="line"></span><br><span class="line">print(api_settings.DEFAULT_AUTHENTICATION_CLASSES)</span><br></pre></td></tr></table></figure>

<p><code>api_settings</code>对象会检查所有用户定义的设置项, 以及未设置项的默认值. </p>
<p>任何使用字符串表示其导出路径的类会自动返回该类<strong>本身</strong>, 而非字符串. </p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="API策略设置"><a href="#API策略设置" class="headerlink" title="API策略设置"></a>API策略设置</h3><hr>
<h4 id="默认渲染器类"><a href="#默认渲染器类" class="headerlink" title="默认渲染器类"></a>默认渲染器类</h4><p><strong>DEFAULT_RENDERER_CLASSES</strong> </p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">    <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="默认解析器类"><a href="#默认解析器类" class="headerlink" title="默认解析器类"></a>默认解析器类</h4><p><strong>DEFAULT_PARSER_CLASSES</strong></p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">    <span class="string">'rest_framework.authentication.BasicAuthentication'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="默认权限类"><a href="#默认权限类" class="headerlink" title="默认权限类"></a>默认权限类</h4><p><strong>DEFAULT_PERMISSION_CLASSES</strong></p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'rest_framework.permissions.AllowAny'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="默认限流类"><a href="#默认限流类" class="headerlink" title="默认限流类"></a>默认限流类</h4><p><strong>DEFAULT_THROTTLE_CLASSES</strong></p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值: <code>[]</code></p>
<hr>
<h4 id="默认请求协商类"><a href="#默认请求协商类" class="headerlink" title="默认请求协商类"></a>默认请求协商类</h4><p><strong>DEFAULT_CONTENT_NEGOTIATION_CLASS</strong></p>
<p>数据格式: 字符串</p>
<p>默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'rest_framework.negotiation.DefaultContentNegotiation'</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="默认概要类"><a href="#默认概要类" class="headerlink" title="默认概要类"></a>默认概要类</h3><p><strong>DEFAULT_SCHEMA_CLASS</strong></p>
<p>数据格式: 字符串</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'rest_framework.schemas.AutoSchema'</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通用视图设置"><a href="#通用视图设置" class="headerlink" title="通用视图设置"></a>通用视图设置</h2><p>以下设置项控制通用CBV的行为.</p>
<hr>
<h3 id="默认过滤后端"><a href="#默认过滤后端" class="headerlink" title="默认过滤后端"></a>默认过滤后端</h3><p><strong>DEFAULT_FILTER_BACKENDS</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[]</code></p>
<hr>
<h3 id="默认分页类"><a href="#默认分页类" class="headerlink" title="默认分页类"></a>默认分页类</h3><p><strong>DEFAULT_PAGINATION_CLASS</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="分页大小"><a href="#分页大小" class="headerlink" title="分页大小"></a>分页大小</h3><p><strong>PAGE_SIZE</strong></p>
<p>数据类型: 整型</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="搜索参数名"><a href="#搜索参数名" class="headerlink" title="搜索参数名"></a>搜索参数名</h3><p><strong>SEARCH_PARAM</strong></p>
<p>用以调用查询后端的查询参数名</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>search</code></p>
<hr>
<h3 id="排序参数名"><a href="#排序参数名" class="headerlink" title="排序参数名"></a>排序参数名</h3><p><strong>ORDERING_PARAM</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>ordering</code></p>
<hr>
<h2 id="版本设置"><a href="#版本设置" class="headerlink" title="版本设置"></a>版本设置</h2><hr>
<h3 id="默认版本"><a href="#默认版本" class="headerlink" title="默认版本"></a>默认版本</h3><p><strong>DEFAULT_VERSION</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="允许的版本"><a href="#允许的版本" class="headerlink" title="允许的版本"></a>允许的版本</h3><p><strong>ALLOWED_VERSION</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="版本参数名"><a href="#版本参数名" class="headerlink" title="版本参数名"></a>版本参数名</h3><p><strong>VERSION_PARAM</strong></p>
<p>用以指示版本的查询参数名或url变量名或其他指示版本的相关参数名</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>version</code></p>
<hr>
<h2 id="认证设置"><a href="#认证设置" class="headerlink" title="认证设置"></a>认证设置</h2><h3 id="默认未认证用户"><a href="#默认未认证用户" class="headerlink" title="默认未认证用户"></a>默认未认证用户</h3><p><strong>UNAUTHENTICATED_USER</strong></p>
<p>未经认证的请求中的<code>request.user</code>属性中应当填充的类, 如果完全取消认证时, 该项应当被设为<code>None</code></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>django.contrib.auth.models.AnonymousUser</code></p>
<hr>
<h3 id="默认未认证凭证"><a href="#默认未认证凭证" class="headerlink" title="默认未认证凭证"></a>默认未认证凭证</h3><p><strong>UNAUTHENTICATED_TOKEN</strong></p>
<p>同上, 需要为未认证请求的<code>.auth</code>属性填充的类.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>None</code></p>
<hr>
<h2 id="测试设置"><a href="#测试设置" class="headerlink" title="测试设置"></a>测试设置</h2><p>以下各项控制<code>APIRequestFactory</code>和<code>APIClient</code>的行为.</p>
<hr>
<h3 id="默认测试请求的数据格式"><a href="#默认测试请求的数据格式" class="headerlink" title="默认测试请求的数据格式"></a>默认测试请求的数据格式</h3><p><strong>TEST_REQUEST_DEFAULT_FORMAT</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>multipart</code></p>
<hr>
<h3 id="测试请求渲染类"><a href="#测试请求渲染类" class="headerlink" title="测试请求渲染类"></a>测试请求渲染类</h3><p><strong>TEST_REQUEST_RENDERER_CLASSES</strong> </p>
<p>数据类型: 字符串列表</p>
<p>默认值: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &apos;rest_framework.renderers.MultiPartRenderer&apos;,</span><br><span class="line">    &apos;rest_framework.renderers.JSONRenderer&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API概要生成控制"><a href="#API概要生成控制" class="headerlink" title="API概要生成控制"></a>API概要生成控制</h2><h3 id="概要强制路径主键"><a href="#概要强制路径主键" class="headerlink" title="概要强制路径主键"></a>概要强制路径主键</h3><p><strong>SCHEMA_COERCE_PATH_PK</strong></p>
<p>是否在生成url时将路径中的<code>PK</code>标识符映射至实际字段名, 通常为<code>id</code>. 这会给出更清晰的概念, 因为主键是一个实现细节, 而标识符则是一个通用概念. </p>
<p>数据类型: 布尔型</p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="概要强制方法名"><a href="#概要强制方法名" class="headerlink" title="概要强制方法名"></a>概要强制方法名</h3><p><strong>SCHEMA_COERCE_METHOD_NAMES</strong></p>
<p>定义一个映射关系, 用以将视图集的方法名映射为表义更清晰的外部操作名.</p>
<p>数据类型: Dict</p>
<p>默认值: <code>{&#39;retrieve&#39;: &#39;read&#39;, &#39;destroy&#39;: &#39;delete&#39;}</code></p>
<hr>
<h2 id="内容类型控制"><a href="#内容类型控制" class="headerlink" title="内容类型控制"></a>内容类型控制</h2><hr>
<h3 id="URL格式重写"><a href="#URL格式重写" class="headerlink" title="URL格式重写"></a>URL格式重写</h3><p><strong>URL_FORMAT_OVERRIDE</strong></p>
<p>用以表示重写默认内容协商<code>Accept</code>结果的URL参数名, 设为<code>None</code>时禁用.</p>
<p>示例: <code>http://example.com/organizations/?format=csv</code></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>format</code></p>
<hr>
<h3 id="格式后缀关键字"><a href="#格式后缀关键字" class="headerlink" title="格式后缀关键字"></a>格式后缀关键字</h3><p><strong>FORMAT_SUFFIX_KWARG</strong></p>
<p><strong>可能</strong>用以给URL提供格式后缀的关键字参数名, 在使用<code>format_suffix_patterns</code>时会使用该项设置.</p>
<p>示例: <code>http://example.com/organizations.csv/</code>, <code>.csv</code>会匹配至<code>format</code>变量名</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>format</code></p>
<hr>
<h2 id="日期时间格式"><a href="#日期时间格式" class="headerlink" title="日期时间格式"></a>日期时间格式</h2><p>以下设置项控制日期和时间类型被如何解析和渲染.</p>
<hr>
<h3 id="DateTime的渲染格式"><a href="#DateTime的渲染格式" class="headerlink" title="DateTime的渲染格式"></a>DateTime的渲染格式</h3><p><strong>DATETIME_FORMAT</strong></p>
<p>在渲染序列化器<code>DateTimeField</code>字段时为其使用的格式字符串, 如果设为<code>None</code>, 返回的是python中<code>datetime</code>对象, 编码则取决于渲染器.</p>
<p>可以为 <code>None</code>, <code>iso-8601</code>或python中srtftime format可用的字符串.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>iso-8601</code></p>
<hr>
<h3 id="DateTime的输入解析格式"><a href="#DateTime的输入解析格式" class="headerlink" title="DateTime的输入解析格式"></a>DateTime的输入解析格式</h3><p><strong>DATETIME_INPUT_FORMATS</strong></p>
<p>可以用以解析原始数据以传入序列化器<code>DateTimeField</code>的格式字符串的列表.</p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[&#39;iso-8601&#39;]</code></p>
<hr>
<h3 id="Date渲染格式"><a href="#Date渲染格式" class="headerlink" title="Date渲染格式"></a>Date渲染格式</h3><p><strong>DATE_FORMAT</strong></p>
<p>与<code>DATETIME_FORMAT</code>类似, 但作用于<code>DateField</code></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>iso-8601</code></p>
<hr>
<h3 id="Date输入解析格式"><a href="#Date输入解析格式" class="headerlink" title="Date输入解析格式"></a>Date输入解析格式</h3><p><strong>DATE_INPUT_FORMATS</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[&#39;iso-8601&#39;]</code></p>
<hr>
<h3 id="TIME渲染格式"><a href="#TIME渲染格式" class="headerlink" title="TIME渲染格式"></a>TIME渲染格式</h3><p><strong>TIME_FORMAT</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>iso-8601</code></p>
<hr>
<h3 id="Time输入解析格式"><a href="#Time输入解析格式" class="headerlink" title="Time输入解析格式"></a>Time输入解析格式</h3><p><strong>TIME_INPUT_FORMATS</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[&#39;iso-8601&#39;]</code></p>
<hr>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="UNICODE-JSON-允许unicode字符的JSON响应"><a href="#UNICODE-JSON-允许unicode字符的JSON响应" class="headerlink" title="UNICODE_JSON 允许unicode字符的JSON响应"></a>UNICODE_JSON 允许unicode字符的JSON响应</h3><p>设为True时, json响应将允许unicode字符.</p>
<p>例如: <code>{&quot;unicode black star&quot;:&quot;★&quot;}</code></p>
<p>当设置为False, json响应将对非ASCII字符进行转义</p>
<p>例如: <code>{&quot;unicode black star&quot;:&quot;\u2605&quot;}</code></p>
<p>数据类型: 布尔型</p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="COMPACT-JSON-紧缩格式的JSON响应"><a href="#COMPACT-JSON-紧缩格式的JSON响应" class="headerlink" title="COMPACT_JSON 紧缩格式的JSON响应"></a>COMPACT_JSON 紧缩格式的JSON响应</h3><p>设为True时, json响应的<code>,</code>和<code>:</code>之后不会有空格, 例如: </p>
<p><code>{&quot;is_admin&quot;:false,&quot;email&quot;:&quot;jane@example&quot;}</code></p>
<p>设为False则为略带冗余的格式, 例如: </p>
<p><code>{&quot;is_admin&quot;: false, &quot;email&quot;: &quot;jane@example&quot;}</code></p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="STRICT-JSON-严格JSON"><a href="#STRICT-JSON-严格JSON" class="headerlink" title="STRICT_JSON 严格JSON"></a>STRICT_JSON 严格JSON</h3><p>当设为<code>True</code>时, json渲染时会验证检查json语法的正确性, 并确保不会使用不被广泛接受的值.</p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="COERCE-DECIMAL-TO-STRING-强制将十进制转为字符串"><a href="#COERCE-DECIMAL-TO-STRING-强制将十进制转为字符串" class="headerlink" title="COERCE_DECIMAL_TO_STRING 强制将十进制转为字符串"></a>COERCE_DECIMAL_TO_STRING 强制将十进制转为字符串</h3><p>在不支持本机十进制类型的API表示形式中返回十进制对象时, 通常最好将该值作为字符串返回以避免了二进制浮点实现所带来的精度损失.</p>
<p>设为True时, 序列化器字段<code>DecimalField</code>会返回字符串而非十进制对象.</p>
<p>默认值:<code>True</code></p>
<hr>
<h2 id="视图命名和描述"><a href="#视图命名和描述" class="headerlink" title="视图命名和描述"></a>视图命名和描述</h2><p>以下选项控制如何生成收到<code>option</code>请求时返回的视图名和描述.</p>
<hr>
<h3 id="VIEW-NAME-FUNCTION-生成视图名的函数"><a href="#VIEW-NAME-FUNCTION-生成视图名的函数" class="headerlink" title="VIEW_NAME_FUNCTION 生成视图名的函数"></a>VIEW_NAME_FUNCTION 生成视图名的函数</h3><p>一个用以生成视图名的函数的路径的字符串. </p>
<p>该函数的签名需为: <code>view_name(self)</code></p>
<p>self: 该view实例. 通常命名函数会检查<strong>类名</strong>, 通过访问<code>self.__class__.__name__</code>.</p>
<p>如果视图继承自<code>ViewSet</code>, 可能会在初始化时包含一些可选参数:</p>
<ol>
<li>name 明确指定的视图名</li>
<li>suffix 区分视图集中各个视图时使用的文本, 与<code>name</code>参数互斥</li>
<li>detail 是否是<code>detail</code>操作视图</li>
</ol>
<p>(视图集中每个视图都需要不同的视图名)</p>
<p>数据类型: 字符串(路径)</p>
<p>默认值: <code>rest_framework.views.get_view_name</code></p>
<hr>
<h3 id="VIEW-DESCRIPTION-FUNCTION-生成视图描述的函数"><a href="#VIEW-DESCRIPTION-FUNCTION-生成视图描述的函数" class="headerlink" title="VIEW_DESCRIPTION_FUNCTION 生成视图描述的函数"></a>VIEW_DESCRIPTION_FUNCTION 生成视图描述的函数</h3><p>一个表示函数路径的字符串, 该函数用以生成视图描述</p>
<p>该函数签名需为: <code>view_description(self, html=False)</code></p>
<p>self: 该view实例. 通常应当检查该view的描述性属性, 通过访问<code>self.__class__.__doc__</code><br>html: 是否需要在html输入中包含, 设为True会在browseable API中显示, 设为False会仅在产生<code>OPTION</code>响应时使用.</p>
<p>如果该视图继承自<code>ViewSet</code>, 可能会在初始化时包含一些可选参数:</p>
<ol>
<li>description: 明确指定的描述性文本属性.</li>
</ol>
<p>数据类型: 字符串(路径)</p>
<p>默认值: <code>rest_framework.views.get_view_description</code></p>
<hr>
<h2 id="HTML页面选项截断"><a href="#HTML页面选项截断" class="headerlink" title="HTML页面选项截断"></a>HTML页面选项截断</h2><p>在某个关系字段被渲染至browseable API页面时, 对于关系字段会给出可用选项, 需要指定最多展示多少个选项以及截断时的文本.</p>
<hr>
<h3 id="HTML-SELECT-CUTOFF-HTML选项截断"><a href="#HTML-SELECT-CUTOFF-HTML选项截断" class="headerlink" title="HTML_SELECT_CUTOFF HTML选项截断"></a>HTML_SELECT_CUTOFF HTML选项截断</h3><p>html页面中, 关系字段最多显示多少个选项. <code>html_cutoff</code>属性的全局设置.</p>
<p>数据类型: 整型</p>
<p>默认值: <code>1000</code></p>
<hr>
<h3 id="HTML-SELECT-CUTOFF-TEXT-HTML选项截断文本"><a href="#HTML-SELECT-CUTOFF-TEXT-HTML选项截断文本" class="headerlink" title="HTML_SELECT_CUTOFF_TEXT HTML选项截断文本"></a>HTML_SELECT_CUTOFF_TEXT HTML选项截断文本</h3><p>html页面中, 在选项截断处显示的文本. <code>html_cutoff_text</code>属性的全局设置.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>More than {count} items...</code></p>
<hr>
<h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><h3 id="默认异常处理器"><a href="#默认异常处理器" class="headerlink" title="默认异常处理器"></a>默认异常处理器</h3><p><strong>EXCEPTION_HANDLER</strong></p>
<p>该函数需有签名 <code>exception_handler(exc, context)</code></p>
<p>数据类型: 字符串(路径)</p>
<p>默认值: <code>rest_framework.views.exception_handler</code></p>
<hr>
<h3 id="字段无关的错误关键字"><a href="#字段无关的错误关键字" class="headerlink" title="字段无关的错误关键字"></a>字段无关的错误关键字</h3><p><strong>NON_FIELD_ERRORS_KEY</strong></p>
<p>出现在errors中的与任何字段无关的出错信息的关键字.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>non_field_errors</code></p>
<hr>
<h3 id="URL字段名"><a href="#URL字段名" class="headerlink" title="URL字段名"></a>URL字段名</h3><p><strong>URL_FIELD_NAME</strong></p>
<p>在使用<code>HyperlinkedModelSerializer</code>时, 应用于超链接的字段名.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>url</code></p>
<hr>
<h3 id="代理数量"><a href="#代理数量" class="headerlink" title="代理数量"></a>代理数量</h3><p><strong>NUM_PROXIES</strong></p>
<p>0或更大的整型, 指明API运行在几层代理之后, 允许<strong>限流</strong>功能更准确的判断客户端ip地址. </p>
<p>如果设置为None, 限流类将会使用不严格匹配来进行限流. </p>
<p>数据类型: 整型, <code>None</code></p>
<p>默认值: <code>None</code></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>25. 测试 Testing</title>
    <url>/2019/10/03/25.%20%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>无测试的代码就是设计好的失败.   — Jacob Kaplan-Moss</p>
</blockquote>
<p>REST-framework 包含了一些辅助类用以拓展Django现存的测试框架, 并增强了对发起API请求的支持.</p>
<a id="more"></a>

<hr>
<h2 id="APIRequestFactory"><a href="#APIRequestFactory" class="headerlink" title="APIRequestFactory"></a>APIRequestFactory</h2><p>拓展了Django的<a href="https://docs.djangoproject.com/en/stable/topics/testing/advanced/#django.test.client.RequestFactory" target="_blank" rel="noopener">RequestFactory</a></p>
<hr>
<h3 id="创建测试请求"><a href="#创建测试请求" class="headerlink" title="创建测试请求"></a>创建测试请求</h3><p><code>APIRequestFactory</code>支持与Django的<code>RequestFactory</code>相同的接口, 包括<code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.patch()</code>, <code>.delete()</code>, <code>.head()</code>和<code>.options()</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APIRequestFactory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the standard RequestFactory API to create a form POST request</span></span><br><span class="line">factory = APIRequestFactory()</span><br><span class="line">request = factory.post(<span class="string">'/notes/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="使用format参数"><a href="#使用format参数" class="headerlink" title="使用format参数"></a>使用<code>format</code>参数</h4><p>附加请求体的方法例如<code>post</code>, <code>put</code>和<code>patch</code>, 会包括一个<code>format</code>参数, 用以简单地生成非multipart form data地内容类型的请求, 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a JSON POST request</span></span><br><span class="line">factory = APIRequestFactory()</span><br><span class="line">request = factory.post(<span class="string">'/notes/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;, format=<span class="string">'json'</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下, 可用的格式为<code>multipart</code>和<code>json</code>, 为了兼容Django现存的<code>RequestFactory</code>的默认格式<code>multiparty</code>.</p>
<p>要支持更多的请求格式, 或更改默认的格式, 查看本节<code>设置</code>部分. </p>
<hr>
<h4 id="指定请求体的编码"><a href="#指定请求体的编码" class="headerlink" title="指定请求体的编码"></a>指定请求体的编码</h4><p>如果要明确指明请求体部分的编码, 需要设置<code>content_type</code>标识. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request = factory.post(<span class="string">'/notes/'</span>, json.dumps(&#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;), content_type=<span class="string">'application/json'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="使用form-data进行PUT和PATCH"><a href="#使用form-data进行PUT和PATCH" class="headerlink" title="使用form data进行PUT和PATCH"></a>使用form data进行PUT和PATCH</h3><p>在使用<code>APIRequestFactory</code>时, 除<code>post</code>方法之外的请求会自动编码为multipart form data.</p>
<p>例如使用<code>APIRequestFactory</code>发起PUT请求:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factory = APIRequestFactory()</span><br><span class="line">request = factory.put(<span class="string">'/notes/547/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'remember to email dave'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="强制身份认证"><a href="#强制身份认证" class="headerlink" title="强制身份认证"></a>强制身份认证</h3><p>当使用请求工厂测试视图时, 通常能够很方便地对直接请求进行身份验证, 而不必构造正确的身份验证凭据.</p>
<p>要强制认证一个请求, 使用<code>force_authenticate()</code>方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> force_authenticate</span><br><span class="line"></span><br><span class="line">factory = APIRequestFactory()</span><br><span class="line">user = User.objects.get(username=<span class="string">'olivia'</span>)</span><br><span class="line">view = AccountDetail.as_view()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make an authenticated request to the view...</span></span><br><span class="line">request = factory.get(<span class="string">'/accounts/django-superstars/'</span>)</span><br><span class="line">force_authenticate(request, user=user)</span><br><span class="line">response = view(request)</span><br></pre></td></tr></table></figure>

<p>签名: <code>force_authenticate(request, user=None, token=None)</code></p>
<p>当调用该方法时, 至少设置user或token其中一项.</p>
<p>如果要使用token进行认证, 可能需要如下进行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.get(username=<span class="string">'olivia'</span>)</span><br><span class="line">request = factory.get(<span class="string">'/accounts/django-superstars/'</span>)</span><br><span class="line">force_authenticate(request, user=user, token=user.auth_token)</span><br></pre></td></tr></table></figure>

<p>注意, <code>force_authenticate</code>方法会直接使用内存中的<code>user</code>实例来设置<code>request.user</code>, 如果需要对同一个<code>user</code>进行多个可能会影响到user状态的测试, 应该在各个测试间调用<code>refresh_from_db()</code>.</p>
<p>注意, 当使用<code>APIRequestFactory</code>时, 返回的是django标准的<code>HttpRequest</code>, 而非Rest framework的<code>Request</code>对象, 该对象仅会在API视图被调用的时候生成一次.</p>
<p>这意味着, 直接设置请求对象的属性可能不会如预期一样生效, 例如, 直接设置<code>.token</code>属性无效, 直接设置<code>.user</code>仅在使用session认证时生效.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Request will only authenticate if `SessionAuthentication` is in use.</span></span><br><span class="line">request = factory.get(<span class="string">'/accounts/django-superstars/'</span>)</span><br><span class="line">request.user = user</span><br><span class="line">response = view(request)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="强制CSRF验证"><a href="#强制CSRF验证" class="headerlink" title="强制CSRF验证"></a>强制CSRF验证</h3><p>默认情况下, 由<code>APIRequestFactory</code>生成的请求不会带有合法的csrf, 如果要强制使请求的csrf认证合法, 需要在初始化<code>APIRequestFactory</code>时设置<code>enforce_csrf_checks</code>标识.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factory = APIRequestFactory(enforce_csrf_checks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>注意, django的标准<code>RequestFactory</code>不用包含此选项, 因为常规Django的csrf验证发生在中间件中, 该中间件在测试视图时不会运行. 而REST framework的csrf验证发生在视图内部, 所以请求工厂需要将试图级别的csrf验证检查禁用.</p>
<hr>
<h2 id="APIClient"><a href="#APIClient" class="headerlink" title="APIClient"></a>APIClient</h2><p>拓展了Django现存的<a href="https://docs.djangoproject.com/en/2.2/topics/testing/tools/#the-test-client" target="_blank" rel="noopener"><code>Client</code></a>类.</p>
<h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p><code>APIClient</code>类支持与Django标准的<code>Client</code>类相同的接口, 意味着标准的<code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.patch()</code>, <code>.delete()</code>, <code>.head()</code>和<code>.options()</code>方法都可以使用. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APIClient</span><br><span class="line"></span><br><span class="line">client = APIClient()</span><br><span class="line">client.post(<span class="string">'/notes/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;, format=<span class="string">'json'</span>)</span><br></pre></td></tr></table></figure>

<p>要支持更多请求格式, 或更改默认格式, 查看本节<code>设置</code>部分.</p>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><hr>
<h4 id="login-kwargs"><a href="#login-kwargs" class="headerlink" title=".login(**kwargs)"></a><code>.login(**kwargs)</code></h4><p>login方法与其在Django<code>Client</code>中的表现相同, 允许对所有支持<code>SessionAuthentication</code>的视图进行请求认证.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Make all requests in the context of a logged in session.</span></span><br><span class="line">client = APIClient()</span><br><span class="line">client.login(username=<span class="string">'lauren'</span>, password=<span class="string">'secret'</span>)</span><br></pre></td></tr></table></figure>

<p>要注销登陆, 调用<code>logout</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Log out</span></span><br><span class="line">client.logout()</span><br></pre></td></tr></table></figure>

<p>login方法对于测试支持会话认证的API非常合适, 例如包含了AJAX交互的网站.</p>
<hr>
<h4 id="credentials-kwargs"><a href="#credentials-kwargs" class="headerlink" title=".credentials(**kwargs)"></a><code>.credentials(**kwargs)</code></h4><p><code>credentials</code>方法可以设置被之后所有测试客户端产生的请求共同使用的请求头.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authtoken.models <span class="keyword">import</span> Token</span><br><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APIClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># Include an appropriate `Authorization:` header on all requests.</span></span><br><span class="line">token = Token.objects.get(user__username=<span class="string">'lauren'</span>)</span><br><span class="line">client = APIClient()</span><br><span class="line">client.credentials(HTTP_AUTHORIZATION=<span class="string">'Token '</span> + token.key)</span><br></pre></td></tr></table></figure>

<p>注意, 再次调用<code>credentials</code>方法会重写任何现有的credentials, 可以通过不带参数地调用该方法来清空现有地credentials.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Stop including any credentials</span></span><br><span class="line">client.credentials()</span><br></pre></td></tr></table></figure>

<p>该方法适合测试那些需要包含认证头的API, 例如基本认证, OAuth1a和OAuth2认证, 以及简单的token认证方案.</p>
<hr>
<p><strong><code>.force_authenticate(user=None, token=None)</code></strong></p>
<p>有时需要绕过认证, 并让所有请求被自动视为已通过认证.</p>
<p>如果在测试时不想构造合法的认证凭证, 使用该快捷方式可能相当有用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.get(username=<span class="string">'lauren'</span>)</span><br><span class="line">client = APIClient()</span><br><span class="line">client.force_authenticate(user=user)</span><br></pre></td></tr></table></figure>

<p>如果要取消认证, 再次调用该方法将user和/或token设为None即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client.force_authenticate(user=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CSRF验证"><a href="#CSRF验证" class="headerlink" title="CSRF验证"></a>CSRF验证</h3><p>默认当使用<code>APIClient</code>时CSRF验证未开启, 如果需要启用CSRF验证, 需要在初始化客户端的时候设置<code>enforce_csrf_checks</code>标识.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = APIClient(enforce_csrf_checks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>与正常情况一样, CSRF仅会对使用会话认证的视图生效, 这意味着CSRF验证仅会发生在使用<code>.login()</code>登陆之后.</p>
<hr>
<h2 id="RequestClient"><a href="#RequestClient" class="headerlink" title="RequestClient"></a>RequestClient</h2><p>REST framework提供了一个使用python库<code>request</code>与应用进行交互的客户端, 在以下情况下可能很有用:</p>
<ol>
<li>期望主要通过另一个python服务与API进行交互, 并想要测试与客户端同级别的结果.</li>
<li>期望实时测试.(参见本节<strong>实时测试</strong>部分)</li>
</ol>
<p>它暴露了与直接使用请求会话完全相同的接口.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> RequestsClient</span><br><span class="line"></span><br><span class="line">client = RequestsClient()</span><br><span class="line">response = client.get(<span class="string">'http://testserver/users/'</span>)</span><br><span class="line"><span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>注意<code>RequestClient</code>需要传递绝对URL.</p>
<hr>
<h3 id="与数据库的交互"><a href="#与数据库的交互" class="headerlink" title="与数据库的交互"></a>与数据库的交互</h3><p>当仅要测试服务接口的<strong>交互</strong>时, <code>ReqeustClient</code>是非常有效的, 比使用标准的Django测试客户端稍加严格, 因此意味着所有的交互都通过API.</p>
<p>如果使用<code>RequestClient</code>时, 需要确保所有的设置和断言是通过常规API调用进行的, 而非直接与数据库模型进行交互, 例如应该直接列出所有Costumer的实例确保其确实包含三条记录而非直接检查<code>Customer.objects.count() == 3</code>.</p>
<h3 id="请求头和认证"><a href="#请求头和认证" class="headerlink" title="请求头和认证"></a>请求头和认证</h3><p>需要与使用标准的<code>request.Session</code>实例时相同的方式自定义请求头和认证凭证.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">client.auth = HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">client.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>如果使用基于会话的身份认证, 需要在任何<code>POST</code>, <code>PUT</code>, <code>PATCH</code>或<code>DELETE</code>请求中包含csrf凭证.</p>
<p>你可以使用基于js的客户端同样的方式, 先发起<code>GET</code>请求获取CSRF凭证, 然后将其包含在请求头中发送:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = RequestsClient()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Obtain a CSRF token.</span></span><br><span class="line">response = client.get(<span class="string">'http://testserver/homepage/'</span>)</span><br><span class="line"><span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">csrftoken = response.cookies[<span class="string">'csrftoken'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interact with the API.</span></span><br><span class="line">response = client.post(<span class="string">'http://testserver/organisations/'</span>, json=&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'MegaCorp'</span>,</span><br><span class="line">    <span class="string">'status'</span>: <span class="string">'active'</span></span><br><span class="line">&#125;, headers=&#123;<span class="string">'X-CSRFToken'</span>: csrftoken&#125;)</span><br><span class="line"><span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="实时测试"><a href="#实时测试" class="headerlink" title="实时测试"></a>实时测试</h3><p><code>RequestClient</code>和<code>CoreAPIClient</code>都可以编写可以在开发或生产环境直接运行的测试用例.</p>
<p>使用这种方式创建对少量核心函数的测试, 对于运行中的服务相当有效. 这样做需要谨慎地开始和终止, 以确保测试不会以影响客户数据的方式进行.</p>
<hr>
<h2 id="CoreAPIClient"><a href="#CoreAPIClient" class="headerlink" title="CoreAPIClient"></a>CoreAPIClient</h2><p><code>CoreClient</code>可以使用python的<code>coreapi</code>客户端库与API进行交互.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fetch the API schema</span></span><br><span class="line">client = CoreAPIClient()</span><br><span class="line">schema = client.get(<span class="string">'http://testserver/schema/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new organisation</span></span><br><span class="line">params = &#123;<span class="string">'name'</span>: <span class="string">'MegaCorp'</span>, <span class="string">'status'</span>: <span class="string">'active'</span>&#125;</span><br><span class="line">client.action(schema, [<span class="string">'organisations'</span>, <span class="string">'create'</span>], params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure that the organisation exists in the listing</span></span><br><span class="line">data = client.action(schema, [<span class="string">'organisations'</span>, <span class="string">'list'</span>])</span><br><span class="line"><span class="keyword">assert</span>(len(data) == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span>(data == [&#123;<span class="string">'name'</span>: <span class="string">'MegaCorp'</span>, <span class="string">'status'</span>: <span class="string">'active'</span>&#125;])</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="请求头-amp-认证"><a href="#请求头-amp-认证" class="headerlink" title="请求头&amp;认证"></a>请求头&amp;认证</h3><p>使用于<code>RequestClient</code>相似的方式来自定义请求头和认证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">client = CoreAPIClient()</span><br><span class="line">client.session.auth = HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">client.session.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API测试用例"><a href="#API测试用例" class="headerlink" title="API测试用例"></a>API测试用例</h2><p>REST framework包含了以下的测试用例类, 与Django的测试用例类相同, 但使用的是<code>APIClient</code>.而非<code>Client</code>.</p>
<ul>
<li>APISimpleTestCase</li>
<li>APITransactionTestCase</li>
<li>APITestCase</li>
<li>APILiveServerTestCase</li>
</ul>
<p>示例:</p>
<p>可以像使用常规Django测试用例类一样使用任何REST framework测试用例类. <code>self.client</code>会是一个<code>APIClient</code>实例.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountTests</span><span class="params">(APITestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_create_account</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Ensure we can create a new account object.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = reverse(<span class="string">'account-list'</span>)</span><br><span class="line">        data = &#123;<span class="string">'name'</span>: <span class="string">'DabApps'</span>&#125;</span><br><span class="line">        response = self.client.post(url, data, format=<span class="string">'json'</span>)</span><br><span class="line">        self.assertEqual(response.status_code, status.HTTP_201_CREATED)</span><br><span class="line">        self.assertEqual(Account.objects.count(), <span class="number">1</span>)</span><br><span class="line">        self.assertEqual(Account.objects.get().name, <span class="string">'DabApps'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="URLPatternsTestCase"><a href="#URLPatternsTestCase" class="headerlink" title="URLPatternsTestCase"></a>URLPatternsTestCase</h3><p>REST-framework还提供了一个测试用例类用以按类隔离url pattern, 继承自Django的SimpleTestCase, 很可能与其他测试用例类混合使用.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path, reverse</span><br><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APITestCase, URLPatternsTestCase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountTests</span><span class="params">(APITestCase, URLPatternsTestCase)</span>:</span></span><br><span class="line">    urlpatterns = [</span><br><span class="line">        path(<span class="string">'api/'</span>, include(<span class="string">'api.urls'</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_create_account</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Ensure we can create a new account object.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = reverse(<span class="string">'account-list'</span>)</span><br><span class="line">        response = self.client.get(url, format=<span class="string">'json'</span>)</span><br><span class="line">        self.assertEqual(response.status_code, status.HTTP_200_OK)</span><br><span class="line">        self.assertEqual(len(response.data), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="测试响应"><a href="#测试响应" class="headerlink" title="测试响应"></a>测试响应</h2><hr>
<h3 id="检查响应数据"><a href="#检查响应数据" class="headerlink" title="检查响应数据"></a>检查响应数据</h3><p>在检查响应的合法性时通常直接检查其包含数据的合法性, 相较于检查完全渲染后的响应更为方便. </p>
<p>例如, 检查<code>response.data</code>更为方便:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = self.client.get(<span class="string">'/users/4/'</span>)</span><br><span class="line">self.assertEqual(response.data, &#123;<span class="string">'id'</span>: <span class="number">4</span>, <span class="string">'username'</span>: <span class="string">'lauren'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>而非检查<code>response.content</code>的解析结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = self.client.get(<span class="string">'/users/4/'</span>)</span><br><span class="line">self.assertEqual(json.loads(response.content), &#123;<span class="string">'id'</span>: <span class="number">4</span>, <span class="string">'username'</span>: <span class="string">'lauren'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="渲染响应"><a href="#渲染响应" class="headerlink" title="渲染响应"></a>渲染响应</h3><p>如果直接使用<code>APIRequestFactory</code>测试视图, 返回的响应未经渲染, 因为模板响应的呈现是由Django的内部请求-响应周期执行的(TemplateResponse是在中间件中被渲染的), 为了访问response.content, 首先手动进行渲染. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">view = UserDetail.as_view()</span><br><span class="line">request = factory.get(<span class="string">'/users/4'</span>)</span><br><span class="line">response = view(request, pk=<span class="string">'4'</span>)</span><br><span class="line">response.render()  <span class="comment"># Cannot access `response.content` without this.</span></span><br><span class="line">self.assertEqual(response.content, <span class="string">'&#123;"username": "lauren", "id": 4&#125;'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><hr>
<h3 id="设置默认格式"><a href="#设置默认格式" class="headerlink" title="设置默认格式"></a>设置默认格式</h3><p>使用<code>TEST_REQUEST_DEFAULT_FORMAT</code>设置项来设置测试请求的默认格式, 例如, 使用json格式来替换默认的multipartform格式, 如下设置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'TEST_REQUEST_DEFAULT_FORMAT'</span>: <span class="string">'json'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置可用的格式"><a href="#设置可用的格式" class="headerlink" title="设置可用的格式"></a>设置可用的格式</h3><p>如果要使用json或multipart之外的格式, 可以使用<code>TEST_REQUEST_RENDERER_CLASSES</code>设置项进行设置.</p>
<p>例如, 为了支持<code>format=&#39;html&#39;</code>的请求, 需要在设置文件中如下设置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'TEST_REQUEST_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.MultiPartRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.TemplateHTMLRenderer'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 状态码 Status</title>
    <url>/2019/10/03/24.%20%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p>在响应中使用纯粹的状态码并不推荐, rest-framework提供了一系列<strong>命名常量</strong>, 使用这些常量会让代码更加清晰可读.</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_view</span><span class="params">(self)</span>:</span></span><br><span class="line">    content = &#123;<span class="string">'please move along'</span>: <span class="string">'nothing to see here'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> Response(content, status=status.HTTP_404_NOT_FOUND)</span><br></pre></td></tr></table></figure>

<p>包含在<code>status</code>模块中的所有状态码会在下面列出.</p>
<p>该模块同样包含了一个辅助函数用以测试一个状态码是否在某一个区间内.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APITestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleTestCase</span><span class="params">(APITestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_url_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = reverse(<span class="string">'index'</span>)</span><br><span class="line">        response = self.client.get(url)</span><br><span class="line">        self.assertTrue(status.is_success(response.status_code))</span><br></pre></td></tr></table></figure>

<p>HTTP状态码的合适使用方式请参考<a href>RFC 2616</a> 和<a href>RFC 6585</a>.</p>
<hr>
<h3 id="信息提示-1xx"><a href="#信息提示-1xx" class="headerlink" title="信息提示 - 1xx"></a>信息提示 - 1xx</h3><p>这类响应码代表了临时响应. rest-framework默认未使用该类状态码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_100_CONTINUE</span><br><span class="line">HTTP_101_SWITCHING_PROTOCOLS</span><br></pre></td></tr></table></figure>

<h3 id="成功-2xx"><a href="#成功-2xx" class="headerlink" title="成功 - 2xx"></a>成功 - 2xx</h3><p>这类响应码代表着客户端请求被成功收到, 理解并接收.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_200_OK</span><br><span class="line">HTTP_201_CREATED</span><br><span class="line">HTTP_202_ACCEPTED</span><br><span class="line">HTTP_203_NON_AUTHORITATIVE_INFORMATION</span><br><span class="line">HTTP_204_NO_CONTENT</span><br><span class="line">HTTP_205_RESET_CONTENT</span><br><span class="line">HTTP_206_PARTIAL_CONTENT</span><br><span class="line">HTTP_207_MULTI_STATUS</span><br><span class="line">HTTP_208_ALREADY_REPORTED</span><br><span class="line">HTTP_226_IM_USED</span><br></pre></td></tr></table></figure>

<h3 id="重定向-3xx"><a href="#重定向-3xx" class="headerlink" title="重定向 - 3xx"></a>重定向 - 3xx</h3><p>这类响应码代表着用户代理必须采取进一步的行动才能满足请求.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_300_MULTIPLE_CHOICES</span><br><span class="line">HTTP_301_MOVED_PERMANENTLY</span><br><span class="line">HTTP_302_FOUND</span><br><span class="line">HTTP_303_SEE_OTHER</span><br><span class="line">HTTP_304_NOT_MODIFIED</span><br><span class="line">HTTP_305_USE_PROXY</span><br><span class="line">HTTP_306_RESERVED</span><br><span class="line">HTTP_307_TEMPORARY_REDIRECT</span><br><span class="line">HTTP_308_PERMANENT_REDIRECT</span><br></pre></td></tr></table></figure>

<h3 id="客户端错误-4xx"><a href="#客户端错误-4xx" class="headerlink" title="客户端错误 - 4xx"></a>客户端错误 - 4xx</h3><p>这类状态码代表着(可能是)客户端错误. 在使用该类状态码的时候响应<strong>应当</strong>包含一个实体用以说明该错误状况的解释, 以及该错误是暂时的还是永久的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_400_BAD_REQUEST</span><br><span class="line">HTTP_401_UNAUTHORIZED</span><br><span class="line">HTTP_402_PAYMENT_REQUIRED</span><br><span class="line">HTTP_403_FORBIDDEN</span><br><span class="line">HTTP_404_NOT_FOUND</span><br><span class="line">HTTP_405_METHOD_NOT_ALLOWED</span><br><span class="line">HTTP_406_NOT_ACCEPTABLE</span><br><span class="line">HTTP_407_PROXY_AUTHENTICATION_REQUIRED</span><br><span class="line">HTTP_408_REQUEST_TIMEOUT</span><br><span class="line">HTTP_409_CONFLICT</span><br><span class="line">HTTP_410_GONE</span><br><span class="line">HTTP_411_LENGTH_REQUIRED</span><br><span class="line">HTTP_412_PRECONDITION_FAILED</span><br><span class="line">HTTP_413_REQUEST_ENTITY_TOO_LARGE</span><br><span class="line">HTTP_414_REQUEST_URI_TOO_LONG</span><br><span class="line">HTTP_415_UNSUPPORTED_MEDIA_TYPE</span><br><span class="line">HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE</span><br><span class="line">HTTP_417_EXPECTATION_FAILED</span><br><span class="line">HTTP_422_UNPROCESSABLE_ENTITY</span><br><span class="line">HTTP_423_LOCKED</span><br><span class="line">HTTP_424_FAILED_DEPENDENCY</span><br><span class="line">HTTP_426_UPGRADE_REQUIRED</span><br><span class="line">HTTP_428_PRECONDITION_REQUIRED</span><br><span class="line">HTTP_429_TOO_MANY_REQUESTS</span><br><span class="line">HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE</span><br><span class="line">HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS</span><br></pre></td></tr></table></figure>

<h3 id="服务器错误-5xx"><a href="#服务器错误-5xx" class="headerlink" title="服务器错误 - 5xx"></a>服务器错误 - 5xx</h3><p>这类响应码代表着服务端出错或无法执行该请求. 响应应当包含一个实体, 该实体中<strong>应当</strong>有对错误情况的说明, 以及该情况是暂时的或永久的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_500_INTERNAL_SERVER_ERROR</span><br><span class="line">HTTP_501_NOT_IMPLEMENTED</span><br><span class="line">HTTP_502_BAD_GATEWAY</span><br><span class="line">HTTP_503_SERVICE_UNAVAILABLE</span><br><span class="line">HTTP_504_GATEWAY_TIMEOUT</span><br><span class="line">HTTP_505_HTTP_VERSION_NOT_SUPPORTED</span><br><span class="line">HTTP_506_VARIANT_ALSO_NEGOTIATES</span><br><span class="line">HTTP_507_INSUFFICIENT_STORAGE</span><br><span class="line">HTTP_508_LOOP_DETECTED</span><br><span class="line">HTTP_509_BANDWIDTH_LIMIT_EXCEEDED</span><br><span class="line">HTTP_510_NOT_EXTENDED</span><br><span class="line">HTTP_511_NETWORK_AUTHENTICATION_REQUIRED</span><br></pre></td></tr></table></figure>

<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>以下辅助函数用以判断响应码属于哪一类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">is_informational()  <span class="comment"># 1xx</span></span><br><span class="line">is_success()        <span class="comment"># 2xx</span></span><br><span class="line">is_redirect()       <span class="comment"># 3xx</span></span><br><span class="line">is_client_error()   <span class="comment"># 4xx</span></span><br><span class="line">is_server_error()   <span class="comment"># 5xx</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 异常处理 Exception</title>
    <url>/2019/10/03/23.%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>当视图函数的执行过程中抛出异常, 即转入错误处理阶段. REST framework的视图能够处理各种异常, 并为其返回合适错误响应.</p>
<p>可以被处理的异常包括:</p>
<ol>
<li><code>APIException</code>的子类异常</li>
<li><code>django</code>的<code>Http404</code>异常</li>
<li><code>django</code>的<code>PermissionDenied</code>异常</li>
</ol>
<a id="more"></a>

<p>在各种情况下, rest_framework会返回合适的状态码和<code>content-type</code>头, 响应体部分会包含有关错误特征的更进一步的详细信息.</p>
<p>大多数错误响应在响应体会包含<code>detail</code>项.</p>
<p>例如如下请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE http://api.example.com/foo/bar HTTP/1.1</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>

<p>如果对该资源的<code>DELETE</code>操作被禁止, 收到的错误响应可能如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">405</span> Method Not Allowed</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: <span class="number">42</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"detail"</span>: <span class="string">"Method 'DELETE' not allowed."</span>&#125;</span><br></pre></td></tr></table></figure>

<p>验证器错误的处理可能稍有不同, 在响应中会包含字段名作为关键字. 如果验证错误并不明确指向某个字段, 会使用<code>non_field_errors</code>关键字, 或者在<code>NON_FIELD_ERRORS_KEY</code>设置的值.</p>
<p>验证错误响应可能如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: <span class="number">94</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"amount"</span>: [<span class="string">"A valid integer is required."</span>], </span><br><span class="line">	<span class="string">"description"</span>: [<span class="string">"This field may not be blank."</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h2><p>自定义错误处理函数应该包含两个参数<code>exc</code>和<code>context</code>, <code>exc</code>为API视图抛出的异常, 而<code>context</code>则是包含了任何额外上下文的字典, 例如当前正在被调用的视图等.</p>
<p>异常处理函数应该返回<code>Response</code>对象或者在无法处理该异常时返回<code>None</code>, 如果异常处理函数返回了<code>None</code>, 客户端最终接收到的就是一个<code>HTTP 500 server error</code>响应.</p>
<p>例如, 要在错误响应的body部分始终包含http状态码, 如下所示:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 405 Method Not Allowed</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">&#123;"status_code": 405, "detail": "Method 'DELETE' not allowed."&#125;</span><br></pre></td></tr></table></figure>

<p>则为了更改响应的风格, 可以这样自定义异常处理函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="comment"># Call REST framework's default exception handler first, </span></span><br><span class="line">    <span class="comment"># to get the standard error response.</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now add the HTTP status code to the response.</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response.data[<span class="string">'status_code'</span>] = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p><code>context</code>参数不会被默认的异常处理函数所使用, 不过如果想要获得额外信息例如当前使用的视图函数, 则可以用<code>context[&#39;view&#39;]</code>使用</p>
<p>异常处理函数必须被<code>EXCEPTION_HANDLER</code>设置项指定, 然后才会被应用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'my_project.my_app.utils.custom_exception_handler'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不指定, 则默认使用rest_framework的默认异常处理器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'rest_framework.views.exception_handler'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意该异常处理函数仅会在抛出异常时调用, 它不会用于视图直接返回的任何响应.</p>
<p>例如, 当序列化程序验证失败时, 通用视图返回的HTTP_400_BAD_REQUEST响应, 不会引起异常处理函数的调用.</p>
<hr>
<h2 id="api-参考"><a href="#api-参考" class="headerlink" title="api 参考"></a>api 参考</h2><h3 id="APIException-异常类"><a href="#APIException-异常类" class="headerlink" title="APIException 异常类"></a>APIException 异常类</h3><p>签名<code>APIException()</code></p>
<p>所有在APIView类或者使用了<code>@api_view</code>装饰器函数中抛出的异常的基类.</p>
<p>要提供一个自定义异常, 将<code>APIException</code>子类化并设置 <code>status_code</code>, <code>default_detail</code> 和 <code>default_code</code> 属性</p>
<p>例如, 如果你的API依赖于某个不稳定的第三方服务, 可能需要为<code>503 Service Unavailable</code>响应码实现一个异常类, 如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> APIException</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceUnavailable</span><span class="params">(APIException)</span>:</span></span><br><span class="line">    status_code = <span class="number">503</span></span><br><span class="line">    default_detail = <span class="string">'Service temporarily unavailable, try again later.'</span></span><br><span class="line">    default_code = <span class="string">'service_unavailable'</span></span><br></pre></td></tr></table></figure>

<p>可重写的方法/属性</p>
<ol>
<li><code>.detail</code> 该错误的文字描述</li>
<li><code>.get_codes()</code> 返回该异常的错误代码标识符</li>
<li><code>.get_full_details()</code> 返回文字描述和代码标识符</li>
</ol>
<p>在大多数情况下, 错误的detail项会是一个简单元素.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.detail)</span><br><span class="line">You do <span class="keyword">not</span> have permission to perform this action.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_codes())</span><br><span class="line">permission_denied</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_full_details())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">'message'</span>:<span class="string">'You do not have permission to perform this action.'</span>, </span><br><span class="line">	<span class="string">'code'</span>:<span class="string">'permission_denied'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在验证器错误时, detail会是由字段名和错误提示组成的字典或列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.detail)</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"This field is required."</span>, <span class="string">"age"</span>:<span class="string">"A valid integer is required."</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_codes())</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"required"</span>, <span class="string">"age"</span>:<span class="string">"invalid"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_full_details())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"name"</span>:&#123;<span class="string">"message"</span>:<span class="string">"This field is required."</span>, <span class="string">"code"</span>:<span class="string">"required"</span>&#125;, </span><br><span class="line">	<span class="string">"age"</span>:&#123;</span><br><span class="line">		<span class="string">"message"</span>:<span class="string">"A valid integer is required."</span>, </span><br><span class="line">		<span class="string">"code"</span>:<span class="string">"invalid"</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ParseError-解析器错误"><a href="#ParseError-解析器错误" class="headerlink" title="ParseError(解析器错误)"></a>ParseError(解析器错误)</h3><p>签名:<code>ParseError(detail=None, code=None)</code></p>
<p>当访问<code>request.data</code>属性出错时抛出该异常, 默认的处理结果为一个 <code>400 Bad Request</code>响应</p>
<hr>
<h3 id="AuthenticationFailed-身份认证失败"><a href="#AuthenticationFailed-身份认证失败" class="headerlink" title="AuthenticationFailed(身份认证失败)"></a>AuthenticationFailed(身份认证失败)</h3><p>签名：<code>AuthenticationFailed(detail=None, code=None</code></p>
<p>接收到认证身份失败的请求时抛出的错误, 默认为<code>401 Unauthenticated</code>或者<code>403 Forbidden</code>响应, 具体请参看身份验证一节.</p>
<hr>
<h3 id="NotAuthenticated-未认证"><a href="#NotAuthenticated-未认证" class="headerlink" title="NotAuthenticated(未认证)"></a>NotAuthenticated(未认证)</h3><p>签名: <code>NotAuthenticated(detail=None, code=None)</code></p>
<p>接收到认证身份失败的请求时抛出的错误, 默认为<code>401 Unauthenticated</code>或者<code>403 Forbidden</code>响应, 具体请参看身份验证一节.</p>
<hr>
<h3 id="PermissionDenied-权限禁止"><a href="#PermissionDenied-权限禁止" class="headerlink" title="PermissionDenied(权限禁止)"></a>PermissionDenied(权限禁止)</h3><p>签名:<code>PermissionDenied(detail=None, code=None)</code></p>
<p>默认返回结果为<code>403 Forbidden</code></p>
<hr>
<h3 id="NotFound-未找到"><a href="#NotFound-未找到" class="headerlink" title="NotFound(未找到)"></a>NotFound(未找到)</h3><p>签名:<code>NotFound(detail=None, code=None)</code></p>
<p>默认响应状态码为<code>404 Not Found</code>.</p>
<hr>
<h3 id="MethodNotAllowed-不被允许的方法"><a href="#MethodNotAllowed-不被允许的方法" class="headerlink" title="MethodNotAllowed(不被允许的方法)"></a>MethodNotAllowed(不被允许的方法)</h3><p>签名:<code>MethodNotAllowed(method, detail=None, code=None)</code></p>
<p>默认响应状态码为<code>405 Method Not Allowed</code></p>
<hr>
<h3 id="NotAcceptable-客户端无法接收响应"><a href="#NotAcceptable-客户端无法接收响应" class="headerlink" title="NotAcceptable(客户端无法接收响应)"></a>NotAcceptable(客户端无法接收响应)</h3><p>签名:<code>UnsupportedMediaType(media_type, detail=None, code=None)</code></p>
<p>当渲染器列表中的任何渲染器都无法满足客户端请求的Accept头时抛出. </p>
<p>默认响应状态码为<code>406 Not Acceptable</code></p>
<hr>
<h3 id="UnsupportedMediaType-不支持的媒体类型"><a href="#UnsupportedMediaType-不支持的媒体类型" class="headerlink" title="UnsupportedMediaType(不支持的媒体类型)"></a>UnsupportedMediaType(不支持的媒体类型)</h3><p>签名:<code>UnsupportedMediaType(media_type, detail=None, code=None)</code></p>
<p>当访问<code>request.data</code>时, 没有任何可用的解析器可以处理请求中所携带的数据, 则抛出该异常.</p>
<p>默认响应状态码为<code>415 Unsupported Media Type</code></p>
<hr>
<h3 id="Throttled-被限流"><a href="#Throttled-被限流" class="headerlink" title="Throttled(被限流)"></a>Throttled(被限流)</h3><p>签名:<code>Throttled(wait=None, detail=None, code=None)</code></p>
<p>该请求未通过限流检测时抛出该异常</p>
<p>默认响应状态码为<code>429 Too Many Requests</code></p>
<hr>
<h3 id="ValidationError-验证错误"><a href="#ValidationError-验证错误" class="headerlink" title="ValidationError(验证错误)"></a>ValidationError(验证错误)</h3><p>签名:<code>ValidationError(detail, code=None)</code></p>
<p>与<code>APIException</code>的不同之处</p>
<ol>
<li><code>detail</code>参数不是可选的, 而是强制的</li>
<li><code>detail</code>参数可能是一个列表或者错误信息的字典, 或者是一个嵌套的数据结构</li>
<li>按照惯例, 你应当使用完全限定的<code>ValidationError</code>以区别Djano内置的验证错误</li>
</ol>
<p>例如<code>raise serializers.ValidationError(&#39;This field must be an integer value.&#39;)</code></p>
<p><code>ValidationError</code>应当用被验证器使用在序列化器和字段验证上. 或者当调用<code>raise_execption</code>参数为<code>True</code>的<code>serializer.is_valid()</code>方法时抛出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>通用视图使用了<code>raise_execption</code>=<code>True</code>, 所以你可以在全局重写API的验证错误响应的风格, 使用上面所述的自定义异常处理器和描述. </p>
<p>该异常的默认处理结果是 “400 Bad Request”</p>
<hr>
<h2 id="通用错误视图"><a href="#通用错误视图" class="headerlink" title="通用错误视图"></a>通用错误视图</h2><p>鉴于Django的默认错误视图提供HTML响应, 这可能不适用于纯API应用, 因此DRF提供了两个错误视图, 提供通用的JSON形式的5xx和4xx响应.</p>
<p><code>rest_framework.exceptions.server_error</code></p>
<p>返回状态码为<code>500</code>和内容类型为<code>application/json</code>的响应</p>
<p>设置为<code>handler500</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler500 = <span class="string">'rest_framework.exceptions.server_error'</span></span><br></pre></td></tr></table></figure>

<p><code>rest_framework.exceptions.bad_request</code></p>
<p>返回状态码为<code>400</code>和内容类型为<code>application/json</code>的响应.</p>
<p>设置为<code>handler400</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler400 = <span class="string">'rest_framework.exceptions.bad_request'</span></span><br></pre></td></tr></table></figure>

<p>查看Django的<a href="https://docs.djangoproject.com/en/stable/topics/http/views/#customizing-error-views" target="_blank" rel="noopener">自定义错误视图</a>部分.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>22. 返回URL Return URL</title>
    <url>/2019/10/03/22.%20%E8%BF%94%E5%9B%9EURL/</url>
    <content><![CDATA[<blockquote>
<p>REST架构跟与其他架构的核心区别就是强调接口之间的统一性    — Roy Fielding</p>
</blockquote>
<p>通常, 返回url的时候最好是返回绝对url, 而不是返回相对url.</p>
<p>这样做的优势在于：</p>
<ol>
<li>更明确</li>
<li>减轻客户端的负担</li>
<li>当在诸如JSON之类的结果中找不到原始URL时, 也不会产生歧义</li>
<li>很容易地使用带有超链接的html样式</li>
</ol>
<a id="more"></a>

<p>rest_framework提供两个工具函数来更简单地使API返回绝对url, 如果有需要, 使用它们能使自描述API能够自动生成超链接, 使浏览api变得更加容易.</p>
<p>这两个函数是 <code>reverse</code>和 <code>reverse_lazy</code></p>
<hr>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><code>reverse</code></h3><p>签名: <code>reverse(viewname, *args, **kwargs)</code></p>
<p>与django.urls.reverse的行为相同, 唯一的不同是返回的是<strong>绝对URL</strong>.</p>
<p>在这个过程中需要使用<code>request</code>来确定主机和端口, 因此在使用reverse()函数的时候, 需要为其传入request关键字参数.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.reverse <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> django.utils.timezone <span class="keyword">import</span> now</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIRootView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        year = now().year</span><br><span class="line">        data = &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">'year-summary-url'</span>: reverse(<span class="string">'year-summary'</span>, args=[year], request=request)</span><br><span class="line">            <span class="comment">#此处需要传入request</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="reverse-lazy"><a href="#reverse-lazy" class="headerlink" title="reverse_lazy"></a><code>reverse_lazy</code></h3><p>签名: <code>reverse_lazy(viewname, *args, **kwargs)</code></p>
<p>与<code>django.urls.reverse_lazy</code>相同, 唯一区别是返回<strong>绝对URL</strong>, 使用<code>request</code>来确定主机和端口.</p>
<p>与reverse一样, 在使用时为其包含request关键字参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">api_root = reverse_lazy(<span class="string">'api-root'</span>, request=request)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 格式后缀 Format suffixes</title>
    <url>/2019/10/03/21.%20%E6%A0%BC%E5%BC%8F%E5%90%8E%E7%BC%80/</url>
    <content><![CDATA[<p>Web API的常见方式是在URL上使用文件拓展名用以指定所期望获得响应的媒体类型, 例如<code>http://example.com/api/users.json</code>用于请求<code>JSON</code>格式的数据.</p>
<p>如果要在API的URLconf中为每个单独的条目添加格式后缀容易出错且违背DRY原则, 因此REST框架提供了将这些模式添加到URLConf的快捷方式.</p>
<a id="more"></a>

<hr>
<h2 id="format-suffix-patterns"><a href="#format-suffix-patterns" class="headerlink" title="format_suffix_patterns"></a><code>format_suffix_patterns</code></h2><p>签名: <code>format_suffix_patterns(urlpatterns, suffix_required=False, allowed=None)</code></p>
<p>该函数接收一个urlpatterns参数, 并为其中每个urlpattern都提供了后缀的新的urlpatterns作为返回结果</p>
<p><code>urlpatterns</code>: 必要参数, 一个URL pattern 列表<br><code>suffix_required</code>: 可选参数, 布尔型, 用来指定请求url是否<strong>必须</strong>包含后缀. 默认为<code>False</code><br><code>allowed</code>：可选参数, 合法的后缀列表或元组, 如果不提供, 则会使用通配符格式后缀</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.urlpatterns <span class="keyword">import</span> format_suffix_patterns</span><br><span class="line"><span class="keyword">from</span> blog <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^/$'</span>, views.apt_root), </span><br><span class="line">    url(<span class="string">r'^comments/$'</span>, views.comment_list), </span><br><span class="line">    url(<span class="string">r'^comments/(?P&lt;pk&gt;[0-9]+)/$'</span>, views.comment_detail)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = format_suffix_patterns(urlpatterns, allowed=[<span class="string">'json'</span>, <span class="string">'html'</span>])</span><br></pre></td></tr></table></figure>

<p>当使用<code>format_suffix_patterns</code>的时候, 必须确保在对应的视图中的请求处理函数中接收<code>format</code>关键字参数(通用视图中的处理方法默认已包含<code>format</code>参数).</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(('GET', 'POST'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment_list</span><span class="params">(request, format=None)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>这个参数名(<code>&#39;farmat&#39;</code>)可以使用<code>FORMAT_SUFFIX_KWARG</code>设置项来改变</p>
<p>同时需要注意, <code>format_suffix_patterns</code> 不支持在其patterns中使用<code>include</code>来包含下级<code>urlpattern</code>, 所以该函数的使用位置为底层的urlconf</p>
<hr>
<h3 id="同时使用-i18n-patterns"><a href="#同时使用-i18n-patterns" class="headerlink" title="同时使用 i18n_patterns"></a>同时使用 <code>i18n_patterns</code></h3><p>如果使用django提供的<code>i18n_patterns</code>函数, 确保其在最外层调用, 即返回的urlpattern需要为最终的urlpattern</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    …</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = i18n_patterns(</span><br><span class="line">    format_suffix_patterns(urlpatterns, allowed=[<span class="string">'json'</span>, <span class="string">'html'</span>])</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通过查询参数来指定格式"><a href="#通过查询参数来指定格式" class="headerlink" title="通过查询参数来指定格式"></a>通过查询参数来指定格式</h2><p>另一个指定格式的方法是使用查询参数来指定格式, rest_framework默认提供这个特性.</p>
<p>使用的查询参数名默认为<code>format</code>, 例如: <code>http://example.com/organizations/?format=csv</code>.</p>
<p>查询参数的名字(<code>format</code>), 可以通过 <code>URL_FORMAT_OVERRIDE</code> 进行设置, 设置为<code>None</code>则禁止使用查询参数的方式来指定格式.</p>
<hr>
<h2 id="Accept头和格式后缀的比较"><a href="#Accept头和格式后缀的比较" class="headerlink" title="Accept头和格式后缀的比较"></a>Accept头和格式后缀的比较</h2><p>在某些Web社区中似乎有一种观点认为文件扩展名不是RESTful模式, 而且应始终使用HTTP Accept标头. </p>
<p>这实际上是一种误解. 例如, 请参阅Roy Fielding的以下引用, 讨论查询参数媒体类型指标与文件扩展媒体类型指标的相对优点：</p>
<blockquote>
<p>“这就是为什麽我总是喜欢扩展名, 这两种选择都与REST无关. “ -  Roy Fielding, REST讨论邮件列表</p>
</blockquote>
<p>引用中没有提到<code>Accept</code>标头, 但它确实清楚地表明格式后缀应该被认为是可接受的模式. </p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>20. API概览 Schemas</title>
    <url>/2019/10/03/20.%20API%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>能被机器所理解的概要, 描述了通过api可得到的资源, URL, 表示方式以及支持的操作.</p>
<p>API概要在很多使用场景下都是有用的工具, 例如生成参考文档, 或者驱动可以与API交互的动态客户端库.</p>
<p>rest-framework支持自动生成<a href="https://github.com/OAI/OpenAPI-Specification" target="_blank" rel="noopener">OPENAPI</a>文档.</p>
<a id="more"></a>

<hr>
<h2 id="生成API概览"><a href="#生成API概览" class="headerlink" title="生成API概览"></a>生成API概览</h2><h4 id="安装CoreAPI和PyYAML"><a href="#安装CoreAPI和PyYAML" class="headerlink" title="安装CoreAPI和PyYAML"></a>安装CoreAPI和PyYAML</h4><p>安装<code>coreapi</code>包来为REST框架提供概要支持, 同时还可能需要<code>pyyaml</code>包以将概要渲染为通用的YAML格式的开放API格式.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install coreapi pyyaml</span><br></pre></td></tr></table></figure>

<p>两种方法来生成API描述文档:</p>
<ol>
<li>使用<code>generateschema</code>管理命令生成静态的概要文件</li>
<li>使用SchemaView视图来生成动态的概要响应.</li>
</ol>
<hr>
<h3 id="使用generateschema管理命令生成静态的概要文件"><a href="#使用generateschema管理命令生成静态的概要文件" class="headerlink" title="使用generateschema管理命令生成静态的概要文件"></a>使用<code>generateschema</code>管理命令生成静态的概要文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py generateschema &gt; shcema.yml</span><br></pre></td></tr></table></figure>

<p>之后会生成一个包含api概要的YAML语法的文件<code>schema.yml</code>, 之后你可以在其中添加额外信息以补充概要生成器所未能包含的其他信息.</p>
<p>这种方法需要手动登记版本控制信息, 并在每个新版本发布时更新该文档, 或者将其作为静态媒体文件由服务器返回.</p>
<hr>
<h3 id="添加动态生成概要的视图函数"><a href="#添加动态生成概要的视图函数" class="headerlink" title="添加动态生成概要的视图函数"></a>添加动态生成概要的视图函数</h3><p>在某些情况下需要的是一个动态的api概要, 因为外键的可选项可能随着数据库中的值而变动. 使用<code>SchemaView</code>并将其注册至路由中, 这样就可以按需生成概要.</p>
<p>将SchemaView添加至路由, 需要使用<code>get_schema_view()</code>辅助函数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#project/urls.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.schemas <span class="keyword">import</span> get_schema_view</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">'openapi'</span>, get_schema_view(</span><br><span class="line">        title=<span class="string">"Your Project"</span>, </span><br><span class="line">        description=<span class="string">"API for all things …"</span>, </span><br><span class="line">        version=<span class="string">"1.0.0"</span></span><br><span class="line">    ), name=<span class="string">'openapi-schema'</span>), </span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ol>
<li><code>title</code> 用以提供的概要标题</li>
<li><code>description</code> 较长的描述性文本</li>
<li><code>version</code> 标注的api版本, 默认为<code>0.1.0</code></li>
<li><code>url</code> 可用于标注baseURL</li>
<li><code>urlconf</code> 该概要所想要包含的urlconf的所在路径, 默认为django的<code>ROOT_URLCONF</code>设置项</li>
<li><code>gengerator_class</code> 可能用以指定一个要被<code>SchemaView</code>所使用的<code>SchemaGenerator</code>的子类</li>
<li><code>authentication_classes</code> 指定用以进行身份认证的类列表, 默认为django的<code>DEFAULT_AUTHENTICATION_CLASSES</code>设置项</li>
<li><code>permission_classes</code> 指定用以进行权限验证的类列表, 默认为django的<code>DEFAULT_PERMISSION_CLASSES</code>设置项</li>
<li><code>renderer_classes</code> 用以指定生成最终结果的渲染器类</li>
</ol>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">schema_view = get_schema_view(</span><br><span class="line">    title=<span class="string">'Server Monitoring API'</span>, </span><br><span class="line">    url=<span class="string">'https://www.example.org/api/'</span>, </span><br><span class="line">    urlconf=<span class="string">'myproject.urls'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义概要生成"><a href="#自定义概要生成" class="headerlink" title="自定义概要生成"></a>自定义概要生成</h2><p>自定义全部API概要, 或指定视图级的自定义概要.</p>
<h3 id="概要级别的自定义"><a href="#概要级别的自定义" class="headerlink" title="概要级别的自定义"></a>概要级别的自定义</h3><p>如果要自定义最高级的概要, 需要子类化<code>rest_framework.schemas.openapi.SchemaGenerator</code>, 并将其作为参数提供给<code>generateschema</code>命令或者<code>get_schema_view</code>辅助函数.</p>
<p><strong>SchemaGenerator</strong>是一个用来遍历一个urlpattern列表, 并为其中每一个视图生成相关概要的类.</p>
<p>通常需要提供一个<code>title</code>参数将其实例化:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generator = SchemaGenerator(title=<span class="string">'Stock Prices API'</span>)</span><br></pre></td></tr></table></figure>

<p>可用的参数包括</p>
<ol>
<li>title </li>
<li>description</li>
<li>version</li>
<li>url</li>
<li>patterns</li>
<li>urlconf</li>
</ol>
<p>各参数的含义与在<code>get_schema_view()</code>函数中相同, 不再赘述. 其中只有<code>title</code>是必要参数.</p>
<p>需要重写的方法为<code>get_schema(self, request)</code> </p>
<p>该方法返回一个字典, 所包含的数据用于表示API概要.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generator = SchemaGenerator(title=<span class="string">'Stock Prices API'</span>)</span><br><span class="line">schema = generator.get_schema()</span><br></pre></td></tr></table></figure>

<p>request参数是可选的, 如果要对生成的模式生成应用每个用户权限, 则可以使用request参数. </p>
<p>如果要自定义生成的字典(例如添加自定义规范扩展名), 则可以覆盖该方法. </p>
<hr>
<h3 id="视图级别的自定义"><a href="#视图级别的自定义" class="headerlink" title="视图级别的自定义"></a>视图级别的自定义</h3><p>默认情况下, 视图自省可通过APIView上的schema属性访问的AutoSchema实例执行. 这为视图, 请求方法和路径提供了适当的Open API操作对象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">auto_schema = view.schema</span><br><span class="line">operation = auto_schema.get_operation(...)</span><br></pre></td></tr></table></figure>

<p>在编译概要时, SchemaGenerator为每个视图, 允许的方法和路径调用<code>view.schema.get_operation()</code>.</p>
<p>注意：对于基本的APIView子类, 默认自省本质上仅限于URL关键字路径参数, 对于GenericAPIView子类, 其中包括所有提供的基于类的视图, AutoSchema将尝试内省序列化程序, 分页和过滤器字段, 并提供更丰富的路径字段描述(这里的关键钩子是相关的GenericAPIView属性和方法: get_serializer, pagination_class, filter_backends等).</p>
<hr>
<p>为了自定义操作生成, 应该提供一个<code>AutoSchema</code>的子类, 并按需重写<code>get_operation()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.schemas.openapi <span class="keyword">import</span> AutoSchema</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSchema</span><span class="params">(AutoSchema)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_link</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment"># Implement custom introspection here (or in other sub-methods)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""APIView subclass with custom schema introspection."""</span></span><br><span class="line">    schema = CustomSchema()</span><br></pre></td></tr></table></figure>

<p>这为视图的自省提供了完全控制.</p>
<p>如果想要某个视图不被包含在api概要中, 将其schema属性设为None即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    schema = <span class="literal">None</span>  <span class="comment"># 不会在概要中出现该视图.</span></span><br></pre></td></tr></table></figure>

<p>或是不想让某个ViewSet中自定义路由包含在API概要中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=True, schema=None)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extra_action</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>如果要指定某个<code>AutoSchema</code>的子类应用于全局, 通过<code>DEFAULT_SCHEMA_CLASS</code>设置项进行设置.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 元数据 Metadata</title>
    <url>/2019/10/03/19.%20%E5%85%83%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>OPTIONS方法允许客户端在不要求资源动作或启动资源检索的前提下, 确定资源相关的选项, 需求或服务端的能力, </p>
</blockquote>
<p>REST framework包含一个可配置的机制, 用于确定API应如何响应<code>OPTIONS</code>请求, 返回API构架或其他资源信息。</p>
<p>目前还没有任何广泛采用的约定, 以确切地为<code>HTTP OPTIONS</code>请求返回什么样的响应, 因此我们提供了一种返回一些有用信息的ad-hoc样式。</p>
<a id="more"></a>

<p>这是一个示例响应, 演示默认返回的信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">Allow: GET, POST, HEAD, OPTIONS</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"To Do List"</span>, </span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"List existing 'To Do' items, or create a new item."</span>, </span><br><span class="line">    <span class="string">"renders"</span>: [</span><br><span class="line">        <span class="string">"application/json"</span>, </span><br><span class="line">        <span class="string">"text/html"</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">"parses"</span>: [</span><br><span class="line">        <span class="string">"application/json"</span>, </span><br><span class="line">        <span class="string">"application/x-www-form-urlencoded"</span>, </span><br><span class="line">        <span class="string">"multipart/form-data"</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">"actions"</span>: &#123;</span><br><span class="line">        <span class="string">"POST"</span>: &#123;</span><br><span class="line">            <span class="string">"note"</span>: &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"string"</span>, </span><br><span class="line">                <span class="string">"required"</span>: <span class="literal">false</span>, </span><br><span class="line">                <span class="string">"read_only"</span>: <span class="literal">false</span>, </span><br><span class="line">                <span class="string">"label"</span>: <span class="string">"title"</span>, </span><br><span class="line">                <span class="string">"max_length"</span>: <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置元数据方案"><a href="#设置元数据方案" class="headerlink" title="设置元数据方案"></a>设置元数据方案</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>使用<code>DEFAULT_METADATA_CLASS</code>设置项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_METADATA_CLASS'</span>: <span class="string">'rest_framework.metadata.SimpleMetadata'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图级设置, 使用metadata_class即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIRoot</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    metadata_class = SimpleMetadata</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>drf仅仅提供了一个<code>SimpleMetadata</code>类, 如果想用其他风格都必须自定义元数据类。</p>
<p>###创建概要端点</p>
<p>如果想要创建一个可以使用<code>GET</code>请求方法访问的元数据入口, 你可以通过复用元数据API来实现</p>
<p>例如, 如下额外的路由可以提供一个可链接的概要端点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@action(methods=['GET'], detail=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schema</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    meta = self.metadata_class()</span><br><span class="line">    data = meta.determine_metadata(request, self)</span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<p>使用理由:<code>OPTION</code>响应不可缓存, 而<code>GET</code>可以</p>
<hr>
<p>##自定义元数据类</p>
<p>重写<code>BaseMetadata</code>, 并实现<code>determine_metadata(self, request, view)</code>方法</p>
<p>例如想返回JSON格式的概要信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimalMetadata</span><span class="params">(BaseMetadata)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Don't include field and other information for `OPTIONS` requests.</span></span><br><span class="line"><span class="string">    Just return the name and description.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_metadata</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'name'</span>: view.get_view_name(), </span><br><span class="line">            <span class="string">'description'</span>: view.get_view_description()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_METADATA_CLASS'</span>: <span class="string">'myproject.apps.core.MinimalMetadata'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 内容协商 Content negotiation</title>
    <url>/2019/10/03/18.%20%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86/</url>
    <content><![CDATA[<p>内容协商的结果会在选择解析器和渲染器阶段使用.</p>
<p>REST使用简单的内容协商方式来确定应该返回给客户端什么媒体类型的响应, 并根据可用的渲染器, 各个渲染器的优先级以及客户端的<code>Accpet</code>标头来选择渲染器, 部分由客户端驱动, 部分由服务端驱动. </p>
<p>在进行内容协商时:</p>
<a id="more"></a>

<ol>
<li>更具体的媒体类型优先</li>
<li>可用渲染器列表的顺序优先</li>
</ol>
<p>例如接收到的<code>Accept</code>头如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">application/json; indent=4, application/json, application/yaml, text/html, */*</span><br></pre></td></tr></table></figure>

<p>其优先顺序为</p>
<ol>
<li>application/json; indent=4</li>
<li>application/json, application/yaml and text/html</li>
<li><em>/</em></li>
</ol>
<p>如果视图里定义的渲染器仅有YAML和HTML格式, REST会选择列表中第一个渲染器进行渲染</p>
<p>注意：q值指定优先级的方式, 不会被rest_framework所采用. </p>
<hr>
<h3 id="自定义内容协商"><a href="#自定义内容协商" class="headerlink" title="自定义内容协商"></a>自定义内容协商</h3><p>通常不太可能需要自定义内容协商方案, 不过如果有需要, 可以通过重写<code>BaseContentNegotiation</code>来实现</p>
<p>内容协商同时处理解析器和渲染器的选择, 所以需要同时实现<code>.select_parser(request, parsers)</code>和<code>.select_renderer(request, renderers, format_suffix)</code>方法</p>
<ol>
<li><code>select_parser()</code>方法返回一个在可用解析器列表中的解析器, 如果找不到合适的解析器则返回None. </li>
<li><code>select_renderer()</code>方法返回一个二元组<code>(renderer instance, media type)</code>, 或者抛出一个<code>NotAcceptable</code>异常.</li>
</ol>
<p>示例: 以下自定义内容协商类, 会在内容协商阶段忽略客户端的请求, 而直接选择最靠前的解析器和渲染器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.negotiation <span class="keyword">import</span> BaseContentNegotiation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IgnoreClientContentNegotiation</span><span class="params">(BaseContentNegotiation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_parser</span><span class="params">(self, request, parsers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Select the first parser in the `.parser_classes` list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> parsers[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_renderer</span><span class="params">(self, request, renderers, format_suffix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Select the first renderer in the `.renderer_classes` list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (renderers[<span class="number">0</span>], renderers[<span class="number">0</span>].media_type)</span><br></pre></td></tr></table></figure>

<p>将其设置为全局默认的内容协商类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_CONTENT_NEGOTIATION_CLASS'</span>: <span class="string">'myapp.negotiation.IgnoreClientContentNegotiation'</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者指定为某视图使用的内容协商类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myapp.negotiation <span class="keyword">import</span> IgnoreClientContentNegotiation</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoNegotiationView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    An example view that does not perform content negotiation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    content_negotiation_class = IgnoreClientContentNegotiation</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'accepted media type'</span>: request.accepted_renderer.media_type</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>17. 版本控制 Versioning</title>
    <url>/2019/10/03/17.%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>API版本控制允许为不同客户端执行不同的行为. REST-framework提供了多种版本控制方案:</p>
<ol>
<li>基于url查询参数的版本控制<code>QueryParameterVersioning</code></li>
<li>基于url中路径段匹配的版本控制<code>URLPathVersioning</code></li>
<li>基于ACCEPT请求头的版本控制<code>AcceptHeaderVersioning</code></li>
<li>基于命名空间的版本控制<code>NamespaceVersioning</code></li>
<li>基于主机名的版本控制<code>HostNameVersioning</code></li>
<li>自定义的版本控制</li>
</ol>
<a id="more"></a>

<p><em>导出路径均为<code>rest_framework.versioning</code></em></p>
<p>任何方案最终都会将请求的版本号保存在<code>request.version</code>中, 当未启用任何版本控制方案时, <code>request.version</code>总是返回<code>None</code>. 可以通过检查<code>request.version</code>为客户端提供不同的数据.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.version == <span class="string">'v1'</span>:</span><br><span class="line">        <span class="keyword">return</span> AccountSerializerVersion1</span><br><span class="line">    <span class="keyword">return</span> AccountSerializer</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="配置版本控制方案"><a href="#配置版本控制方案" class="headerlink" title="配置版本控制方案"></a>配置版本控制方案</h3><p>全局级别:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_VERSIONING_CLASS'</span>: <span class="string">'rest_framework.versioning.NamespaceVersioning'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他可选配置项</p>
<ul>
<li>DEFAULT_VERSION: 默认版本，默认值为None</li>
<li>ALLOWED_VERSIONS：允许的版本，默认为None，不做限制</li>
<li>VERSION_PARAM：用来控制版本控制系统的字符串，默认为’version’</li>
</ul>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="QueryParameterVersioning-基于url查询参数的版本控制"><a href="#QueryParameterVersioning-基于url查询参数的版本控制" class="headerlink" title="QueryParameterVersioning(基于url查询参数的版本控制)"></a>QueryParameterVersioning(基于url查询参数的版本控制)</h3><p>启用基于查询参数的版本控制方案时, 直接在请求中包含<code>version</code>查询参数即可, 请求格式:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/something/?version=0.1</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="URLPathVersioning-基于url中路径段匹配的版本控制"><a href="#URLPathVersioning-基于url中路径段匹配的版本控制" class="headerlink" title="URLPathVersioning(基于url中路径段匹配的版本控制)"></a>URLPathVersioning(基于url中路径段匹配的版本控制)</h3><p>启用基于url路径的版本控制方案后, 需要配置url conf中添加变量(或命名正则表达式).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">'something/(&lt;?P=version&gt;(V1|V2))/bookings/$'</span>, bookings_list), </span><br><span class="line">    re_path(<span class="string">'something/(&lt;?P=version&gt;(V1|V2))/bookings/(?P&lt;pk&gt;[0-9]+)/$'</span>, bookings_detail)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>请求格式</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/v1/bookings/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="HostNameVersioning-基于主机名的版本控制"><a href="#HostNameVersioning-基于主机名的版本控制" class="headerlink" title="HostNameVersioning(基于主机名的版本控制)"></a>HostNameVersioning(基于主机名的版本控制)</h3><p>尝试从hostname中取出version, hostname应当与<code>^([a-zA-Z0-9]+)\.[a-zA-Z0-9]+\.[a-zA-Z0-9]+$</code>相匹配.</p>
<p>请求格式</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bookings/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: v1.example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AcceptHeaderVersioning-基于ACCEPT请求头的版本控制"><a href="#AcceptHeaderVersioning-基于ACCEPT请求头的版本控制" class="headerlink" title="AcceptHeaderVersioning(基于ACCEPT请求头的版本控制)"></a>AcceptHeaderVersioning(基于ACCEPT请求头的版本控制)</h3><p>通过<code>ACCEPT</code>头的version参数获取版本</p>
<p>请求格式:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bookings/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json; version=1.0</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="NamespaceVersioning-基于命名空间的版本控制"><a href="#NamespaceVersioning-基于命名空间的版本控制" class="headerlink" title="NamespaceVersioning(基于命名空间的版本控制)"></a>NamespaceVersioning(基于命名空间的版本控制)</h3><p>匹配至包含不同版本路径的urlconf, 然后分配至对应的namespace</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bookings/urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^$'</span>, bookings_list, name=<span class="string">'bookings-list'</span>), </span><br><span class="line">    url(<span class="string">r'^(?P&lt;pk&gt;[0-9]+)/$'</span>, bookings_detail, name=<span class="string">'bookings-detail'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^v1/bookings/'</span>, include(<span class="string">'bookings.urls'</span>, namespace=<span class="string">'v1'</span>)), </span><br><span class="line">    url(<span class="string">r'^v2/bookings/'</span>, include(<span class="string">'bookings.urls'</span>, namespace=<span class="string">'v2'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>与URLPathVersioning相比, NamespaceVersioning适用用较大的项目, 因为所有的管理内容在urls.py中进行配置, 而非在各个view中通过request.version进行配置, 更易于管理.</p>
<hr>
<h3 id="自定义版本控制"><a href="#自定义版本控制" class="headerlink" title="自定义版本控制"></a>自定义版本控制</h3><p>子类化<code>BaseVersioning</code>并重写<code>.determine_version()</code>方法, 返回值为期望获取的版本号.</p>
<p>示例:使用自定义的X-API-Version头来确定请求的版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XAPIVersionScheme</span><span class="params">(versioning.BaseVersioning)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> request.META.get(<span class="string">'HTTP_X_API_VERSION'</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>如果自定义控制方案是基于URL获取version的, 还需要重写<code>reverse()</code>方法.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 分页 Pagination</title>
    <url>/2019/10/03/16.%20%E5%88%86%E9%A1%B5%E5%99%A8%20Paginator/</url>
    <content><![CDATA[<p>分页器可以将较多的数据分为若干页，并在每一页上给出上一页/下一页的链接. DRF支持自定义分页风格，并允许改变每页包含的数据的数量. </p>
<p>分页API应当支持:</p>
<ol>
<li>分页对象的链接，作为响应内容的一部分</li>
<li>分页对象的链接，作为响应头的一部分 (Content-Range或者Link)</li>
</ol>
<a id="more"></a>

<p>当前DRF内置分页器的分页风格都是将链接包含至内容中. </p>
<p>分页器仅会在使用通用视图或视图集时自动应用, 如果使用<code>APIView</code>, 需要自行调用分页接口来保证返回分页响应. 可以查看<code>mixins.ListModelMixin</code>和<code>generics.GenericAPIView</code>来查看示例代码.</p>
<p>将视图的<code>pagination_class</code>设为<code>None</code>可以关闭分页器.</p>
<hr>
<h3 id="设置使用分页器"><a href="#设置使用分页器" class="headerlink" title="设置使用分页器"></a>设置使用分页器</h3><p>全局设置</p>
<p>使用<code>DEFAULT_PAGINATION_CLASS</code>和<code>PAGE_SIZE</code>关键字来设置全局的分页风格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.LimitOffsetPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这两项都必须进行设置.</p>
<p>在view/viewset中则使用<code>pagination_class</code>属性指定分页类.</p>
<hr>
<h3 id="分页器在何处被应用"><a href="#分页器在何处被应用" class="headerlink" title="分页器在何处被应用?"></a>分页器在何处被应用?</h3><p><code>list</code>行为中需要对数量较大的查询集进行分页.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mixins.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="改变分页风格"><a href="#改变分页风格" class="headerlink" title="改变分页风格"></a>改变分页风格</h3><p>继承<code>PageNumberPagination</code>并重写相关属性来自定义分页器类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeResultsSetPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">1000</span></span><br><span class="line">    page_size_query_param = <span class="string">'page_size'</span></span><br><span class="line">    max_page_size = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardResultsSetPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">100</span></span><br><span class="line">    page_size_query_param = <span class="string">'page_size'</span></span><br><span class="line">    max_page_size = <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>如果指定<code>page_size_query_param</code>,则允许客户端来指定每页的大小.</p>
<p>然后在视图中使用自定义分页类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillingRecordsView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Billing.objects.all()</span><br><span class="line">    serializer_class = BillingRecordsSerializer</span><br><span class="line">    pagination_class = StandardResultsSetPagination</span><br></pre></td></tr></table></figure>

<p>或者设置为全局默认分页类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'apps.core.pagination.StandardResultsSetPagination'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="PageNumberPagination"><a href="#PageNumberPagination" class="headerlink" title="PageNumberPagination"></a>PageNumberPagination</h3><p>路径:<code>rest_framework.pagination.PageNumberPagination</code></p>
<p>只接受<code>page</code>作为查询参数</p>
<p>请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET https://api.example.org/accounts/?page=4</span><br></pre></td></tr></table></figure>

<p>响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"count"</span>: <span class="number">1023</span></span><br><span class="line">    <span class="string">"next"</span>: <span class="string">"https://api.example.org/accounts/?page=5"</span>,</span><br><span class="line">    <span class="string">"previous"</span>: <span class="string">"https://api.example.org/accounts/?page=3"</span>,</span><br><span class="line">    <span class="string">"results"</span>: [</span><br><span class="line">       …</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可重写属性如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>django_paginator_class</code></td>
<td>使用的Django中的分页器 默认为<code>django.core.paginator.Paginator</code></td>
</tr>
<tr>
<td><code>page_size</code></td>
<td>数字型，该属性会覆盖<code>PAGE_SIZE</code>，默认为与<code>PAGE_SIZE</code>等值</td>
</tr>
<tr>
<td><code>page_query_param</code></td>
<td>查询参数的关键字，默认为<code>&#39;page&#39;</code></td>
</tr>
<tr>
<td><code>page_size_query_param</code></td>
<td>查询参数中控制每页大小的关键字, 默认为<code>None</code>，即不受客户端控制，仅由服务器端控制.</td>
</tr>
<tr>
<td><code>max_page_size</code></td>
<td>如果设置该项，意味着可请求的最大分页数，该项只有在<code>page_query_param</code>已存在时合法</td>
</tr>
<tr>
<td><code>last_page_strings</code></td>
<td>字符串列表，当查询的<code>page_query_param</code>为其中的值时，返回最后一页，默认为<code>(&#39;last&#39;,)</code></td>
</tr>
<tr>
<td><code>template</code></td>
<td>返回时用来渲染的模板，默认为<code>rest_framework/pagination/numbers.html</code>，可设为<code>None</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="LimitOffsetPagination"><a href="#LimitOffsetPagination" class="headerlink" title="LimitOffsetPagination"></a>LimitOffsetPagination</h3><p>路径: <code>rest_framework.pagination.LimitOffsetPagination</code></p>
<p>支持<code>limit</code>和<code>offset</code>查询参数，较之<code>page</code>更为灵活，因为可以从任意处开始截取指定数量的数据. </p>
<p>请求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET https://api.example.org/accounts/?limit=100&amp;offset=400</span><br></pre></td></tr></table></figure>

<p>响应:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"count"</span>: <span class="number">1023</span></span><br><span class="line">    <span class="string">"next"</span>: <span class="string">"https://api.example.org/accounts/?limit=100&amp;offset=500"</span>,</span><br><span class="line">    <span class="string">"previous"</span>: <span class="string">"https://api.example.org/accounts/?limit=100&amp;offset=300"</span>,</span><br><span class="line">    <span class="string">"results"</span>: [</span><br><span class="line">       …</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果设置了<code>PAGE_SIZE</code>,那么<code>URL</code>中的<code>limit</code>查询参数就是可选的，如果URL中不包含<code>limit</code>，直接从<code>offset</code>处截取出<code>PAGE_SIZE</code>条数据. </p>
<p><code>LimitOffsetPagination</code>可重写的属性如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>default_limit</code></td>
<td>INT</td>
<td>与<code>PAGE_SIZE</code>的意义相同，如果设置，limit参数将为可选</td>
</tr>
<tr>
<td><code>limit_query_param</code></td>
<td>string</td>
<td>用来代表<code>limit</code>含义的关键字，默认就是<code>&#39;limit&#39;</code></td>
</tr>
<tr>
<td><code>offset_query_param</code></td>
<td>string</td>
<td>用来代表<code>offset</code>含义的关键字，默认就是<code>&#39;offset&#39;</code></td>
</tr>
<tr>
<td><code>max_limit</code></td>
<td>INT</td>
<td>用来控制可指定的最大限制条数，默认为<code>None</code></td>
</tr>
<tr>
<td><code>template</code></td>
<td>string</td>
<td>返回时使用的模板，默认为<code>rest_framework/pagination/numbers.html</code>，可以设为<code>None</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="CursorPagination-游标分页器"><a href="#CursorPagination-游标分页器" class="headerlink" title="CursorPagination 游标分页器"></a>CursorPagination 游标分页器</h3><p>不允许直接指定开始位置，页面大小或者请求页数，而只能从开始处逐渐进行偏移</p>
<p>基于光标的分页呈现不透明(无表义)的游标指示符，客户端可以使用该指示符来翻阅结果集. 此分页样式仅显示前向和后退控件，并且不允许客户端导航到任意位置. </p>
<p>基于游标的分页要求结果集中的项具有唯一且不变的排, 排序依据通常可能是记录上的创建时间戳，因为可以提供一致的分页排序. </p>
<p>优势如下:</p>
<ul>
<li>提供一致的分页视图. 正确使用CursorPagination可确保客户端在分页记录时永远不会看到相同的项目，即使在分页过程中其他客户端插入新项目时也是如此. </li>
<li>支持使用非常大的数据集. 对于极大的数据集，使用基于偏移的分页样式的分页可能变得低效或无法使用. 基于游标的分页方案具有固定时间属性，并且不会随著数据集大小的增加而减慢. </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.CursorPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认排序字段名为<code>&#39;created&#39;</code>，如果你的模型中不包含该字段，则必须子类化<code>CursorPagination</code>并重写该属性，然后应用该子类作为排序器</p>
<p>可重写的属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>page_size</code></td>
<td>INT</td>
<td>每页的数据量，同<code>PAGE_SIZE</code></td>
</tr>
<tr>
<td><code>cursor_query_param</code></td>
<td>string</td>
<td>代表cursor含义的查询参数，默认为<code>&#39;cursor&#39;</code></td>
</tr>
<tr>
<td><code>ordering</code></td>
<td>string|listofstring</td>
<td>用来进行后台排序的字段，默认为<code>&#39;-created&#39;</code>,该项会被OrderingFilter的设置所覆盖</td>
</tr>
<tr>
<td><code>template</code></td>
<td>string</td>
<td>返回数据时使用的模板，默认为<code>&quot;rest_framework/pagination/previous_and_next.html&quot;</code>，可以设为<code>None</code></td>
</tr>
</tbody></table>
<p>注意，ordering字段必须指定为该模型中的字段，该字段默认为<code>-created</code>，如果模型没有这个字段就会报错，因此需要为其指定一个存在的，可以用来排序的字段. </p>
<p>使用游标分页器的结果集必须为有序的，所以该字段是必需的.</p>
<p>该参数无法通过配置项实现，必须子类化然后覆盖该属性, 示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#blog/paginations.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> CursorPagination</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycursorpagnitor</span><span class="params">(CursorPagination)</span>:</span></span><br><span class="line">    ordering = <span class="string">'date_created'</span></span><br></pre></td></tr></table></figure>

<p>settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'blog.paginations.MyCursorPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">Allow: GET, POST, HEAD, OPTIONS</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Vary: Accept</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"next"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/blog/?cursor=bz0xJnA9MjAxOS0wNC0xMSsyMCUzQTAwJTNBMDAlMkIwMCUzQTAw"</span>,</span><br><span class="line">    <span class="string">"previous"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/blog/?cursor=cj0xJnA9MjAxOS0wNC0wOSsxOSUzQTQ2JTNBMzglMkIwMCUzQTAw"</span>,</span><br><span class="line">    <span class="string">"results"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"多标签测试用"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/category/4/"</span>,</span><br><span class="line">            <span class="string">"date_created"</span>: <span class="string">"2019-04-09T19:46:38Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"测试用例4 ，储存"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/category/1/"</span>,</span><br><span class="line">            <span class="string">"date_created"</span>: <span class="string">"2019-04-11T20:00:00Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"测试用例2 ，储存"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/category/2/"</span>,</span><br><span class="line">            <span class="string">"date_created"</span>: <span class="string">"2019-04-29T03:50:51.522801Z"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义分页器"><a href="#自定义分页器" class="headerlink" title="自定义分页器"></a>自定义分页器</h3><p>子类化<code>pagination.BasePagination</code>并重写</p>
<ol>
<li><code>paginate_queryset(self, queryset, request, view=None)</code>方法</li>
<li><code>get_paginated_response(self, data)</code>方法</li>
</ol>
<p><code>paginate_queryset</code>方法接收一个初始的查询集并返回一个只包含请求数据的可迭代对象(获取部分查询集并将其序列化,并返回序列化结果data)<br><code>get_paginated_response</code>方法接收已序列化的数据并返回一个<code>Response</code>实例 (简单地将数据嵌入某些格式中,并作为响应体的内容,返回一个Response) </p>
<p>注意<code>paginate_queryset</code>方法在分页器实例中设置状态，并可能随后被<code>get_paginated_response</code>方法所使用. </p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPagination</span><span class="params">(pagination.PageNumberPagination)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_paginated_response</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'links'</span>: &#123;</span><br><span class="line">                <span class="string">'next'</span>: self.get_next_link(),</span><br><span class="line">                <span class="string">'previous'</span>: self.get_previous_link()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'count'</span>: self.page.paginator.count,</span><br><span class="line">            <span class="string">'results'</span>: data</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'my_project.apps.core.pagination.CustomPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果如果想更改默认排序字段，当构造分页响应的body部分时应当使用<code>OrderedDict</code>，这是可选的</p>
<hr>
<h3 id="分页-amp-概要"><a href="#分页-amp-概要" class="headerlink" title="分页 &amp; 概要"></a>分页 &amp; 概要</h3><p>还可以通过实现<code>get_chema_fields()</code>方法来使REST框架自动生成的概要能够使用分页控件. </p>
<p>该函数的签名 <code>get_schema_fields(self, view)</code>, 返回值为一个<code>coreapi.Field</code>实例的列表. </p>
<p><img src="https://www.django-rest-framework.org/img/link-header-pagination.png" alt></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 过滤 Filter</title>
    <url>/2019/10/03/15.%20%E8%BF%87%E6%BB%A4%20Filter/</url>
    <content><![CDATA[<blockquote>
<p>“由Django Manager提供的全查询集描述了数据库表中的所有对象。可是通常你需要的只是选择所有对象中的一个子集而已。” —— Django文档</p>
</blockquote>
<p>REST-framework默认获得的是一个model的全部查询集, 而通常我们只需要其中一部分. </p>
<p>分页器解决的是将查询集分批次返回的问题, 而过滤则是要按某种条件取出部分查询集.</p>
<p>最简单的方法就是重写<code>GenericAPIView</code>的子类(例如viewset)的<code>get_queryset</code>方法, 通过重写该方法可以使用各种方式来自定义查询集. </p>
<a id="more"></a>

<hr>
<h3 id="根据当前用户进行过滤"><a href="#根据当前用户进行过滤" class="headerlink" title="根据当前用户进行过滤"></a>根据当前用户进行过滤</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> Purchase</span><br><span class="line"><span class="keyword">from</span> myapp.serializers <span class="keyword">import</span> PurchaseSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    serializer_class = PurchaseSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        This view should return a list of all the purchases</span></span><br><span class="line"><span class="string">        for the currently authenticated user.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        user = self.request.user</span><br><span class="line">        <span class="keyword">return</span> Purchase.objects.filter(purchaser=user)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="根据url的变量-查询参数进行查询"><a href="#根据url的变量-查询参数进行查询" class="headerlink" title="根据url的变量/查询参数进行查询"></a>根据url的变量/查询参数进行查询</h3><h4 id="根据url变量进行过滤"><a href="#根据url变量进行过滤" class="headerlink" title="根据url变量进行过滤"></a>根据url变量进行过滤</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#url.py</span></span><br><span class="line">url(<span class="string">'^purchases/(?P&lt;username&gt;.+)/$'</span>, PurchaseList.as_view()),</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    serializer_class = PurchaseSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        This view should return a list of all the purchases for</span></span><br><span class="line"><span class="string">        the user as determined by the username portion of the URL.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        username = self.kwargs[<span class="string">'username'</span>]</span><br><span class="line">        <span class="keyword">return</span> Purchase.objects.filter(purchaser__username=username)</span><br></pre></td></tr></table></figure>

<h4 id="根据查询参数进行过滤"><a href="#根据查询参数进行过滤" class="headerlink" title="根据查询参数进行过滤"></a>根据查询参数进行过滤</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    serializer_class = PurchaseSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        queryset = Purchase.objects.all()</span><br><span class="line">        username = self.request.query_params.get(<span class="string">'username'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queryset = queryset.filter(purchaser__username=username)</span><br><span class="line">        <span class="keyword">return</span> queryset</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h3><p>rest-framework提供了一些通用的过滤方案, 例如通过模型某些字段的值来过滤结果, 通过搜索功能以过滤结果等, 我们直接配置即可.</p>
<p>首先配置<code>filter_backend</code>, 然后配置相关项</p>
<hr>
<h3 id="SearchFilter-搜索过滤"><a href="#SearchFilter-搜索过滤" class="headerlink" title="SearchFilter 搜索过滤"></a>SearchFilter 搜索过滤</h3><p>支持简单的单参数查询过滤, 基于django admin 的 search 功能实现.</p>
<p>当使用SearchFilter时, 需要设置<code>search_fields</code>属性.<code>search_fields</code>是一个包含该模型text类型字段(例如CharField/TextField)的字符串列表, 对于外键字段, 则需要指定该外键对应外模型的text类型字段, 用双下划线连接.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    filter_backends = [filters.SearchFilter]</span><br><span class="line">    search_fields = [<span class="string">'username'</span>, <span class="string">'email'</span>, <span class="string">'country__country_name'</span>]</span><br></pre></td></tr></table></figure>

<p>然后就可以支持如下的url请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?search=russell</span><br></pre></td></tr></table></figure>

<p>另外, 支持在search_field添加一些符号来更改搜索行为的限制</p>
<p><code>=</code>: exact match 完全匹配<br><code>^</code>: start-with 开头匹配<br><code>@</code>: full-text 全文搜索(仅支持MySQL后端)<br><code>$</code>: regex 正则搜索</p>
<p>例如<br><code>search_fields = [&#39;=username&#39;, &#39;=email&#39;]</code></p>
<p>在默认情况下, 搜索的查询参数名为<code>search</code>, 可以通过<code>SEARCH_PARAM</code>设置项修改, 或者通过<code>get_search_fields()</code>方法动态获得.</p>
<hr>
<h3 id="OrderingFilter-排序过滤"><a href="#OrderingFilter-排序过滤" class="headerlink" title="OrderingFilter 排序过滤"></a>OrderingFilter 排序过滤</h3><p>指定过滤后端, 并指定<code>ordering_fields</code>给出要用以排序的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    filter_backends = [filters.OrderingFilter]</span><br><span class="line">    ordering_fields = [<span class="string">'username'</span>, <span class="string">'email'</span>]</span><br></pre></td></tr></table></figure>

<p>默认的搜索查询参数名为<code>search</code>, 可以通过<code>ORDERING_PARAM</code>设置项修改.</p>
<p>现在可以将这些字段包含在url的查询参数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?ordering=username</span><br></pre></td></tr></table></figure>

<p>或者使用<code>-</code>来指定反向排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?ordering=-username</span><br></pre></td></tr></table></figure>

<p>或者指定多个排序字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?ordering=account, username</span><br></pre></td></tr></table></figure>

<p>如果未指定ordering_fields, 则客户端可以通过序列化器的任何readable字段进行排序.(可能会引起某些敏感信息的泄露)</p>
<p>如果确定可以通过model的任意字段进行排序, 可以显式地指定其值为<code>__all__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookingsListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Booking.objects.all()</span><br><span class="line">    serializer_class = BookingSerializer</span><br><span class="line">    filter_backends = [filters.OrderingFilter]</span><br><span class="line">    ordering_fields = <span class="string">'__all__'</span></span><br></pre></td></tr></table></figure>

<p>或者通过ordering属性指定默认排序字段, 数据类型为字符串或字符串列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    filter_backends = [filters.OrderingFilter]</span><br><span class="line">    ordering_fields = [<span class="string">'username'</span>, <span class="string">'email'</span>]</span><br><span class="line">    ordering = [<span class="string">'username'</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DjangoFilterBackend"><a href="#DjangoFilterBackend" class="headerlink" title="DjangoFilterBackend"></a>DjangoFilterBackend</h3><p><code>django-filter</code>库提供了<code>DjangoFilterBackend</code>类, 支持高度定制化的字段过滤. </p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install django-filters</span><br></pre></td></tr></table></figure>

<p>然后将其添加至django项目settings.py的<code>INSTALLED_APPS</code>中.</p>
<p>之后将<code>DjangoFilterBackend</code>设置为rest-framework的默认过滤后端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_FILTER_BACKENDS'</span>: [<span class="string">'django_filters.rest_framework.DjangoFilterBackend'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在view/viewset中通过<code>filter_backends</code>指定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    filter_backends = [DjangoFilterBackend]</span><br></pre></td></tr></table></figure>

<p>如果需要简单的等值查询, 可以设置view/viewset的<code>filterset_fields</code>属性, 指定该过滤后端所使用的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend]</span><br><span class="line">    filterset_fields = [<span class="string">'category'</span>, <span class="string">'in_stock'</span>]</span><br></pre></td></tr></table></figure>

<p>指定<code>filterset_fields</code>属性会自动生成一个包含这些字段的<code>FilterSet</code>类, 支持如下形式的request</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/products?category=clothing&amp;in_stock=True</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义通用过滤"><a href="#自定义通用过滤" class="headerlink" title="自定义通用过滤"></a>自定义通用过滤</h3><p>继承<code>BaseFilterBackend</code>, 并重写<code>.filter_queryset(self, request, queryset, view)</code>方法, 该方法应该返回一个新的, 过滤后的查询集.</p>
<p>示例: 一个只允许用户获得自己创建的对象的过滤后端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsOwnerFilterBackend</span><span class="params">(filters.BaseFilterBackend)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Filter that only allows users to see their own objects.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter_queryset</span><span class="params">(self, request, queryset, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> queryset.filter(owner=request.user)</span><br></pre></td></tr></table></figure>

<p>自定义过滤后端相较于直接将逻辑写在<code>get_queryset</code>方法中, 优势在于易于复用.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 限流 Throttling</title>
    <url>/2019/10/03/14.%20%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>限流(Throttling)和权限类似, 用以判断一个请求是否应该被处理. 限流是一种<strong>临时</strong>的状态, 用以限制<strong>一段时间内</strong>客户端可以对API发起请求的速率.</p>
<p>在rest-framework中, 可以使用多重限制, 以适用不同的请求类型.</p>
<p>例如定义一个全局的限流策略, 但对已登录的用户施以更少的限制, 或者对一些资源密集型接口施以更严格的限制, 或是施加多重速率限制, 例如将用户的请求限制为每分钟60个请求，但不能多于每天1000个请求.</p>
<p>跟权限一样, 所有的限流检查会在view被执行<strong>之前</strong>进行, 如果限流认证未通过, 抛出<code>exceptions.Throttled</code>, 主体函数不会被执行.</p>
<a id="more"></a>

<p>在使用限流系统时, 有如下两个技术问题:</p>
<ol>
<li>区别不同客户端, 以保证每个客户端作为限流的基本单位的依据到底是什么?</li>
<li>在何处存储每个客户端以及其近期访问的统计数据?</li>
</ol>
<p>对于前者, 在未登录的情况下, 使用的是<code>X-Forwarded-For</code>(HTTP头)和<code>REMOTE_ADDR</code>(WSGI变量)来作为每个客户端特有的标识, 优先级递减.而在登陆的状态下, 使用的则是用户id.</p>
<p>而后者, 答案是Django的缓存. 限流的实现需要使用缓存来保存每个客户端近期已请求的API及其次数等数据, 因此要使用限流必须保证Django的缓存被正确配置.</p>
<p>默认情况下, rest-framework使用默认缓存(default)来保存数据, 如果想指定缓存, 可以重写限流类的<code>cache</code>属性.</p>
<p>更改限流类使用的缓存的示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> caches</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomAnonRateThrottle</span><span class="params">(AnonRateThrottle)</span>:</span></span><br><span class="line">    cache = caches[<span class="string">'alternate'</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="设定限流策略"><a href="#设定限流策略" class="headerlink" title="设定限流策略"></a>设定限流策略</h3><p>我们可以从两个层次设定限流策略</p>
<ol>
<li>全局限流策略, 任何不被单独指定的view会应用该限流策略</li>
<li>视图级别的限流策略, 单独指定某个view/viewset范围内的限流策略, 通过throttle_classes属性给出</li>
</ol>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py 全局限流设置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.throttling.AnonRateThrottle'</span>, </span><br><span class="line">        <span class="string">'rest_framework.throttling.UserRateThrottle'</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'anon'</span>: <span class="string">'100/day'</span>, </span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'1000/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个限流都需要有一个<code>rate</code>属性, 来指定自己的速率限制.我们可以直接重写某个默认限流类并修改rate属性, 也可以在setting中直接配置.</p>
<p>rate是一个字符串, 格式为 <code>次数/时间段</code>, 时间段可用’day’, ‘hour’, ‘minute’, ‘second’, 例如<code>&#39;100/day&#39;</code>, <code>&#39;10/minute&#39;</code> </p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><p>rest-framework 提供了三个限流类</p>
<h3 id="AnonRateThrottle"><a href="#AnonRateThrottle" class="headerlink" title="AnonRateThrottle"></a>AnonRateThrottle</h3><p>用于匿名(未登录)用户的限流, ip地址作为限流依据. </p>
<p>限流速率的给出方式(优先级递减):</p>
<ol>
<li>rate属性</li>
<li>settings文件中的<code>DEFAULT_THROTTLE_RATES[&#39;anon&#39;]</code>项</li>
</ol>
<p><code>UserRateThrottle</code>在简单地为匿名用户设定全局速率限制时适用.</p>
<hr>
<h3 id="UserRateThrottle"><a href="#UserRateThrottle" class="headerlink" title="UserRateThrottle"></a>UserRateThrottle</h3><p>用于已登录用户的限流, 用户id作为限流依据</p>
<p>限流速率的给出方式</p>
<ol>
<li>rate属性</li>
<li>setting文件中的<code>DEFAULT_THROTTLE_RATES[&#39;user&#39;]</code>项</li>
</ol>
<p>可以使用多个UserRateThrottle的子类来实现多重限制.</p>
<p>例如</p>
<p>首先定义多个UserRateThrottle的子类, 并为其指定不同的scope, 以在设置文件中通过<code>DEFAULT_THROTTLE_RATES[scope]</code>为其设定不同rate</p>
<p>(直接重写rate的方式, 显然不如在setting中统一配置更易管理)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BurstRateThrottle</span><span class="params">(UserRateThrottle)</span>:</span></span><br><span class="line">    scope = <span class="string">'burst'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SustainedRateThrottle</span><span class="params">(UserRateThrottle)</span>:</span></span><br><span class="line">    scope = <span class="string">'sustained'</span></span><br></pre></td></tr></table></figure>

<p>然后在setting中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'example.throttles.BurstRateThrottle'</span>, </span><br><span class="line">        <span class="string">'example.throttles.SustainedRateThrottle'</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'burst'</span>: <span class="string">'60/min'</span>, </span><br><span class="line">        <span class="string">'sustained'</span>: <span class="string">'1000/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserRateThrottle</code>在简单地为每个用户设定全局速率限制时适用.</p>
<hr>
<h3 id="ScopedRateThrottle"><a href="#ScopedRateThrottle" class="headerlink" title="ScopedRateThrottle"></a>ScopedRateThrottle</h3><p>AnonRateThrottle 和 UserRateThrottle 两个限流类都是全局应用的.</p>
<p>例如一个已登录用户, 对任意API的访问次数都被累计, 在达到UserRateThrottle的上限时, 则暂时无法访问任何API.</p>
<p>这显然是不合适的, 我们应该对一些高代价的API施加严格的限制, 但另一些API则应该相当宽松, 而这些API的访问次数累计和访问限制应当分开计算, 即使是来自同一用户的访问.</p>
<p>ScopedRateThrottle类可以按照不同的标识将一些API分组计算, 每个ScopedRateThrottle仅会累计匹配自己唯一标识的API的访问次数.</p>
<p>首先我们为一些View指定限流标识</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactListView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'contacts'</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactDetailView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'contacts'</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'uploads'</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>然后在设置中使用<code>DEFAULT_THROTTLE_RATES[throttle_scope]</code>的方式为每一个限流scope指定速率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.throttling.ScopedRateThrottle'</span>, </span><br><span class="line">    ], </span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'contacts'</span>: <span class="string">'1000/day'</span>, </span><br><span class="line">        <span class="string">'uploads'</span>: <span class="string">'20/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们施加多重速率限制的不同, 在使用UserRateThrottle类时, 我们使用了多个UserRateThrottle的子类来施加多重速率限制, 不同的scope在不同的限流类(子类)中.</p>
<p>而在使用ScopedRateThrottle类时, 我们仅需要指定为view指定不同标识, 然后设定不同标识的限制速率即可, 使用的就是ScopedRateThrottle本身.不同的throttle_scope在不同的view中.</p>
<p>另一点则相当明确: 以上的所有代码中, 我们都不重写rate属性, 而是在设置文件中使用DEFAULT_THROTTLE_RATES[x-scope]的方式进行设置, 这样更易管理.</p>
<hr>
<h3 id="Custom-throttles-自定义限流类"><a href="#Custom-throttles-自定义限流类" class="headerlink" title="Custom throttles 自定义限流类"></a>Custom throttles 自定义限流类</h3><p>自定义限流类需要重写<code>BaseThrottle</code>并实现<code>.allow_request(self, request, view)</code>方法.该方法应该返回一个布尔型, 以判定是否通过了限流验证.</p>
<p>除此之外, 还可以实现<code>.wait()</code>方法, 该方法在allow_request方法返回false时被调用, 应当返回一个推荐值, 指定在接受下一个请求前应当间隔的时间.</p>
<p>在实现了<code>wait()</code>方法后, 如果该方法被调用, 响应中会包含<code>Retry-After</code>头, 以告知客户端应当在推荐值之后再重试.</p>
<p>示例代码 实现一个随机10选9的限流类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomRateThrottle</span><span class="params">(throttling.BaseThrottle)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_request</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> random.randint(<span class="number">1</span>, <span class="number">10</span>) != <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 缓存 Cache</title>
    <url>/2019/10/03/13.%20%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>rest-framework中的缓存行为可以非常简单地使用Django的缓存来实现.</p>
<a id="more"></a>
<hr>
<h3 id="在APIView和ViewSets中使用缓存"><a href="#在APIView和ViewSets中使用缓存" class="headerlink" title="在APIView和ViewSets中使用缓存"></a>在APIView和ViewSets中使用缓存</h3><p>Django提供了<code>method_decorator</code>以便装饰器能够用在<strong>方法</strong>上，所以仍然可以使用<code>@cache_page</code>或<code>vary_on_cookie</code>这些缓存相关的装饰器来装饰的ViewSet中的方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.Viewset)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Cache requested url for each user for 2 hours</span></span><br><span class="line"><span class="meta">    @method_decorator(cache_page(60*60*2))</span></span><br><span class="line"><span class="meta">    @method_decorator(vary_on_cookie)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        content = &#123;</span><br><span class="line">            <span class="string">'user_feed'</span>: request.user.get_user_feed()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostView</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Cache page for the requested url</span></span><br><span class="line"><span class="meta">    @method_decorator(cache_page(60*60*2))</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        content = &#123;</span><br><span class="line">            <span class="string">'title'</span>: <span class="string">'Post title'</span>,</span><br><span class="line">            <span class="string">'body'</span>: <span class="string">'Post content'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure>

<p>注意, <code>cache_page</code>仅会缓存<code>GET</code>和<code>HEAD</code>请求获取的状态码为200的响应.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 权限 Permissions</title>
    <url>/2019/10/03/12.%20%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>权限与身份认证和限流一起决定一个请求是否应该被允许或是拒绝.</p>
<p>权限检查在视图函数主体运行之前进行, 只有检查通过才会执行函数体, 权限一般使用<code>reuqest.user</code>或者<code>request.auth</code>的信息来进行验证.</p>
<p>rest-framework 中的权限应当始终指定为一个权限类的列表, 列表所有的权限对象必须<strong>都</strong>通过之后才被视为通过.任意权限类检查失败, 会抛出一个<code>exceptions.PermissionDenied</code>或<code>exceptions.NotAuthenticated</code>异常.</p>
<a id="more"></a>


<p>权限检查失败时, 响应的状态码为 <code>403 Forbidden</code> 或 <code>401 Unauthorized</code></p>
<ul>
<li>如果请求通过用户身份认证, 但权限不足, 会返回<code>403 Forbidden</code></li>
<li>如果请求未通过用户身份认证, 但身份认证类不使用<code>WWW-Authenticate</code>头时, 也会返回<code>403 Unauthorized</code></li>
<li>如果请求未通过用户身份认证, 且最先应用的身份认证类中使用<code>WWW-Authenticate</code>, 会返回<code>401 Unauthorized</code>, 并包含合适的<code>WWW-Authenticate</code>头.</li>
</ul>
<hr>
<h3 id="对象级别的权限"><a href="#对象级别的权限" class="headerlink" title="对象级别的权限"></a>对象级别的权限</h3><p>这里的对象一般指的是一个Model的实例, 即某一条数据记录.</p>
<p>对象级别的权限验证会在GenericAPIView及其子类的<code>get_object()</code>方法被调用时进行验证.</p>
<p>如果对象级别的权限验证未通过, 会抛出<code>exceptions.PermissionDenied</code>异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self)</span>:</span></span><br><span class="line">    obj = get_object_or_404(self.get_queryset(), pk=self.kwargs[<span class="string">"pk"</span>])</span><br><span class="line">    self.check_object_permissions(self.request, obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>在rest-framework所提供的所有权限验证类中, 并不直接提供对象级别的验证, 所有的该级别验证都需要通过重写<code>has_object_permission()</code>实现, 而rest-framework会自动使用该方法检查权限.</p>
<p>详情查阅<strong>自定义权限验证</strong>一节. </p>
<hr>
<h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>全局权限设置通过settings的<code>DEFAULT_PERMISSION_CLASSES</code>项进行设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span>, </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者通过<code>permission_classes</code>属性为指定APIview进行设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    permission_classes = (IsAuthenticated, )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在视图中指定permission_classes意味着忽略默认的权限验证类</p>
<p>另外, 每个权限项可以由多个权限类用<code>|</code>、<code>&amp;</code>、<code>~</code>来组合作为权限类列表中的一个对象.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission, IsAuthenticated, SAFE_METHODS</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadOnly</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> request.method <span class="keyword">in</span> SAFE_METHODS</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    permission_classes = [IsAuthenticated|ReadOnly]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        content = &#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="string">'request was permitted'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><p>以下各项从<code>rest_framework.permissions</code>中导出</p>
<hr>
<h3 id="AllowAny"><a href="#AllowAny" class="headerlink" title="AllowAny:"></a>AllowAny:</h3><p>无论如何, 允许无限制访问</p>
<hr>
<h3 id="IsAuthenticated"><a href="#IsAuthenticated" class="headerlink" title="IsAuthenticated:"></a>IsAuthenticated:</h3><ol>
<li>身份认证通过, 允许任何访问.</li>
<li>身份认证未通过, 禁止任何访问.</li>
</ol>
<hr>
<h3 id="IsAdminUser"><a href="#IsAdminUser" class="headerlink" title="IsAdminUser"></a>IsAdminUser</h3><ol>
<li>用户的is_stuff == True, 允许任何访问</li>
<li>用户的is_stuff == False, 禁止任何访问</li>
</ol>
<hr>
<h3 id="IsAuthenticatedOrReadOnly"><a href="#IsAuthenticatedOrReadOnly" class="headerlink" title="IsAuthenticatedOrReadOnly"></a>IsAuthenticatedOrReadOnly</h3><ol>
<li>身份认证通过, 允许任何访问</li>
<li>身份认证未通过, 允许只读访问</li>
</ol>
<hr>
<h3 id="DjangoModelPermissions"><a href="#DjangoModelPermissions" class="headerlink" title="DjangoModelPermissions"></a>DjangoModelPermissions</h3><p>该权限与DjangoModelPermissions相关联, 对于用户不同方式的请求, 验证对应的django权限(Model级别的权限验证)</p>
<p>因为必须与模型相关联, 该权限类仅能应用于具有.queryset属性的视图, 且仅有<strong>通过身份认证</strong>的用户才有可能通过权限验证</p>
<ul>
<li><code>POST</code> 请求要求用户对模型具有添加权限。</li>
<li><code>PUT</code> 和 <code>PATCH</code> 请求要求用户对模型具有更改权限。</li>
<li><code>DELETE</code>请求要求用户对模型具有删除权限。</li>
</ul>
<p>如果为匿名用户, 则一定被禁止.</p>
<hr>
<h3 id="DjangoModelPermissionsOrAnonReadOnly"><a href="#DjangoModelPermissionsOrAnonReadOnly" class="headerlink" title="DjangoModelPermissionsOrAnonReadOnly"></a>DjangoModelPermissionsOrAnonReadOnly</h3><p>与前者类似, 但允许匿名用户拥有只读权限.</p>
<hr>
<h3 id="DjangoObjectPermissions"><a href="#DjangoObjectPermissions" class="headerlink" title="DjangoObjectPermissions"></a>DjangoObjectPermissions</h3><p>该类由<a href="https://github.com/rpkilby/django-rest-framework-guardian" target="_blank" rel="noopener">djangorestframework-guardian package</a>提供.</p>
<p>绑定于Django的对象级别的权限验证, 允许对每个对象的权限(Model的实例, 对象级别的权限验证)进行单独指定.</p>
<p>当然, Django默认不支持该功能, 因此需要添加一个支持对象级别权限的权限后端, 例如<code>django-guardian</code></p>
<p>与DjangoModelPermissions一样, 该权限只有在用户已通过身份认证, 且用于与HTTP METHOD相对应的对象级别权限时才会被通过.</p>
<hr>
<h2 id="自定义权限验证"><a href="#自定义权限验证" class="headerlink" title="自定义权限验证"></a>自定义权限验证</h2><p>子类化<code>BasePermission</code>并实现以下两个方法</p>
<ul>
<li><code>.has_permission(self, request, view)</code></li>
<li><code>.has_object_permission(self, request, view, obj)</code></li>
</ul>
<p>这两个方法都应当返回一个布尔型, <code>True</code>代表验证通过, <code>False</code>则代表验证未通过.</p>
<p>前者代表模型级别的权限验证, 后者则是对象级别的权限验证</p>
<p>对象级别的权限验证仅当<code>get_object()</code>被调用时进行检查, 且必须在模型级别的验证通过时才会进行到这一步.</p>
<p>在GenericAPIView的子类中会自动调用<code>check_object_permissions</code>, 而在APIView的子类中你必须手动调用这一方法.</p>
<p>只读操作的HTTP METHOD为<code>GET</code>, <code>OPTION</code>及<code>HEAD</code>, 包含在<code>permissions.SAFE_METHODS</code>中.</p>
<p>示例</p>
<p>使用权限类实现黑名单. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlacklistPermission</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Global permission check for blacklisted IPs.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        ip_addr = request.META[<span class="string">'REMOTE_ADDR'</span>]</span><br><span class="line">        blacklisted = Blacklist.objects.filter(ip_addr=ip_addr).exists()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> blacklisted</span><br></pre></td></tr></table></figure>

<p>自定义权限类, 仅允许对象的拥有者进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsOwnerOrReadOnly</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Object-level permission to only allow owners of an object to edit it.</span></span><br><span class="line"><span class="string">    Assumes the model instance has an `owner` attribute.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_object_permission</span><span class="params">(self, request, view, obj)</span>:</span></span><br><span class="line">        <span class="comment"># Read permissions are allowed to any request, </span></span><br><span class="line">        <span class="comment"># so we'll always allow GET, HEAD or OPTIONS requests.</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Instance must have an attribute named `owner`.</span></span><br><span class="line">        <span class="keyword">return</span> obj.owner == request.user</span><br></pre></td></tr></table></figure>

<p>值得注意的是, 在list操作中, 仅会进行模型级别的权限检查, 对象级别的权限不会被检查(只有在get_object方法被调用时才会进行对象级别的检查), 因此如果有必要, 则需要将其验证逻辑写入filter而非对象级别的权限中, 这样才能保证在get_queryset时获取到适当的queryset. </p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>10.2 序列化器字段:关系字段 Serializer Field</title>
    <url>/2019/10/03/10.2%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%AD%97%E6%AE%B5-%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>关系字段用来表示模型之间的关系, 这些字段可用于映射外键, 多对多关系字段, 和单对单关系字段, 反向关联字段, 也可以自定义关系字段.</p>
<p>所有的关系字段定义在<code>relations.py</code>中, 但出于方便起见, 应该在<code>serializers</code>模块中导出, 然后通过<code>serializers.&lt;FieldName&gt;</code>使用关系字段.</p>
<a id="more"></a>

<hr>
<h4 id="查看关系"><a href="#查看关系" class="headerlink" title="查看关系"></a>查看关系</h4><p>当使用<code>ModelSerializer</code>时, 序列化器字段和关系字段都被自动生成, 查看具体定义可以帮助你决定如何自定义关系风格.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python manage.py shell</span></span><br><span class="line">&gt;&gt;&gt; from myapp.serializers import AccountSerializer</span><br><span class="line">&gt;&gt;&gt; serializer = AccountSerializer()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(repr(serializer))</span><br><span class="line">AccountSerializer():</span><br><span class="line">    id = IntegerField(label=<span class="string">'ID'</span>, read_only=True)</span><br><span class="line">    name = CharField(allow_blank=True, max_length=100, required=False)</span><br><span class="line">    owner = PrimaryKeyRelatedField(queryset=User.objects.all())</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><p>为了理解各种类型的关系字段, 我们首先建立几个模型, 用以在我们的示例代码中使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Album</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    album_name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    artist = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    album = models.ForeignKey(Album, related_name=<span class="string">'tracks'</span>, on_delete=models.CASCADE)</span><br><span class="line">    order = models.IntegerField()</span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    duration = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        unique_together = (<span class="string">'album'</span>, <span class="string">'order'</span>)</span><br><span class="line">        ordering = [<span class="string">'order'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__unicode__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%d: %s'</span> % (self.order, self.title)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="StringRelatedField"><a href="#StringRelatedField" class="headerlink" title="StringRelatedField"></a>StringRelatedField</h3><p>该字段会将外键指向的模型的<code>.__str__()</code>方法的返回值作为展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.StringRelatedField(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>该序列化器将数据序列化为如下格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Things We Lost In The Fire'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Low'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'1: Sunflower'</span>, </span><br><span class="line">        <span class="string">'2: Whitetail'</span>, </span><br><span class="line">        <span class="string">'3: Dinosaur Act'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该字段固定为<code>只读</code>字段</p>
<p>参数:</p>
<p><code>many</code>参数, 如果是*对多字段, 就必须将<code>many</code>设为<code>True</code></p>
<hr>
<h3 id="PrimaryKeyRelatedField"><a href="#PrimaryKeyRelatedField" class="headerlink" title="PrimaryKeyRelatedField"></a>PrimaryKeyRelatedField</h3><p>序列化结果为外模型的主键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.PrimaryKeyRelatedField(many=<span class="literal">True</span>, read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>该字段为读写字段, 可以使用read_only标志来更改为只读.</p>
<p>参数</p>
<p><code>queryset</code>: 用指定一个查询集, 传入(序列化或者反序列化时)时作为验证该字段接收到的值是否合法的范围, </p>
<p><code>many</code>: 对于一个’X对多’字段来说, <code>many</code>必须设为<code>True</code>才能使其接收多个对象(many参数用于关系字段或本身是一个序列器的字段)</p>
<p><code>allow_null</code>: 指定<code>None</code>值是否是合法的输入, 默认为<code>False</code></p>
<p><code>pk_field</code>: 指定一个字段以控制主键值的序列化/反序列化, 例如<code>pk_field = UUIDField(format =&#39;hex&#39;)</code>会将UUID主键序列化为其紧凑的十六进制表示. </p>
<hr>
<h3 id="HyperlinkedRelatedField"><a href="#HyperlinkedRelatedField" class="headerlink" title="HyperlinkedRelatedField"></a>HyperlinkedRelatedField</h3><p>对外模型的序列化结果为指向该外模型detail页面的超链接.</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.HyperlinkedRelatedField(</span><br><span class="line">        many=<span class="literal">True</span>, </span><br><span class="line">        read_only=<span class="literal">True</span>, </span><br><span class="line">        view_name=<span class="string">'track-detail'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Graceland'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Paul Simon'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'http://www.example.com/api/tracks/45/'</span>, </span><br><span class="line">        <span class="string">'http://www.example.com/api/tracks/46/'</span>, </span><br><span class="line">        <span class="string">'http://www.example.com/api/tracks/47/'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认为读写字段, 可以使用read_only标志来更改</p>
<p><code>view_name</code> 必需参数, 指定关联目标的api-view, 如果使用<code>Router</code>来注册, 则为<code>&lt;modelname&gt;-detail</code><br><code>queryset</code> 用以校验输入是否合法的查询集, 如果不设定参数, 则必须置<code>read_only</code>=<code>True</code><br><code>lookup_field</code> 用以检索的关联目标的字段, 应该对应于引用视图上的URL关键字参数, 默认为<code>pk</code><br><code>lookup_url_kwarg</code> 在url conf中定义的关键字参数名, 默认使用与<code>lookup_field</code>相同的值<br><code>format</code> 如果使用格式后缀, 超链接字段将会为目标模型的url使用同样的后缀, 除非重写<code>format</code>参数</p>
<p>注: 写操作时传入的外键字段值是目标对象的detial的超链接.</p>
<hr>
<h3 id="SlugRelatedField"><a href="#SlugRelatedField" class="headerlink" title="SlugRelatedField"></a>SlugRelatedField</h3><p>使用外模型的某个字段来表示模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.SlugRelatedField(</span><br><span class="line">        many=<span class="literal">True</span>, </span><br><span class="line">        read_only=<span class="literal">True</span>, </span><br><span class="line">        slug_field=<span class="string">'title'</span></span><br><span class="line">     )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Dear John'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Loney Dear'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'Airport Surroundings'</span>, </span><br><span class="line">        <span class="string">'Everything Turns to You'</span>, </span><br><span class="line">        <span class="string">'I Was Only Going Out'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认为读写字段</p>
<p><code>slug_field</code> 指定使用外模型的哪个字段来表示该模型, 注意, <strong>该外模型字段必须受到<code>unique</code>约束</strong></p>
<hr>
<h3 id="HyperlinkedIdentityField"><a href="#HyperlinkedIdentityField" class="headerlink" title="HyperlinkedIdentityField"></a>HyperlinkedIdentityField</h3><p>HyperlinkedIdentityField用于自动生成<strong>当前模型</strong>的超链接, 指向<strong>当前模型</strong>的detial接口.</p>
<p>HyperlinkedModelSerializer中会使用该字段生成指向自身detail界面的<code>url</code>字段以取代<code>id</code>字段. </p>
<p>该字段会传入整个当前对象, 并将其中某个属性作为生成detail链接的字段, 通常用id作为<code>pk</code>.</p>
<p>所以:</p>
<ol>
<li>使用HyperlinkedIdentityField链接到当前正在序列化的对象.</li>
<li>使用HyperlinkedRelatedField链接到与序列化的对象相关的对象.</li>
</ol>
<p>因此, 对于一对一关系, 外键关系, 多对多关系以及基本上任何其他涉及关系的事物(在Django模型中)都应该使用<code>HyperlinkedRelatedField</code>. </p>
<p>使用<code>HyperlinkedRelatedField</code>的唯一时间是url字段, 可以在序列化程序中包含该字段以指向当前对象. </p>
<p>该字段为固化的<code>read_only</code>字段.</p>
<p>参数:</p>
<p><code>view_name</code>: 必需参数, 指定关联目标的api-view, 如果使用<code>Router</code>来注册, 则为<code>&lt;modelname&gt;-detail</code><br><code>lookup_field</code>: 默认为<code>pk</code>, 用于查找当前对象的主字段, 需要与url关键字(lookup_url_kwargs)保持一致.<br><code>lookup_url_kwarg</code>: 用于查找对象的url关键字, 需要与lookup_field保持一致.<br><code>format</code>: 需要为超链接添加的后缀.</p>
<p>请参阅<code>HyperlinkedSerializer</code>一节.</p>
<hr>
<h3 id="嵌套关系"><a href="#嵌套关系" class="headerlink" title="嵌套关系"></a>嵌套关系</h3><p>嵌套关系可以使用序列器作为字段来表示</p>
<p>如果该序列器对应的是*对多关系, 则必须设置<code>many</code>=<code>True</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Track</span><br><span class="line">        fields = (<span class="string">'order'</span>, <span class="string">'title'</span>, <span class="string">'duration'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = TrackSerializer(many=<span class="literal">True</span>, read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; album = Album.objects.create(album_name="The Grey Album", artist='Danger Mouse')</span><br><span class="line">&gt;&gt;&gt; Track.objects.create(album=album, order=1, title='Public Service Announcement', duration=245)</span><br><span class="line">&lt;Track: Track object&gt;</span><br><span class="line">&gt;&gt;&gt; Track.objects.create(album=album, order=2, title='What More Can I Say', duration=264)</span><br><span class="line">&lt;Track: Track object&gt;</span><br><span class="line">&gt;&gt;&gt; Track.objects.create(album=album, order=3, title='Encore', duration=159)</span><br><span class="line">&lt;Track: Track object&gt;</span><br><span class="line">&gt;&gt;&gt; serializer = AlbumSerializer(instance=album)</span><br><span class="line">&gt;&gt;&gt; serializer.data</span><br><span class="line">&#123;</span><br><span class="line">    'album_name': 'The Grey Album', </span><br><span class="line">    'artist': 'Danger Mouse', </span><br><span class="line">    'tracks': [</span><br><span class="line">        &#123;'order': 1, 'title': 'Public Service Announcement', 'duration': 245&#125;, </span><br><span class="line">        &#123;'order': 2, 'title': 'What More Can I Say', 'duration': 264&#125;, </span><br><span class="line">        &#123;'order': 3, 'title': 'Encore', 'duration': 159&#125;, </span><br><span class="line">        ...</span><br><span class="line">    ], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可写的嵌套序列化器"><a href="#可写的嵌套序列化器" class="headerlink" title="可写的嵌套序列化器"></a>可写的嵌套序列化器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Track</span><br><span class="line">        fields = (<span class="string">'order'</span>, <span class="string">'title'</span>, <span class="string">'duration'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = TrackSerializer(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        tracks_data = validated_data.pop(<span class="string">'tracks'</span>)</span><br><span class="line">        album = Album.objects.create(**validated_data)</span><br><span class="line">        <span class="keyword">for</span> track_data <span class="keyword">in</span> tracks_data:</span><br><span class="line">            Track.objects.create(album=album, **track_data)</span><br><span class="line">        <span class="keyword">return</span> album</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'The Grey Album'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Danger Mouse'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        &#123;<span class="string">'order'</span>: <span class="number">1</span>, <span class="string">'title'</span>: <span class="string">'Public Service Announcement'</span>, <span class="string">'duration'</span>: <span class="number">245</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'order'</span>: <span class="number">2</span>, <span class="string">'title'</span>: <span class="string">'What More Can I Say'</span>, <span class="string">'duration'</span>: <span class="number">264</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'order'</span>: <span class="number">3</span>, <span class="string">'title'</span>: <span class="string">'Encore'</span>, <span class="string">'duration'</span>: <span class="number">159</span>&#125;, </span><br><span class="line">    ], </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer = AlbumSerializer(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.is_valid()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.save()</span><br><span class="line">&lt;Album: Album object&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义关系字段"><a href="#自定义关系字段" class="headerlink" title="自定义关系字段"></a>自定义关系字段</h3><p>子类化<code>RelatedField</code>并实现<code>.to_representation(self, value)</code>方法以实现只读关系字段, 如果要实现读写关系字段, 还要实现<code>.to_internal_value(self, data)</code>方法.</p>
<p>如果想要动态提供queryset用以限制外键的合法范围, 需要重写<code>.get_queryset(self)</code>方法以获得queryset而非在初始化该字段时通过<code>queryset</code>参数指定.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackListingField</span><span class="params">(serializers.RelatedField)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        duration = time.strftime(<span class="string">'%M:%S'</span>, time.gmtime(value.duration))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Track %d: %s (%s)'</span> % (value.order, value.name, duration)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = TrackListingField(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = [<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>]</span><br></pre></td></tr></table></figure>

<p>序列化结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Sometimes I Wish We Were an Eagle'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Bill Callahan'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'Track 1: Jim Cain (04:39)'</span>, </span><br><span class="line">        <span class="string">'Track 2: Eid Ma Clack Shaw (04:19)'</span>, </span><br><span class="line">        <span class="string">'Track 3: The Wind and the Dove (04:34)'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义超链接字段"><a href="#自定义超链接字段" class="headerlink" title="自定义超链接字段"></a>自定义超链接字段</h3><p>子类化<code>HyperlinkedRelatedField</code>并考虑重写以下两个方法:</p>
<p><code>get_url(self, obj, view_name, request, format)</code></p>
<p>通过一个obj生成指向它detial的超链接, 如果<code>view_name</code>或<code>lookup_field</code>属性未提供, 或不匹配, 抛出一个<code>NoReverseMatch</code>异常.</p>
<p><code>get_object(self, view_name, view_args, view_kwargs)</code></p>
<p>通过超链接获取对应的实例对象, 如果想要实现可写字段, 则必须重写该方法以在反序列化过程中获得实例对象. 当无法获得对象时, 抛出<code>ObjectDoesNotExist</code>异常.</p>
<p>示例:</p>
<p>我们的URL中包含两个关键字参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/api/&lt;organization_slug&gt;/customers/&lt;customer_pk&gt;/</span><br></pre></td></tr></table></figure>

<p>只接收一个url关键字的默认实现无法序列化/反序列化该格式URL, 所以我们需要自定义超链接字段:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.reverse <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHyperlink</span><span class="params">(serializers.HyperlinkedRelatedField)</span>:</span></span><br><span class="line">    <span class="comment"># We define these as class attributes, so we don't need to pass them as arguments.</span></span><br><span class="line">    view_name = <span class="string">'customer-detail'</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(self, obj, view_name, request, format)</span>:</span></span><br><span class="line">        url_kwargs = &#123;</span><br><span class="line">            <span class="string">'organization_slug'</span>: obj.organization.slug, </span><br><span class="line">            <span class="string">'customer_pk'</span>: obj.pk</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(view_name, kwargs=url_kwargs, request=request, format=format)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self, view_name, view_args, view_kwargs)</span>:</span></span><br><span class="line">        lookup_kwargs = &#123;</span><br><span class="line">           <span class="string">'organization__slug'</span>: view_kwargs[<span class="string">'organization_slug'</span>], </span><br><span class="line">           <span class="string">'pk'</span>: view_kwargs[<span class="string">'customer_pk'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> self.get_queryset().get(**lookup_kwargs)</span><br></pre></td></tr></table></figure>

<p>注意, 如果想要这种风格与通用视图兼容, 还需要在视图中重写<code>.get_object</code>方法, 以保证查找行为正确. </p>
<p>通常推荐使用平面风格的url, 但是嵌套风格的url在适度使用时也相当合理.</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr>
<h4 id="queryset参数"><a href="#queryset参数" class="headerlink" title="queryset参数"></a>queryset参数</h4><p>在初始化一个字段时传入的queryset用以验证传入的外键是否符合约束, 所以只有在<strong>可写</strong>字段中才需要该参数.</p>
<hr>
<h4 id="自定义HTML展示项"><a href="#自定义HTML展示项" class="headerlink" title="自定义HTML展示项"></a>自定义HTML展示项</h4><p>使用序列化器生成的表格中, 外键字段通常提供可选项来确保用户选择合法的字段值, 任何一个外模型的展示名都是其<code>__str__</code>函数的返回值, 但是可以通过重写<code>display_value</code>方法更改该值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackPrimaryKeyRelatedField</span><span class="params">(serializers.PrimaryKeyRelatedField)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display_value</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Track: %s'</span> % (instance.title)</span><br></pre></td></tr></table></figure>

<p><strong>选项截断</strong></p>
<p>在可选项过多时, 限制选项的截断数量.</p>
<p><code>html_cutoff</code>: 最大截断数量, 超过该数量的选项不会被展示, 默认为1000, 设为None意味着无限制.<br><code>html_cutoff_text</code> 如果截断, 截断处显示的文本. 默认为<code>&quot;More than {count} items…&quot;</code></p>
<p>可以通过<code>HTML_SELECT_CUTOFF</code>和<code>HTML_SELECT_CUTOFF_TEXT</code>设置项来进行更改.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">assigned_to = serializers.SlugRelatedField(</span><br><span class="line">   queryset=User.objects.all(),</span><br><span class="line">   slug_field=<span class="string">'username'</span>,</span><br><span class="line">   style=&#123;<span class="string">'base_template'</span>: <span class="string">'input.html'</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反向关联字段"><a href="#反向关联字段" class="headerlink" title="反向关联字段"></a>反向关联字段</h4><p>反向关联字段并非定义在当前的模型中, 因此在使用ModelSerializer时不会自动包含该字段.</p>
<p>如果想要包含该字段, 直接将反向关联字段名添加至<code>Meta</code>的<code>fields</code>属性中即可.</p>
<p>模型定义:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    album = models.ForeignKey(Album, related_name=<span class="string">'tracks'</span>, on_delete=models.CASCADE)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>反向关联名为<code>tracks</code>, 所以直接包含该字段即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        fields = [<span class="string">'tracks'</span>, ...]</span><br></pre></td></tr></table></figure>

<p>如果未定义反向关联名, 使用默认的反向关联名<code>&lt;modelname&gt;_set</code>即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        fields = [<span class="string">'track_set'</span>, ...]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="通用关系字段"><a href="#通用关系字段" class="headerlink" title="通用关系字段"></a>通用关系字段</h4><p>如果使用了<a href="https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/" target="_blank" rel="noopener">通用关系字段</a>, 则需要自定义字段, 以明确目标字段应当如何被序列化.</p>
<p>例如, 给出如下Tag模型, 可以与其他任意模型建立通用关系.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Tags arbitrary model instances using a generic relation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See: https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    tag_name = models.SlugField()</span><br><span class="line">    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    tagged_object = GenericForeignKey(<span class="string">'content_type'</span>, <span class="string">'object_id'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.tag_name</span><br></pre></td></tr></table></figure>

<p>以下两个模型, 均与Tag联系. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bookmark</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A bookmark consists of a URL, and 0 or more descriptive tags.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = models.URLField()</span><br><span class="line">    tags = GenericRelation(TaggedItem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A note consists of some text, and 0 or more descriptive tags.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    text = models.CharField(max_length=<span class="number">1000</span>)</span><br><span class="line">    tags = GenericRelation(TaggedItem)</span><br></pre></td></tr></table></figure>

<p>通过自定义字段, 用以实例化添加标签的外模型实例, 使用类型来判断究竟该如何序列化外模型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedObjectRelatedField</span><span class="params">(serializers.RelatedField)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A custom field to use for the `tagged_object` generic relationship.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Serialize tagged objects to a simple textual representation.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, Bookmark):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Bookmark: '</span> + value.url</span><br><span class="line">        <span class="keyword">elif</span> isinstance(value, Note):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Note: '</span> + value.text</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected type of tagged object'</span>)</span><br></pre></td></tr></table></figure>

<p>如果需要嵌套序列化结果, 可以在内部使用另一个序列化器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Serialize bookmark instances using a bookmark serializer,</span></span><br><span class="line"><span class="string">    and note instances using a note serializer.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(value, Bookmark):</span><br><span class="line">        serializer = BookmarkSerializer(value)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(value, Note):</span><br><span class="line">        serializer = NoteSerializer(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected type of tagged object'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer.data</span><br></pre></td></tr></table></figure>

<p>注意, 在序列化包含<code>Generic Relation</code>字段(即反向关联的通用关系字段)的模型时, 常规的关系字段即可完成, 因为此时外模型的类型总是确定的.</p>
<hr>
<h3 id="通过中间模型关联的多对多-M2M-字段"><a href="#通过中间模型关联的多对多-M2M-字段" class="headerlink" title="通过中间模型关联的多对多(M2M)字段"></a>通过中间模型关联的多对多(M2M)字段</h3><p>默认情况下, 指向通过中间模型建立的多对多关系的序列化器关系字段通常是只读的. </p>
<p>如果要声明一个指向使用了中间模型的<code>ManyToManyField</code>字段的序列化器关系字段, 确保设置<code>read_only=True</code>.</p>
<p>如果想序列化包含在中间模型的额外字段的序列化结果, 可以将中间模型作为<a href="https://www.django-rest-framework.org/api-guide/serializers/#dealing-with-nested-objects" target="_blank" rel="noopener">嵌套对象</a>进行序列化. </p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 序列化器 Validator</title>
    <url>/2019/10/03/11.%20%E9%AA%8C%E8%AF%81%E5%99%A8/</url>
    <content><![CDATA[<p>验证器用以确保数据的合法性.在rest-framework中, 验证器应当在字段定义时serializer的Meta中指定. </p>
<p>如果使用的是<code>ModelSerializer</code>, 那么会自动根据<code>Model</code>的字段类型及约束自动生成相关的验证器, 因此大多数时候不太需要手写验证器.</p>
<p>可以使用<code>repr</code>函数查看自动生成的Serializer的定义代码, 该代码包含了全部的验证逻辑, 验证逻辑也仅执行于此处.</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerReportRecord</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    time_raised = models.DateTimeField(default=timezone.now, editable=<span class="literal">False</span>)</span><br><span class="line">    reference = models.CharField(unique=<span class="literal">True</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    description = models.TextField()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serializers.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerReportSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CustomerReportRecord</span><br></pre></td></tr></table></figure>

<p>运行 python manage.py shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from project.example.serializers import CustomerReportSerializer</span><br><span class="line">&gt;&gt;&gt; serializer = CustomerReportSerializer()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(repr(serializer))</span><br><span class="line">CustomerReportSerializer():</span><br><span class="line">    id = IntegerField(label=<span class="string">'ID'</span>, read_only=True)</span><br><span class="line">    time_raised = DateTimeField(read_only=True)</span><br><span class="line">    reference = CharField(max_length=20, validators=[&lt;UniqueValidator(queryset=CustomerReportRecord.objects.all())&gt;])</span><br><span class="line">    description = CharField(style=&#123;<span class="string">'type'</span>: <span class="string">'textarea'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="UniqueValidator-唯一约束验证"><a href="#UniqueValidator-唯一约束验证" class="headerlink" title="UniqueValidator 唯一约束验证"></a>UniqueValidator 唯一约束验证</h3><p>实例化时的参数:</p>
<ol>
<li>queryset：划定唯一约束的范围</li>
<li>message: 可选, 验证失败时的错误消息</li>
<li>lookup: 可选, 用于限定对queryset中数据的重复性定义, 默认为exact, 即该字段的值准确等于queryset中的某条数据, 视为重复</li>
</ol>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.validators <span class="keyword">import</span> UniqueValidator</span><br><span class="line"></span><br><span class="line">slug = SlugField(</span><br><span class="line">    max_length=<span class="number">100</span>, </span><br><span class="line">    validators=[UniqueValidator(queryset=BlogPost.objects.all())]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="UniqueTogetherValidator-联合唯一约束验证"><a href="#UniqueTogetherValidator-联合唯一约束验证" class="headerlink" title="UniqueTogetherValidator 联合唯一约束验证"></a>UniqueTogetherValidator 联合唯一约束验证</h3><p>实例化时的参数:</p>
<ol>
<li>queryset: 用于验证的查询集</li>
<li>fields: 联合唯一约束的字段列表</li>
<li>message: 可选, 验证失败时的错误消息</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.validators <span class="keyword">import</span> UniqueTogetherValidator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># ToDo items belong to a parent list, and have an ordering defined</span></span><br><span class="line">        <span class="comment"># by the 'position' field. No two items in a given list may share</span></span><br><span class="line">        <span class="comment"># the same position.</span></span><br><span class="line">        validators = [</span><br><span class="line">            UniqueTogetherValidator(</span><br><span class="line">                queryset=ToDoItem.objects.all(), </span><br><span class="line">                fields=(<span class="string">'list'</span>, <span class="string">'position'</span>)</span><br><span class="line">            )</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>注意：UniqueTogetherValidation类始终强制使用隐式约束, 即它所应用的所有字段始终视为required, 可以使用默认值.</p>
<h3 id="UniqueFor-lt-Range-gt-Validator-时段内唯一约束"><a href="#UniqueFor-lt-Range-gt-Validator-时段内唯一约束" class="headerlink" title="UniqueFor&lt;Range&gt;Validator 时段内唯一约束"></a>UniqueFor&lt;Range&gt;Validator 时段内唯一约束</h3><p><code>UniqueForDateValidator</code> 当日唯一约束<br><code>UniqueForMonthValidator</code> 当月唯一约束<br><code>UniqueForYearValidator</code> 当年唯一约束</p>
<p>实例化时的参数</p>
<ol>
<li>queryset： 用于验证的查询集</li>
<li>field： 字段名, 必须为序列化器中的字段</li>
<li>date_field： 用来判读日期的字段, 必须为序列化器中的日期相关字段</li>
<li>message:可选, 验证失败时的错误消息</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.validators <span class="keyword">import</span> UniqueForYearValidator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># Blog posts should have a slug that is unique for the current year.</span></span><br><span class="line">        validators = [</span><br><span class="line">            UniqueForYearValidator(</span><br><span class="line">                queryset=BlogPostItem.objects.all(), </span><br><span class="line">                field=<span class="string">'slug'</span>, </span><br><span class="line">                date_field=<span class="string">'published'</span></span><br><span class="line">            )</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>注意, <code>date_field</code>字段必须在序列化器进行验证逻辑之前传入序列化器.</p>
<p>这意味着如果不打算从前端传入该日期字段, 则需要保证提供的默认值是在序列化器层次, 而非Model层次. 因为在验证时, Model的默认值函数尚未触发.</p>
<p>如果使用的是ModelSerializer, 会自动将Model字段的默认值作为自己对应序列化器字段的默认值, 因此不用出现问题. </p>
<p>而如果是手写的字段, 就必须显式地为其指定默认值, 否则该验证就无法进行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">published = serializers.DateTimeField(required=<span class="literal">True</span>) <span class="comment">#该字段必须被前端传入</span></span><br><span class="line">published = serializers.DateTimeField(read_only=<span class="literal">True</span>, default=timezone.now) <span class="comment">#该字段不允许前端传入, 但提供默认值</span></span><br><span class="line">published = serializers.HiddenField(default=timezone.now) <span class="comment">#该字段可以由前端传入, 也提供默认值</span></span><br></pre></td></tr></table></figure>

<p>总之, 无论是限制前端必须传入该值, 抑或为其提供默认值, 保证的是当前进行验证时, 该字段已被填充.</p>
<hr>
<h3 id="进阶默认值用法"><a href="#进阶默认值用法" class="headerlink" title="进阶默认值用法"></a>进阶默认值用法</h3><p>当我们不希望某个字段由用户传入时, 通常将其设定为只读并指定其默认值, 不过rest-framework提供了专属字段来简化这一流程.</p>
<p><code>CurrentUserDefault</code>: 自动填充当前用户, 在初始化时必须在context参数中传入request才可用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">owner = serializers.HiddenField(</span><br><span class="line">    default=serializers.CurrentUserDefault()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>CreateOnlyDefault</code>: 仅当序列化器进行<strong>创建</strong>(而非更新)行为时, 生成该字段的默认值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">created_at = serializers.DateTimeField(</span><br><span class="line">    read_only=<span class="literal">True</span>, </span><br><span class="line">    default=serializers.CreateOnlyDefault(timezone.now)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="验证器的限制"><a href="#验证器的限制" class="headerlink" title="验证器的限制"></a>验证器的限制</h2><p>在一些情况下, 必须要手写验证器, 而不是使用<code>ModelSerializer</code>自动生成的验证器.</p>
<h3 id="联合唯一约束的某个字段被设置为可选字段-required-False"><a href="#联合唯一约束的某个字段被设置为可选字段-required-False" class="headerlink" title="联合唯一约束的某个字段被设置为可选字段(required=False)"></a>联合唯一约束的某个字段被设置为可选字段(required=False)</h3><p>有的时候确实有这种需求, 而此时默认生成的联合唯一约束验证器的行为是不明确的, 因此必须将其显式排除并酌情考虑是否需要手写一个行为明确的验证器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillingRecordSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># Apply custom validation either here, or in the view.</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        fields = [<span class="string">'client'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>]</span><br><span class="line">        extra_kwargs = &#123;<span class="string">'client'</span>: &#123;<span class="string">'required'</span>: <span class="literal">False</span>&#125;&#125;</span><br><span class="line">        validators = []  <span class="comment"># Remove a default "unique together" constraint.</span></span><br></pre></td></tr></table></figure>

<h3 id="更新嵌套序列化器"><a href="#更新嵌套序列化器" class="headerlink" title="更新嵌套序列化器"></a>更新嵌套序列化器</h3><p>当嵌套序列化器在更新数据记录时, 唯一约束验证会将当前实例(指记录)排除其进行检查的查询集, 因为当前实例在进行序列化器被实例化时是通过<code>instance=...</code>传入的, 因此在序列化器验证时是可以直接访问的, 所以排除当前实例是可以完成的.</p>
<p>而对于嵌套序列化器的更新操作, 实例并不可用, 也就无法排除当前实例.因此, 也需要显式地移除默认生成的验证器, 并酌情考虑是否需要手写一个验证器.</p>
<hr>
<h3 id="在复杂情况下调试"><a href="#在复杂情况下调试" class="headerlink" title="在复杂情况下调试"></a>在复杂情况下调试</h3><p>至少应该使用repr查看自动生成的验证器的具体代码, 如果有必要, 最好不使用ModelSerializer自动生成的验证器, 而是手写验证器, 这样可以让验证行为更加透明. </p>
<hr>
<h2 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h2><hr>
<h3 id="基于函数的验证器"><a href="#基于函数的验证器" class="headerlink" title="基于函数的验证器"></a>基于函数的验证器</h3><p>该函数需要一个参数用以接收字段的值, 并保证在验证失败时抛出一个<code>serializers.ValidationError</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">even_number</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'This field must be an even number.'</span>)</span><br></pre></td></tr></table></figure>

<p>基于函数的验证器也可以通过直接在序列化器中定义<code>validate_&lt;field_name&gt;</code>方法的方式提供.</p>
<hr>
<h3 id="基于类的验证器"><a href="#基于类的验证器" class="headerlink" title="基于类的验证器"></a>基于类的验证器</h3><p>基于类的验证器需要实现<strong>call</strong>方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleOf</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base)</span>:</span></span><br><span class="line">        self.base = base</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value % self.base != <span class="number">0</span>:</span><br><span class="line">            message = <span class="string">'This field must be a multiple of %d.'</span> % self.base</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(message)</span><br></pre></td></tr></table></figure>

<p>使用<code>set_context()</code></p>
<p>进阶情况下, 验证器可能需要传入序列化器字段来进行验证, 可以通过声明<code>set_context()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_context</span><span class="params">(self, serializer_field)</span>:</span></span><br><span class="line">    <span class="comment"># Determine if this is an update or a create operation.</span></span><br><span class="line">    <span class="comment"># In `__call__` we can then use that information to modify the validation behavior.</span></span><br><span class="line">    self.is_update = serializer_field.parent.instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>10.1 序列化器字段:非关系字段 Serializer Field</title>
    <url>/2019/10/03/10.1%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>序列化器字段进行从原始数据到python原生数据类型的转换, 验证输入值, 以及从其对应的Model实例中获取和设置值.</p>
<p>序列化器字段定义在<code>fields.py</code>中, 但为了方便起见, 应该使用<code>from rest_framework import serializers</code> 并用<code>serializers.&lt;FieldName&gt;</code>的形式来使用.</p>
<a id="more"></a>


<hr>
<h3 id="核心参数："><a href="#核心参数：" class="headerlink" title="核心参数："></a>核心参数：</h3><p>任何序列化器字段在构建时至少可以接收以下参数. 一些字段还可以接收额外的参数, 但以下参数所有字段都会接收. </p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>read_only</code></td>
<td>是否只读</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>write_only</code></td>
<td>是否只写</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>required</code></td>
<td>是否需要</td>
<td>Boolean</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>default</code></td>
<td>字段默认值</td>
<td>灵活</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>allow_null</code></td>
<td>是否允许空值</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>source</code></td>
<td>设定本字段数据来源</td>
<td>callable或attribute</td>
<td>本字段</td>
</tr>
<tr>
<td><code>validators</code></td>
<td>指定验证器</td>
<td>list of validator</td>
<td>None</td>
</tr>
<tr>
<td><code>error_message</code></td>
<td>验证出错信息</td>
<td>dict</td>
<td>None</td>
</tr>
<tr>
<td><code>label</code></td>
<td>用于html表格字段的描述</td>
<td>string</td>
<td>None</td>
</tr>
<tr>
<td><code>help_text</code></td>
<td>用于html本字段的帮助文本</td>
<td>string</td>
<td>None</td>
</tr>
<tr>
<td><code>initial</code></td>
<td>用于html本字段的初始值</td>
<td>callable或值</td>
<td>None</td>
</tr>
<tr>
<td><code>style</code></td>
<td>用于html本字段的style参数</td>
<td>dict</td>
<td>None</td>
</tr>
</tbody></table>
<hr>
<p>额外说明:</p>
<h4 id="read-only"><a href="#read-only" class="headerlink" title="read_only"></a><code>read_only</code></h4><p>该参数设为<code>True</code>的字段在<code>create()</code>和<code>update()</code>方法中不会使用</p>
<h4 id="write-only"><a href="#write-only" class="headerlink" title="write_only"></a><code>write_only</code></h4><p>该参数设为<code>True</code>时, 该字段不会被序列化, 但在<code>create()</code>和<code>update()</code>方法中需要该字段</p>
<h4 id="required"><a href="#required" class="headerlink" title="required"></a><code>required</code></h4><p>通常在反序列化过程中, 某个序列化器字段未被传入时, 会抛出错误, 如果某字段该参数设为<code>False</code>时, 则反序列化时没有该参数也不会报错. </p>
<p>设为<code>False</code>还会允许在<strong>序列化过程中</strong>也可以将该字段省略, 如果未传入该字段, 在输出中也就没有该字段. </p>
<h4 id="allow-null"><a href="#allow-null" class="headerlink" title="allow_null"></a><code>allow_null</code></h4><p>该参数设为<code>True</code>时, 允许该字段接收空值(<code>None</code>)作为合法值(序列化和反序列化过程均适用)</p>
<h4 id="default"><a href="#default" class="headerlink" title="default"></a><code>default</code></h4><p>如果该字段未接收到输入的时候, 为其提供一个默认值. </p>
<p>在<strong>部分更新</strong>时, <code>default</code>不会应用, 可指定为某个callable, 在每次使用<code>default</code>时都会进行计算</p>
<p>如果为函数, 该函数不应该接受任何参数. 如果是一个其他callable, 且该callable有<code>set_context</code>方法, 那么会在每次计算前调用, 并将该字段实例作为唯一参数, 与<code>validators</code>的工作方式相同</p>
<p>注意在设置默认值时, 意味着该字段无需被传入, 如果同时设定<code>default</code>和<code>required</code>=<code>True</code>则会报错</p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a><code>source</code></h4><p>用以填充本字段的属性名(通常为与本字段同名的属性, 但可以通过本参数进行额外指定), 可以为某个只接收<code>self</code>参数的方法, 例如<code>URLField(source=&#39;get_absolute_url&#39;)</code>, 或者某个<strong>圆点记法</strong>的属性值, 例如<code>EmailField(source=&#39;user.email&#39;)</code>.</p>
<p>如果设为<code>source</code>=<code>*</code>, 则意味着将正在序列化的整个对象传入该字段. </p>
<h4 id="validators"><a href="#validators" class="headerlink" title="validators"></a><code>validators</code></h4><p>验证器列表, 验证器为一个可以抛出<code>serializers.ValidationError</code>或者Django内置的<code>ValidationError</code>的函数. </p>
<h4 id="error-messages"><a href="#error-messages" class="headerlink" title="error_messages"></a><code>error_messages</code></h4><p>在验证失败后, 返回一个错误信息的字典, 格式为<code>{&#39;field_name&#39;:&#39;error_info&#39;}</code>.</p>
<h4 id="label"><a href="#label" class="headerlink" title="label"></a><code>label</code></h4><p>可能在html表格字段中使用的label标签的值</p>
<h4 id="help-text"><a href="#help-text" class="headerlink" title="help_text"></a><code>help_text</code></h4><p>可能在html表格字段中使用的帮助信息文本</p>
<h4 id="initial"><a href="#initial" class="headerlink" title="initial"></a><code>initial</code></h4><p>可能在html表格字段中使用的预填充值, 可以传入一个<code>callable</code>如同django的表格字段一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    day = serializers.DateField(initial=datetime.date.today)</span><br></pre></td></tr></table></figure>

<h4 id="style"><a href="#style" class="headerlink" title="style"></a><code>style</code></h4><p>可能在html表单字段中使用的内嵌样式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use &lt;input type="password"&gt; for the input.</span></span><br><span class="line">password = serializers.CharField(</span><br><span class="line">    style=&#123;<span class="string">'input_type'</span>: <span class="string">'password'</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a radio input instead of a select input.</span></span><br><span class="line">color_channel = serializers.ChoiceField(</span><br><span class="line">    choices=[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>], </span><br><span class="line">    style=&#123;<span class="string">'base_template'</span>: <span class="string">'radio.html'</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>查看<a href="https://q1mi.github.io/Django-REST-framework-documentation/topics/html-and-forms/" target="_blank" rel="noopener">HTML &amp; Forms</a>文档以获得更多信息. </p>
<hr>
<h2 id="序列化器字段"><a href="#序列化器字段" class="headerlink" title="序列化器字段"></a>序列化器字段</h2><h3 id="布尔型字段"><a href="#布尔型字段" class="headerlink" title="布尔型字段"></a>布尔型字段</h3><h4 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h4><p>布尔型字段, 等同于<code>django.db.models.fields.BooleanField</code></p>
<h4 id="NullBooleanField"><a href="#NullBooleanField" class="headerlink" title="NullBooleanField"></a>NullBooleanField</h4><p>允许空值的布尔型字段, 等同于<code>django.db.models.fields.NullBooleanField</code></p>
<hr>
<h3 id="字符串型字段"><a href="#字符串型字段" class="headerlink" title="字符串型字段"></a>字符串型字段</h3><h4 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h4><p>签名: <code>CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>max_length</code></td>
<td>最大长度</td>
<td>int</td>
<td>无</td>
</tr>
<tr>
<td><code>min_length</code></td>
<td>最小长度</td>
<td>int</td>
<td>无</td>
</tr>
<tr>
<td><code>allow_blank</code></td>
<td>允许空字符串</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>trim_whitespace</code></td>
<td>缩减空格</td>
<td>Boolean</td>
<td><code>True</code></td>
</tr>
</tbody></table>
<h4 id="EmailField"><a href="#EmailField" class="headerlink" title="EmailField"></a>EmailField</h4><p>签名: <code>EmailField(max_length=None, min_length=None, allow_blank=False)</code></p>
<p>自动附加一个邮件地址验证器, 等同于<code>django.db.models.fields.EmailField</code></p>
<h4 id="RegexField"><a href="#RegexField" class="headerlink" title="RegexField"></a>RegexField</h4><p>签名: <code>RegexField(regex, max_length=None, min_length=None, allow_blank=False)</code></p>
<p><code>regex</code>参数为一个代表匹配模式的字符串, 或者python的正则表达式对象</p>
<p>自动附加一个验证字段值是否匹配regex的验证器, 等同于<code>django.core.validators.RegexValidator</code></p>
<h4 id="SlugField"><a href="#SlugField" class="headerlink" title="SlugField"></a>SlugField</h4><p>签名: <code>SlugField(max_length=50, min_length=None, allow_blank=False)</code></p>
<h4 id="URLField"><a href="#URLField" class="headerlink" title="URLField"></a>URLField</h4><p><code>SlugField(max_length=50, min_length=None, allow_blank=False)</code></p>
<h4 id="UUIDField"><a href="#UUIDField" class="headerlink" title="UUIDField"></a>UUIDField</h4><p><code>URLField(max_length=200, min_length=None, allow_blank=False)</code></p>
<h4 id="FilePathField"><a href="#FilePathField" class="headerlink" title="FilePathField"></a>FilePathField</h4><p><code>FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)</code></p>
<h4 id="IPAddressField"><a href="#IPAddressField" class="headerlink" title="IPAddressField"></a>IPAddressField</h4><p><code>IPAddressField(protocol=&#39;both&#39;, unpack_ipv4=False, **options)</code></p>
<p><code>protocol</code>: 指定该地址需符合的协议, <code>ipv4</code>、<code>ipv6</code>或者<code>both</code>(两者均可)<br><code>unpack_ipv4</code>: 解压缩ipv4映射地址, 仅在<code>protocol</code>为<code>both</code>时可用, 默认关闭</p>
<hr>
<h3 id="数字型字段"><a href="#数字型字段" class="headerlink" title="数字型字段"></a>数字型字段</h3><h4 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h4><p><code>IntegerField(max_value=None, min_value=None)</code></p>
<h4 id="FloatField"><a href="#FloatField" class="headerlink" title="FloatField"></a>FloatField</h4><p><code>FloatField(max_value=None, min_value=None)</code></p>
<h4 id="DecimalField"><a href="#DecimalField" class="headerlink" title="DecimalField"></a>DecimalField</h4><p><code>DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)</code></p>
<hr>
<h3 id="时间和日期字段"><a href="#时间和日期字段" class="headerlink" title="时间和日期字段"></a>时间和日期字段</h3><h4 id="DateTimeField"><a href="#DateTimeField" class="headerlink" title="DateTimeField"></a>DateTimeField</h4><p><code>DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)</code></p>
<p><code>format</code>:输出时的格式, 默认为<code>iso-8601</code><br><code>input_formats</code>:输入时的格式列表</p>
<h4 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h4><p><code>DateField(format=api_settings.DATE_FORMAT, input_formats=None)</code></p>
<h4 id="TimeField"><a href="#TimeField" class="headerlink" title="TimeField"></a>TimeField</h4><p><code>TimeField(format=api_settings.TIME_FORMAT, input_formats=None)</code></p>
<h4 id="DurationField"><a href="#DurationField" class="headerlink" title="DurationField"></a>DurationField</h4><p><code>DurationField()</code></p>
<hr>
<h3 id="选择字段"><a href="#选择字段" class="headerlink" title="选择字段"></a>选择字段</h3><h4 id="ChoiceField"><a href="#ChoiceField" class="headerlink" title="ChoiceField"></a>ChoiceField</h4><p>该字段可以接受一个在该字段合法值列表中的值.</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActApplicant</span><span class="params">(Model)</span>:</span></span><br><span class="line">    status_choices = [</span><br><span class="line">        (<span class="number">0</span>, <span class="string">'未通过'</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="string">'已通过'</span>), </span><br><span class="line">        (<span class="number">2</span>, <span class="string">'申请中'</span>)</span><br><span class="line">    ]</span><br><span class="line">    act = ForeignKey(Act, verbose_name=<span class="string">'活动'</span>, on_delete=CASCADE)</span><br><span class="line">    applicant = ForeignKey(Applicant, verbose_name=<span class="string">'申请人'</span>, on_delete=CASCADE)</span><br><span class="line">    apply_time = DateTimeField(<span class="string">'申请时间'</span>)</span><br><span class="line">    status = SmallIntegerField(<span class="string">'申请状态'</span>, choices=status_choices, default=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.act.title</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        unique_together = (<span class="string">'act'</span>, <span class="string">'applicant'</span>)</span><br><span class="line">        verbose_name = verbose_name_plural = <span class="string">'活动申请'</span></span><br></pre></td></tr></table></figure>

<p><code>ChoiceField(choices)</code></p>
<p><code>choices</code>: 该参数需传入一个合法值的列表或者元素为<code>(key, display_name)</code>格式元组的列表</p>
<h4 id="MultipleChoiceField-choices"><a href="#MultipleChoiceField-choices" class="headerlink" title="MultipleChoiceField(choices)"></a>MultipleChoiceField(choices)</h4><p>多选字段</p>
<p><code>MultipleChoiceField(choices)</code></p>
<hr>
<h3 id="文件上传字段"><a href="#文件上传字段" class="headerlink" title="文件上传字段"></a>文件上传字段</h3><h4 id="FileField"><a href="#FileField" class="headerlink" title="FileField"></a>FileField</h4><p><code>FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</code></p>
<p><code>max_length</code>: 文件名最大长度<br><code>allow_empty_file</code>: 是否允许空文件<br><code>use_url</code>: 是否使用url用于输出表示, 默认为<code>UPLOADED_FILES_USE_URL</code>的值, 默认为<code>True</code></p>
<h4 id="ImageField"><a href="#ImageField" class="headerlink" title="ImageField"></a>ImageField</h4><p><code>ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</code></p>
<hr>
<h3 id="组合字段"><a href="#组合字段" class="headerlink" title="组合字段"></a>组合字段</h3><p>组合字段指的是, 该字段中获得的值应该为一个汇集对象, 即其中包含多个元素. 且可以为其中的任意元素的数据格式进行校验. </p>
<h4 id="ListField"><a href="#ListField" class="headerlink" title="ListField"></a>ListField</h4><p><code>ListField(child=&lt;A_FIELD_INSTANCE&gt;, min_length=None, max_length=None)</code></p>
<p>该字段接收的数据类型为一个列表, 可以指定一个<code>child</code>参数, 该参数必须为另一个字段(另一个序列化器也是一个字段)的实例</p>
<p>会验证接收到的列表中的元素都符合参数<code>child</code>所指向的字段形式. </p>
<p>注意, 该字段接受的数据为一个<code>列表</code>. </p>
<h4 id="DictField"><a href="#DictField" class="headerlink" title="DictField"></a>DictField</h4><p><code>DictField(child=&lt;A_FIELD_INSTANCE&gt;, allow_empty=True)</code></p>
<p>同理, 该字段接收的是一个<code>字典</code></p>
<p>参数:</p>
<ol>
<li>child 一个应该用以校验其中单个键值对中的值的field实例, 如果未提供, 则值不会被校验.</li>
<li>allow_empty 是否允许接收一个空字典.</li>
</ol>
<p>例如, 创建一个校验值为字符串类型的字典的字段, 代码可能如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">document = DictField(child=CharField())</span><br></pre></td></tr></table></figure>

<p>或者直接重写DictField类并指定<code>child</code>属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DocumentField(DictField):</span><br><span class="line">    child = CharField()</span><br></pre></td></tr></table></figure>

<h4 id="JSONField"><a href="#JSONField" class="headerlink" title="JSONField"></a>JSONField</h4><p><code>JSONField(binary)</code></p>
<p>该字段接收的是一个<code>JSON</code>结构的数据, 并可以使用<code>child</code>参数来指定验证其数据合理性的字段实例</p>
<hr>
<h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><h4 id="ReadOnlyField"><a href="#ReadOnlyField" class="headerlink" title="ReadOnlyField"></a>ReadOnlyField</h4><p><code>ReadOnlyField()</code></p>
<p>不常用, 简单返回不加修改的数据值</p>
<h4 id="HiddenField"><a href="#HiddenField" class="headerlink" title="HiddenField"></a>HiddenField</h4><p>不接收用户的输入, 而使用default获得数据</p>
<p><code>HiddenField()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modified = serializers.HiddenField(default=timezone.now)</span><br></pre></td></tr></table></figure>

<p>如果需要基于某些预先提供的字段值运行某些验证, 但是不希望将所有这些字段公开给最终用户, 通常需要HiddenField类, </p>
<h4 id="ModelField"><a href="#ModelField" class="headerlink" title="ModelField"></a>ModelField</h4><p><code>ModelField(model_field=&lt;Django ModelField instance&gt;)</code></p>
<p>该字段绑定于一个Django的Model</p>
<h4 id="SerializerMethodField"><a href="#SerializerMethodField" class="headerlink" title="SerializerMethodField"></a>SerializerMethodField</h4><p><code>SerializerMethodField(method_name=None)</code></p>
<p>该字段接受的值为定义在该序列化器中的method的返回值, 使用<code>method_name</code>来指定具体是哪个方法, 如果不指定, 则尝试调用<code>get_&lt;filed_name&gt;</code>方法, 如果该方法不存在则报错. 该方法除了<code>self</code>之外, 仅接受一个参数<code>obj</code>, 即正在被序列化的对象本身. </p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.utils.timezone <span class="keyword">import</span> now</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    days_since_joined = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days_since_joined</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (now() - obj.date_joined).days</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h3><p>创建自定义序列化器字段需要子类化<code>Field</code>并重写以下方法中至少一个:</p>
<p><code>.to_representation()</code><br><code>.to_internal_value()</code></p>
<p>这两者用以进行从初始数据到原生python数据类型, 可序列化数据的转换. 基本数据类型包括数字, 字符串, 布尔型, <code>data</code>/<code>time</code>/<code>datetime</code>或<code>None</code>, 还可以是只包含基本数据类型元素的列表或者字典, 其他的类型可能也被支持, 取决于渲染器.</p>
<p>前者用于从初始数据到基本数据类型, 可序列化的数据的转换.<br>后者用于从原始数据到python内部基本类型的转换. 在校验失败时抛出<code>serializers.ValidationError</code></p>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="基本自定义字段"><a href="#基本自定义字段" class="headerlink" title="基本自定义字段"></a>基本自定义字段</h4><p>定义一个可用于序列化表示RGB颜色值类的字段. Model和Field定义如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A color represented in the RGB colorspace.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, red, green, blue)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span>(red &gt;= <span class="number">0</span> <span class="keyword">and</span> green &gt;= <span class="number">0</span> <span class="keyword">and</span> blue &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">assert</span>(red &lt; <span class="number">256</span> <span class="keyword">and</span> green &lt; <span class="number">256</span> <span class="keyword">and</span> blue &lt; <span class="number">256</span>)</span><br><span class="line">        self.red, self.green, self.blue = red, green, blue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Color objects are serialized into 'rgb(#, #, #)' notation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"rgb(%d, %d, %d)"</span> % (value.red, value.green, value.blue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        data = data.strip(<span class="string">'rgb('</span>).rstrip(<span class="string">')'</span>)</span><br><span class="line">        red, green, blue = [int(col) <span class="keyword">for</span> col <span class="keyword">in</span> data.split(<span class="string">', '</span>)]</span><br><span class="line">        <span class="keyword">return</span> Color(red, green, blue)</span><br></pre></td></tr></table></figure>

<p>默认序列化器字段会映射至Model的<code>同名</code>字段, 如果需要自定义该序列化器字段应该获得Model的非同名字段, 需要重写<code>.get_attribute()</code>和/或<code>.get_value()</code>.</p>
<p>例如, 创建一个字段用以序列化对象的类名:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassNameField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_attribute</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="comment"># We pass the object instance onto `to_representation`, </span></span><br><span class="line">        <span class="comment"># not just the field attribute.</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Serialize the value's class name.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> value.__class__.__name__</span><br></pre></td></tr></table></figure>

<h4 id="抛出验证错误"><a href="#抛出验证错误" class="headerlink" title="抛出验证错误"></a>抛出验证错误</h4><p>以上的ColorField并无进行任何数据验证, 为了宣示数据是否合法, 在<code>.to_internal_value()</code>方法中添加验证逻辑并在校验失败时抛出<code>serializers.ValidationError</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(data, str):</span><br><span class="line">        msg = <span class="string">'Incorrect type. Expected a string, but got %s'</span></span><br><span class="line">        <span class="keyword">raise</span> ValidationError(msg % type(data).__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r'^rgb\([0-9]+, [0-9]+, [0-9]+\)$'</span>, data):</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'Incorrect format. Expected `rgb(#, #, #)`.'</span>)</span><br><span class="line"></span><br><span class="line">    data = data.strip(<span class="string">'rgb('</span>).rstrip(<span class="string">')'</span>)</span><br><span class="line">    red, green, blue = [int(col) <span class="keyword">for</span> col <span class="keyword">in</span> data.split(<span class="string">', '</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> any([col &gt; <span class="number">255</span> <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> (red, green, blue)]):</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'Value out of range. Must be between 0 and 255.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Color(red, green, blue)</span><br></pre></td></tr></table></figure>

<p><code>.fail</code>方法是抛出<code>ValidationError</code>异常的快捷方式, 从<code>error_messages</code>字典中获取信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default_error_messages = &#123;</span><br><span class="line">    <span class="string">'incorrect_type'</span>: <span class="string">'Incorrect type. Expected a string, but got &#123;input_type&#125;'</span>, </span><br><span class="line">    <span class="string">'incorrect_format'</span>: <span class="string">'Incorrect format. Expected `rgb(#, #, #)`.'</span>, </span><br><span class="line">    <span class="string">'out_of_range'</span>: <span class="string">'Value out of range. Must be between 0 and 255.'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(data, str):</span><br><span class="line">        self.fail(<span class="string">'incorrect_type'</span>, input_type=type(data).__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r'^rgb\([0-9]+, [0-9]+, [0-9]+\)$'</span>, data):</span><br><span class="line">        self.fail(<span class="string">'incorrect_format'</span>)</span><br><span class="line"></span><br><span class="line">    data = data.strip(<span class="string">'rgb('</span>).rstrip(<span class="string">')'</span>)</span><br><span class="line">    red, green, blue = [int(col) <span class="keyword">for</span> col <span class="keyword">in</span> data.split(<span class="string">', '</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> any([col &gt; <span class="number">255</span> <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> (red, green, blue)]):</span><br><span class="line">        self.fail(<span class="string">'out_of_range'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Color(red, green, blue)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="使用source-quot-quot"><a href="#使用source-quot-quot" class="headerlink" title="使用source=&quot;*&quot;"></a>使用<code>source=&quot;*&quot;</code></h4><p>在实例化一个字段时, source参数可以为<code>*</code>意味着将整个对象传入该字段, 并在其内部使用该对象. </p>
<p>在自定义字段中可能需要读取不止一个字段的信息用于确定序列化结果, 因此可以使用该参数, 并自定义逻辑.</p>
<p>例如一个坐标模型定义如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataPoint</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    label = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    x_coordinate = models.SmallIntegerField()</span><br><span class="line">    y_coordinate = models.SmallIntegerField()</span><br></pre></td></tr></table></figure>

<p>通过<code>自定义字段</code>和<code>source=&quot;*&quot;</code>, 我们可以使用多个字段的信息来序列化一个字段, 并返回嵌套数据.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoordinateField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        ret = &#123;</span><br><span class="line">            <span class="string">"x"</span>: value.x_coordinate, </span><br><span class="line">            <span class="string">"y"</span>: value.y_coordinate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        ret = &#123;</span><br><span class="line">            <span class="string">"x_coordinate"</span>: data[<span class="string">"x"</span>], </span><br><span class="line">            <span class="string">"y_coordinate"</span>: data[<span class="string">"y"</span>], </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataPointSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    coordinates = CoordinateField(source=<span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = DataPoint</span><br><span class="line">        fields = [<span class="string">'label'</span>, <span class="string">'coordinates'</span>]</span><br></pre></td></tr></table></figure>

<p>以上例子未提供验证处理. </p>
<p>这个例子中的关键点在于:</p>
<ol>
<li><code>to_presentation</code>必须被传递整个数据并从中获取序列化结果.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>instance = DataPoint(label=<span class="string">'Example'</span>, x_coordinate=<span class="number">1</span>, y_coordinate=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer = DataPointSerializer(instance)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer.data</span><br><span class="line">ReturnDict([(<span class="string">'label'</span>, <span class="string">'Example'</span>), (<span class="string">'coordinates'</span>, &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;)])</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>除非该字段被指定为只读, 否则<code>.to_internal_value()</code>必须从原始数据中还原映射关系以用以更新目标对象, 该方法所返回的<code>validated_data</code>用以更新实例对象, 因此该数据必须被拆解为符合原Model字段定义结构的数据.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">"label"</span>: <span class="string">"Second Example"</span>, </span><br><span class="line"><span class="meta">... </span>    <span class="string">"coordinates"</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">"x"</span>: <span class="number">3</span>, </span><br><span class="line"><span class="meta">... </span>        <span class="string">"y"</span>: <span class="number">4</span>, </span><br><span class="line"><span class="meta">... </span>    &#125;</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer = DataPointSerializer(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.is_valid()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.validated_data</span><br><span class="line">OrderedDict([(<span class="string">'label'</span>, <span class="string">'Second Example'</span>), </span><br><span class="line">             (<span class="string">'y_coordinate'</span>, <span class="number">4</span>), </span><br><span class="line">             (<span class="string">'x_coordinate'</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

<p>为了更加完备, 我们尝试使用嵌套序列化器完成相同的功能.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedCoordinateSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    x = serializers.IntegerField(source=<span class="string">'x_coordinate'</span>)</span><br><span class="line">    y = serializers.IntegerField(source=<span class="string">'y_coordinate'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataPointSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    coordinates = NestedCoordinateSerializer(source=<span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = DataPoint</span><br><span class="line">        fields = [<span class="string">'label'</span>, <span class="string">'coordinates'</span>]</span><br></pre></td></tr></table></figure>

<p>我们需要将一个作用于外层序列化器的对象整个传入内层序列化器中, 并由此生成嵌套的序列化结果.</p>
<p>序列化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer = DataPointSerializer(instance)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer.data</span><br><span class="line">ReturnDict([(<span class="string">'label'</span>, <span class="string">'testing'</span>), </span><br><span class="line">            (<span class="string">'coordinates'</span>, OrderedDict([(<span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'y'</span>, <span class="number">2</span>)]))])</span><br></pre></td></tr></table></figure>

<p>反序列化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer = DataPointSerializer(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.is_valid()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.validated_data</span><br><span class="line">OrderedDict([(<span class="string">'label'</span>, <span class="string">'still testing'</span>), </span><br><span class="line">             (<span class="string">'x_coordinate'</span>, <span class="number">3</span>), </span><br><span class="line">             (<span class="string">'y_coordinate'</span>, <span class="number">4</span>)])</span><br></pre></td></tr></table></figure>

<p><em>注: 嵌套序列化器可以简单地反序列化嵌套数据, 只是在进行<code>create</code>和<code>update</code>时需要手写这些方法.</em></p>
<p>优点是自动获得了内建的验证器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_data = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">"label"</span>: <span class="string">"still testing"</span>, </span><br><span class="line"><span class="meta">... </span>    <span class="string">"coordinates"</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">"x"</span>: <span class="string">'a'</span>, </span><br><span class="line"><span class="meta">... </span>        <span class="string">"y"</span>: <span class="string">'b'</span>, </span><br><span class="line"><span class="meta">... </span>    &#125;</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_serializer = DataPointSerializer(data=invalid_data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_serializer.is_valid()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_serializer.errors</span><br><span class="line">ReturnDict([(<span class="string">'coordinates'</span>, </span><br><span class="line">             &#123;<span class="string">'x'</span>: [<span class="string">'A valid integer is required.'</span>], </span><br><span class="line">              <span class="string">'y'</span>: [<span class="string">'A valid integer is required.'</span>]&#125;)])</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ol>
<li>Serializer的<code>to_representation()</code>会调用每个Field的<code>to_representation</code>来完成序列化过程.</li>
<li>Serialzier继承自<code>Field</code>, 是rest_framework.fields中的<code>Field</code>, 并非Django的<code>Field</code></li>
<li>自定义字段相较于使用<code>SerializerMethodField</code>在于可以复用</li>
</ol>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>9.2 序列化器:内置序列化器 Serializer</title>
    <url>/2019/10/03/9.2%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<p>除了基本的<code>Serializer</code>类, rest-framework内置了几种序列化器类, 以供快速构建可用的序列化器, 或提供更基础的序列化器实现.</p>
<a id="more"></a>

<h3 id="ModelSerializer"><a href="#ModelSerializer" class="headerlink" title="ModelSerializer"></a>ModelSerializer</h3><p>ModelSerializer可以指定一个<code>model</code>属性, 指明根据哪个模型自动生成序列化器, 生成的内容包括</p>
<ol>
<li>自动生成与模型相对应的一组字段。</li>
<li>自动生成与模型字段的默认值和约束条件相对应的默认值和验证器.</li>
<li>简单地实现了对应该模型的<code>.create()</code>方法和<code>.update()</code>方法。</li>
</ol>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure>

<p>对于外约束字段, 默认使用<code>PrimaryKeyRelatedField</code>字段.(具体参见下一节<strong>序列化器关系字段</strong>)</p>
<p>注意, 根据Model生成字段时, <strong>不包括</strong>反向关联字段, 因为该字段并没有定义在当前模型中. 如果有需要, 可以手动定义该字段(参见<strong>快速开始</strong>一节).</p>
<p>可以使用<code>repr</code>查看定义该序列化器的实际代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python manage.py shell</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> myapp.serializers <span class="keyword">import</span> AccountSerializer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer = AccountSerializer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(serializer))</span><br><span class="line">AccountSerializer():</span><br><span class="line">    id = IntegerField(label=<span class="string">'ID'</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    name = CharField(allow_blank=<span class="literal">True</span>, max_length=<span class="number">100</span>, required=<span class="literal">False</span>)</span><br><span class="line">    owner = PrimaryKeyRelatedField(queryset=User.objects.all())</span><br></pre></td></tr></table></figure>

<h4 id="指定要包含的字段"><a href="#指定要包含的字段" class="headerlink" title="指定要包含的字段"></a>指定要包含的字段</h4><p>序列化器可能只需要包含模型的部分字段. 可通过以下方式指定:</p>
<ol>
<li>使用内部类<code>Meta</code>的<code>fields</code>属性指定一个字符串列表, 以指明需要包含的Model字段.</li>
<li>使用内部类<code>Meta</code>的<code>exclude</code>属性指定一个字符串列表, 以指明不需要包含的Model字段.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>)</span><br><span class="line">        <span class="comment">#exclude = ('users',)</span></span><br></pre></td></tr></table></figure>

<p> <code>fileds</code>属性可以设定为一个特殊值<code>__all__</code>, 代表包含该模型的所有字段.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = <span class="string">'__all__'</span></span><br></pre></td></tr></table></figure>

<p>注: 必须提供<code>fields</code>或<code>exclude</code>中的一个.</p>
<hr>
<h4 id="包含额外的字段和重写某些字段"><a href="#包含额外的字段和重写某些字段" class="headerlink" title="包含额外的字段和重写某些字段"></a>包含额外的字段和重写某些字段</h4><p>使用ModelSerializer仍然可以添加自定义字段或重写默认的字段，与在Serializer类一样直接声明即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    url = serializers.CharField(source=<span class="string">'get_absolute_url'</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    groups = serializers.PrimaryKeyRelatedField(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="指明只读字段"><a href="#指明只读字段" class="headerlink" title="指明只读字段"></a>指明只读字段</h4><p>在显式定义字段时, 直接传入<code>read_only=True</code>即可将该字段指为只读字段, </p>
<p>但ModelSerializer的模型相关字段是自动生成的, 因此无法直接修改定义字段的代码.</p>
<p>可以通过内部类<code>Meta</code>的<code>read_only_fields</code>属性指明一个字符串列表, 其中包含的所有字段被指定为<strong>只读</strong>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>]</span><br><span class="line">        read_only_fields = [<span class="string">'account_name'</span>]</span><br></pre></td></tr></table></figure>

<p>注: 如果声明一个嵌套序列化器字段并期望其只读, 必须在定义该字段时传入<code>read_only=True</code>, 将该字段包含在<code>read_only_fields</code>列表中无效, 原因不明.</p>
<p>只读字段指的是不允许用户传入的字段, 如果这些字段在存储时是必须的, 通常由内部指定:</p>
<ol>
<li>在存储过程中为<code>.save()</code>方法传入对应于只读字段的额外关键字参数, 参见9.1.</li>
<li>为其指定默认值, 只读字段的默认值在存储时自动被应用.</li>
</ol>
<p>另外, 如果一个只读字段要参与验证, 例如<code>unique_together</code>验证, 则必须为其指定默认值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = serializers.PrimaryKeyRelatedField(read_only=<span class="literal">True</span>, default=serializers.CurrentUserDefault())</span><br></pre></td></tr></table></figure>

<p><code>CurrentUserDefault</code>具体参见<strong>验证器</strong>一节的<strong>进阶默认值使用</strong>部分.</p>
<hr>
<h4 id="添加额外的参数"><a href="#添加额外的参数" class="headerlink" title="添加额外的参数"></a>添加额外的参数</h4><p>如上所述, 为ModelSerializer自动生成的字段进行部分修改较为不方便. </p>
<p>如果需要修改的内容过多, 可以直接重写该字段以覆盖自动生成的字段.</p>
<p>如果仅需要少量修改, 则可以通过内部类<code>Meta</code>的<code>extra_kwargs</code>属性为各个字段添加额外的关键字参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>)</span><br><span class="line">        extra_kwargs = &#123;<span class="string">'password'</span>: &#123;<span class="string">'write_only'</span>: <span class="literal">True</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        user = User(</span><br><span class="line">            email=validated_data[<span class="string">'email'</span>],</span><br><span class="line">            username=validated_data[<span class="string">'username'</span>]</span><br><span class="line">        )</span><br><span class="line">        user.set_password(validated_data[<span class="string">'password'</span>])</span><br><span class="line">        user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="声明嵌套序列化器"><a href="#声明嵌套序列化器" class="headerlink" title="声明嵌套序列化器"></a>声明嵌套序列化器</h4><p>直接通过内部类<code>Meta</code>的<code>depth</code>属性指明需要嵌套的深度, ModelSerializer会自动将所有外键字段替换为与外键模型相对应的ModelSerializer.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>]</span><br><span class="line">        depth = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>使用这种方案生成的内层序列化器, 默认包含该模型的所有字段并且不包含任何额外字段. 如果想要自定义这些内容, 仍需手动嵌套.</p>
<h4 id="关系字段"><a href="#关系字段" class="headerlink" title="关系字段"></a>关系字段</h4><p>对于外键和多对多字段, ModelSerializer默认使用的是<code>PrimaryKeyRelatedField</code>字段.(具体参见下一节<strong>序列化器字段</strong>), 该字段会将外键字段序列化为相关外模型的<strong>主键</strong>(默认id字段)的值.</p>
<p>详情参阅下一节<strong>序列化器关系字段</strong></p>
<hr>
<h3 id="HyperlinkedModelSerializer"><a href="#HyperlinkedModelSerializer" class="headerlink" title="HyperlinkedModelSerializer"></a>HyperlinkedModelSerializer</h3><p>几乎与<code>ModelSerializer</code>一致, 唯一不同之处是对于id和外键的处理.</p>
<p><code>HyperlinkedModelSerializer</code>为对象外键使用的字段是<code>HyperlinkedRelatedField</code>, 序列化结果为指向该外模型对象detail的超链接.</p>
<p>默认不包含自身的id字段, 取而代之的是使用<code>HyperlinkedIdentityField</code>自动生成指向当前对象detial超链接的<code>url</code>字段.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://127.0.0.1:8000/api/books/1/"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Book"</span>,</span><br><span class="line">    <span class="string">"pages"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"country"</span>: <span class="string">"http://127.0.0.1:8000/api/countries/1/"</span>,</span><br><span class="line">    <span class="string">"author"</span>: [</span><br><span class="line">        <span class="string">"http://127.0.0.1:8000/api/persons/1/"</span>,</span><br><span class="line">        <span class="string">"http://127.0.0.1:8000/api/persons/2/"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前, 自身/外模型需要存在detail接口, 也就是说, 此方案需要在打算构建一整套api时使用, 否则一个无效的url只会引起误解.</p>
<p>该url被期望是一个绝对url而非相对url, 因此需要为序列化器传入额外的关键字参数<code>request</code>, 以确保序列化器能使用当前请求信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = AccountSerializer(queryset, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="如何生成超链接"><a href="#如何生成超链接" class="headerlink" title="如何生成超链接"></a>如何生成超链接</h4><p>url需要指向正确的detail接口, 如何确定这个url?</p>
<p>在定义一个<code>HyperlinkedRelatedField</code>字段时, 需要指定以下四个参数</p>
<ol>
<li>view_name 指向的外模型的detail页面的pattern-name</li>
<li>lookup_field 用以传递给detail页面url用以获取对象的字段, 默认为<code>pk</code>, 通常需要与目标pattern中的url变量名一致.</li>
<li>lookup_field_kwargs  期望生成的url中与lookup_field所对应的url关键字变量名, 默认与上一参数保持一致值.</li>
<li>format 如果设定格式后缀, 目标url会附加该后缀.</li>
</ol>
<p>这四个参数作为依据生成指向对象detail页面的url.</p>
<p>示例:</p>
<p>数据模型如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># book/models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">	age = models.IntegerField(default=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">	population = models.IntegerField(default=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">	pages = models.IntegerField(default=<span class="number">100</span>)</span><br><span class="line">	author = models.ManyToManyField(<span class="string">'book.Person'</span>)</span><br><span class="line">	country = models.ForeignKey(<span class="string">'book.Country'</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>

<p>序列化器和视图如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># book/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets, serializers</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model = Book</span><br><span class="line">		fields = <span class="string">"__all__"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountrySerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model = Country</span><br><span class="line">		fields = <span class="string">"__all__"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonSerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model = Person</span><br><span class="line">		fields = <span class="string">"__all__"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">	queryset = Book.objects.all()</span><br><span class="line">	serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">	queryset = Person.objects.all()</span><br><span class="line">	serializer_class = PersonSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountryViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">	queryset = Country.objects.all()</span><br><span class="line">	serializer_class = CountrySerializer</span><br></pre></td></tr></table></figure>

<p>使用路由器注册如下, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># project/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">from</span> book.views <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'books'</span>, BookViewSet)</span><br><span class="line">router.register(<span class="string">r'persons'</span>, PersonViewSet)</span><br><span class="line">router.register(<span class="string">r'countries'</span>, CountryViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'api/'</span>, include(router.urls))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在Router中注册时, 对于任意的viewset, 指定的basename会用以生成url-name(或称pattern-name), 该basename默认为viewset的<code>.querset</code>所指定的Model名.</p>
<p>所以在以上例子中, </p>
<ul>
<li>BookViewSet的base-name为<code>book</code>, 生成的book的接口名为 <code>book-detail</code>和<code>book-list</code></li>
<li>PersonViewSet的base-name为<code>person</code>, 生成的url的pattern-name为<code>person-detail</code>和<code>person-list</code></li>
<li>CountryViewSet的base-name为<code>country</code>, 生成的url的pattern-name为<code>country-detail</code>和<code>country-list</code></li>
</ul>
<p>BookSerializer获取到country和author的外模型名字分别为<code>Country</code>和<code>Person</code>, 生成字段时, 对应字段的<code>view_name</code>参数填充<code>country-detail</code>和<code>person-detail</code>, 然后在序列化过程中, 调用<code>reverse()</code>函数反查真正的url, 然后将外模型对应的<code>pk</code>填入, 获得目标url. </p>
<p><code>url</code>作为生成的超链接的默认字段名, 可以通过<code>URL_FIELD_NAME</code>设置项修改.</p>
<hr>
<h3 id="ListSerializer"><a href="#ListSerializer" class="headerlink" title="ListSerializer"></a>ListSerializer</h3><p>能序列化和一次验证多个对象，通常会作为序列器中的一个字段而不是直接使用作为主序列器。</p>
<p>你通常不需要直接使用ListSerializer，而是应该在实例化一个序列化器时简单地传递一个many=True参数, 实际返回的实例就不是<code>Serializer</code>而是<code>ListSerializer</code>, 后者使用多个对象实例化多个前者, 并将多个前者实例的序列化结果收集至自己的<code>.data</code>属性.</p>
<p>当一个序列化器在带有many=True选项被序列化时，将创建一个ListSerializer实例, 该序列化器类将成为ListSerializer类的子类。</p>
<p>默认多对多约束字段映射的是many=True的PrimaryKeyRelatedField，且allow_empty=True</p>
<hr>
<h4 id="自定义ListSerializer行为"><a href="#自定义ListSerializer行为" class="headerlink" title="自定义ListSerializer行为"></a>自定义ListSerializer行为</h4><p>通常一个ListSerializer会将传入的所有对象进行序列化以及反序列化, 以下情况可能需要自定义<code>ListSerializer</code>行为</p>
<ol>
<li>希望提供列表的特定验证，例如检查一个元素是否与列表中的另外一个元素冲突。</li>
<li>自定义多个对象的创建或更新行为。</li>
</ol>
<p>在一些嵌套序列化器中, 关于一对多, 多对多 外模型的过滤操作依赖于重写ListSerializer.</p>
<p>例如某些内容只是逻辑删除, 实际还存在于数据库中, 所以必须避免这些记录的序列化结果出现在最终的序列化结果中.</p>
<ol>
<li>子类化ListSerializer, 然后在<code>.to_representation()</code>方法中加入过滤逻辑, 根据逻辑决定是否调用<code>super().to_representation()</code></li>
<li>将序列化器的内部类<code>Meta</code>的<code>list_serializer_class</code>属性指向新的ListSerializer</li>
</ol>
<p>注意指定了新ListSerializer之后, 所有many=true的字段均会应用该新ListSerializer, 因此在完成过滤逻辑时应该考虑多个字段.</p>
<h5 id="自定义多个对象的创建"><a href="#自定义多个对象的创建" class="headerlink" title="自定义多个对象的创建"></a>自定义多个对象的创建</h5><p>默认情况下，多个对象的创建默认实现是简单地调用列表中每个对象的.create()方法，如果要自定义实现，那么你需要自定义当被传递many=True参数时使用的ListSerializer类中的.create()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListSerializer</span><span class="params">(serializers.ListSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        books = [Book(**item) <span class="keyword">for</span> item <span class="keyword">in</span> validated_data]</span><br><span class="line">        <span class="keyword">return</span> Book.objects.bulk_create(books)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        list_serializer_class = BookListSerializer</span><br></pre></td></tr></table></figure>

<h5 id="自定义多对象的更新"><a href="#自定义多对象的更新" class="headerlink" title="自定义多对象的更新"></a>自定义多对象的更新</h5><p>默认情况下，ListSerializer类不支持多对象的更新。这是因为插入和删除的预期行为是不明确的。</p>
<p>要支持多对象更新的话你需要自己明确地实现。编写多个对象更新的代码时要注意以下几点：</p>
<ol>
<li>如何确定数据列表中的每个元素应该对应更新哪个实例？</li>
<li>如何处理插入？它们是无效的？还是创建新对象？</li>
<li>移除应该如何处理？它们是要删除对象还是删除关联关系？它们应该被忽略还是提示无效操作？</li>
<li>排序如何处理？改变两个元素的位置是否意味着任何状态改变或者应该被忽视？</li>
<li>你需要向实例序列化器中显式添加一个id字段. 默认隐式生成的id字段是read_only, 这会导致它在更新时被删除.一旦你明确地声明它，它将在列表序列化器的update方法中可用。</li>
</ol>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListSerializer</span><span class="params">(serializers.ListSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        <span class="comment"># Maps for id-&gt;instance and id-&gt;data item.</span></span><br><span class="line">        book_mapping = &#123;book.id: book <span class="keyword">for</span> book <span class="keyword">in</span> instance&#125;</span><br><span class="line">        data_mapping = &#123;item[<span class="string">'id'</span>]: item <span class="keyword">for</span> item <span class="keyword">in</span> validated_data&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Perform creations and updates.</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> book_id, data <span class="keyword">in</span> data_mapping.items():</span><br><span class="line">            book = book_mapping.get(book_id, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> book <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                ret.append(self.child.create(data))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret.append(self.child.update(book, data))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Perform deletions.</span></span><br><span class="line">        <span class="keyword">for</span> book_id, book <span class="keyword">in</span> book_mapping.items():</span><br><span class="line">            <span class="keyword">if</span> book_id <span class="keyword">not</span> <span class="keyword">in</span> data_mapping:</span><br><span class="line">                book.delete()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="comment"># 我们需要使用主键来识别列表中的元素，</span></span><br><span class="line">    <span class="comment"># 所以在这里使用可写的字段，而不是默认的只读字段。</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        list_serializer_class = BookListSerializer</span><br></pre></td></tr></table></figure>

<h5 id="自定义ListSerializer初始化行为"><a href="#自定义ListSerializer初始化行为" class="headerlink" title="自定义ListSerializer初始化行为"></a>自定义ListSerializer初始化行为</h5><p>当一个many=True的序列化器进行初始化时, 我们需要决定哪个参数和关键字参数应该被传入用以实例化单个对象的<code>child</code>Serializer或作为<code>parent</code>的ListSerializer的<code>__init__()</code>方法</p>
<p>默认的行为是<code>validateors</code>以及任何自定义关键字参数只传递给<code>child</code>, 除此之外的所有参数由两个类共有.</p>
<p>有可能需要定义当many=True时子类和父类应当使用那些类, 所以可以重写<code>many_init()</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">many_init</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># Instantiate the child serializer.</span></span><br><span class="line">    kwargs[<span class="string">'child'</span>] = cls()</span><br><span class="line">    <span class="comment"># Instantiate the parent list serializer.</span></span><br><span class="line">    <span class="keyword">return</span> CustomListSerializer(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>注: 该方法最高定义在<code>BaseSerializer</code>中.</p>
<hr>
<h3 id="BaseSerializer"><a href="#BaseSerializer" class="headerlink" title="BaseSerializer"></a>BaseSerializer</h3><p>继承关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializerMetaclass</span><span class="params">(type)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSerializer</span><span class="params">(Field)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListSerializer</span><span class="params">(BaseSerializer)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializer</span><span class="params">(BaseSerializer, metaclass=SerializerMetaclass)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSerializer</span><span class="params">(Serializer)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HyperlinkedModelSerializer</span><span class="params">(ModelSerializer)</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>BaseSerializer</p>
<p>属性&amp;方法</p>
<p><code>.data</code><br><code>.is_valid()</code><br><code>.validated_data</code><br><code>.errors</code><br><code>.save()</code></p>
<p>以及四个可重写的方法, 用以实现额外功能.</p>
<p><code>.to_representation()</code> 序列化主函数.<br><code>.to_internal_value()</code> 反序列化主函数.<br><code>.create()</code> 存储函数.<br><code>.update()</code> 更新函数.</p>
<h4 id="实现只读BaseSerializer"><a href="#实现只读BaseSerializer" class="headerlink" title="实现只读BaseSerializer"></a>实现只读BaseSerializer</h4><p>Model定义如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighScore</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    created = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    player_name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    score = models.IntegerField()</span><br></pre></td></tr></table></figure>

<p>序列化器如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighScoreSerializer</span><span class="params">(serializers.BaseSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'score'</span>: obj.score,</span><br><span class="line">            <span class="string">'player_name'</span>: obj.player_name</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后用其序列化一个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">high_score</span><span class="params">(request, pk)</span>:</span></span><br><span class="line">    instance = HighScore.objects.get(pk=pk)</span><br><span class="line">    serializer = HighScoreSerializer(instance)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>或是序列化多个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_high_scores</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = HighScore.objects.order_by(<span class="string">'-score'</span>)</span><br><span class="line">    serializer = HighScoreSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<h4 id="实现可读可写的BaseSerializer"><a href="#实现可读可写的BaseSerializer" class="headerlink" title="实现可读可写的BaseSerializer"></a>实现可读可写的BaseSerializer</h4><p>那么,我们还必须实现<code>.to_internal_value()</code>方法, 该方法返回经验证的数据用以构建对象实例, 并在验证失败时抛出<code>serializers.ValidationError</code>异常.</p>
<p>一旦实现<code>.to_internal_value()</code>方法, 我们就可以使用<code>is_valid()</code>方法, 以及<code>validated_data</code>和<code>errors</code>属性.</p>
<p>如果还想支持存储操作, 还必须要实现<code>created</code>和<code>update</code>其中之一或两者, 取决于需求.</p>
<p>以下是可读写的HighScoreSerializer, 上一个例子的增强版:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighScoreSerializer</span><span class="params">(serializers.BaseSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        score = data.get(<span class="string">'score'</span>)</span><br><span class="line">        player_name = data.get(<span class="string">'player_name'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Perform the data validation.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> score:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(&#123;</span><br><span class="line">                <span class="string">'score'</span>: <span class="string">'This field is required.'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> player_name:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(&#123;</span><br><span class="line">                <span class="string">'player_name'</span>: <span class="string">'This field is required.'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">if</span> len(player_name) &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(&#123;</span><br><span class="line">                <span class="string">'player_name'</span>: <span class="string">'May not be more than 10 characters.'</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Return the validated values. This will be available as</span></span><br><span class="line">        <span class="comment"># the `.validated_data` property.</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'score'</span>: int(score),</span><br><span class="line">            <span class="string">'player_name'</span>: player_name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'score'</span>: obj.score,</span><br><span class="line">            <span class="string">'player_name'</span>: obj.player_name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HighScore.objects.create(**validated_data)</span><br></pre></td></tr></table></figure>

<h4 id="实现新的基本类"><a href="#实现新的基本类" class="headerlink" title="实现新的基本类"></a>实现新的基本类</h4><p>如果想要实现新的通用序列化器类, 为某些特定的序列化风格或者对某些存储后端进行适配, 继承<code>BaseSerializer</code>并重写其中某些方法.</p>
<p>以下为一个泛型序列化器的例子, 可以将任意复杂类型的对象解构为原始表达(即原生python数据类型).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectSerializer</span><span class="params">(serializers.BaseSerializer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A read-only serializer that coerces arbitrary complex objects</span></span><br><span class="line"><span class="string">    into primitive representations.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        output = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> attribute_name <span class="keyword">in</span> dir(obj):</span><br><span class="line">            attribute = getattr(obj, attribute_name)</span><br><span class="line">            <span class="keyword">if</span> attribute_name.startswith(<span class="string">'_'</span>):</span><br><span class="line">                <span class="comment"># Ignore private attributes.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">elif</span> hasattr(attribute, <span class="string">'__call__'</span>):</span><br><span class="line">                <span class="comment"># Ignore methods and other callables.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">elif</span> isinstance(attribute, (str, int, bool, float, type(<span class="literal">None</span>))):</span><br><span class="line">                <span class="comment"># Primitive types can be passed through unmodified.</span></span><br><span class="line">                output[attribute_name] = attribute</span><br><span class="line">            <span class="keyword">elif</span> isinstance(attribute, list):</span><br><span class="line">                <span class="comment"># Recursively deal with items in lists.</span></span><br><span class="line">                output[attribute_name] = [</span><br><span class="line">                    self.to_representation(item) <span class="keyword">for</span> item <span class="keyword">in</span> attribute</span><br><span class="line">                ]</span><br><span class="line">            <span class="keyword">elif</span> isinstance(attribute, dict):</span><br><span class="line">                <span class="comment"># Recursively deal with items in dictionaries.</span></span><br><span class="line">                output[attribute_name] = &#123;</span><br><span class="line">                    str(key): self.to_representation(value)</span><br><span class="line">                    <span class="keyword">for</span> key, value <span class="keyword">in</span> attribute.items()</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Force anything else to its string representation.</span></span><br><span class="line">                output[attribute_name] = str(attribute)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="进阶序列化器用法"><a href="#进阶序列化器用法" class="headerlink" title="进阶序列化器用法"></a>进阶序列化器用法</h3><h4 id="重写序列化和反序列化行为"><a href="#重写序列化和反序列化行为" class="headerlink" title="重写序列化和反序列化行为"></a>重写序列化和反序列化行为</h4><p>重写<code>.to_representation()</code> 或 <code>.to_internal_value()</code>方法即可更改序列化或反序列化过程</p>
<p><em>这里不得不提一句, 反序列化过程指的是从数据中获得原生python数据类型的<code>validated_data</code>为止.</em><br><em>至于重建对象并存储, 或是使用这些数据更新一个现有实例, 则纯属额外操作, 不能称之为<code>反序列化</code>的一环.</em></p>
<ol>
<li>增加新的行为</li>
<li>更改现有行为</li>
<li>提高某个频繁被访问且返回大量数据的端点的序列化表现.</li>
</ol>
<p>这两个方法的签名如下: </p>
<p><code>.to_representation(self, obj)</code></p>
<p>该方法接收一个实例, 并返回原生的表达式, 通常意味着python基本数据类型, 具体是什么类型可能需要考虑渲染器可以处理何种类型.</p>
<p>(通常就是Dict了.)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">    <span class="string">"""Convert `username` to lowercase."""</span></span><br><span class="line">    ret = super().to_representation(instance)</span><br><span class="line">    ret[<span class="string">'username'</span>] = ret[<span class="string">'username'</span>].lower()</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p><code>.to_internal_value(self, data)</code></p>
<p>接受未经验证的数据类型, 并返回验证过的原生python数据类型的数据.</p>
<p>如果调用<code>save()</code>方法的话, 返回值将被作为<code>validated_data</code>传入<code>.create()</code>和<code>.update()</code>方法中.</p>
<p>如果数据校验失败, 应当抛出<code>serializers.ValidationError(errors)</code>, 并将出错信息存储至<code>.error</code>属性中.</p>
<p>如果想实现对象级别的验证, 请重写<code>.validate()</code>方法.</p>
<p>传入的data通常为<code>request.data</code>, 所以具体的数据类型取决于API使用了何种解析器.</p>
<hr>
<h4 id="Serializer继承"><a href="#Serializer继承" class="headerlink" title="Serializer继承"></a>Serializer继承</h4><p>可以以提供通用方法或字段为目的定义一个序列化器, 然后供其他多个序列化器继承.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseSerializer</span><span class="params">(Serializer)</span>:</span></span><br><span class="line">    my_field = serializers.CharField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_my_field</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySerializer</span><span class="params">(MyBaseSerializer)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>需要注意的点是Meta并不会自动继承, 如果需要, 手动继承.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(MyBaseSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(MyBaseSerializer.Meta)</span>:</span></span><br><span class="line">        model = Account</span><br></pre></td></tr></table></figure>

<p>当然, 继承Meta并不推荐, 绝大多数时候应该显式声明Meta的属性.</p>
<p>注意: </p>
<ol>
<li>如果内部类Meta类继承自多个类，则只使用第一个类</li>
<li>通过在子类上将名称设置为None，可以显式删除从父类继承的Field</li>
</ol>
<hr>
<h4 id="动态改变序列化器字段"><a href="#动态改变序列化器字段" class="headerlink" title="动态改变序列化器字段"></a>动态改变序列化器字段</h4><p>一旦序列化器被实例化，该序列化器的字段字典就可以通过<code>.fields</code>属性来访问, 通过该属性可以动态改变序列化器.</p>
<p>示例代码:指定在初始化一个序列化器时可以指定哪些字段应当被使用的动态字段序列化器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicFieldsModelSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A ModelSerializer that takes an additional `fields` argument that</span></span><br><span class="line"><span class="string">    controls which fields should be displayed.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Don't pass the 'fields' arg up to the superclass</span></span><br><span class="line">        fields = kwargs.pop(<span class="string">'fields'</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Instantiate the superclass normally</span></span><br><span class="line">        super(DynamicFieldsModelSerializer, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fields <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Drop any fields that are not specified in the `fields` argument.</span></span><br><span class="line">            allowed = set(fields)</span><br><span class="line">            existing = set(self.fields.keys())</span><br><span class="line">            <span class="keyword">for</span> field_name <span class="keyword">in</span> existing - allowed:<span class="comment">#(集合减法)</span></span><br><span class="line">                self.fields.pop(field_name)</span><br></pre></td></tr></table></figure>

<p>然后就可以通过传参来控制序列器实例化时使用的字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class UserSerializer(DynamicFieldsModelSerializer):</span><br><span class="line">&gt;&gt;&gt;     class Meta:</span><br><span class="line">&gt;&gt;&gt;         model = User</span><br><span class="line">&gt;&gt;&gt;         fields = (<span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'email'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> UserSerializer(user)</span><br><span class="line">&#123;<span class="string">'id'</span>: 2, <span class="string">'username'</span>: <span class="string">'jonwatts'</span>, <span class="string">'email'</span>: <span class="string">'jon@example.com'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> UserSerializer(user, fields=(<span class="string">'id'</span>, <span class="string">'email'</span>))</span><br><span class="line">&#123;<span class="string">'id'</span>: 2, <span class="string">'email'</span>: <span class="string">'jon@example.com'</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="自定义默认字段"><a href="#自定义默认字段" class="headerlink" title="自定义默认字段"></a>自定义默认字段</h4><p>在2.0+版本中可用.<br>在3.0+版本中, 相关方法不复存在.</p>
<hr>
<h3 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h3><p>…</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>9.1 序列化器:数据验证 Serializer</title>
    <url>/2019/10/03/9.%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<p>序列化器将查询集(queryset)和模型实例(model instances)这样的复杂数据转换为原生python类型，以供渲染成JSON，XML等内容类型, 同时还提供反序列化功能，在验证了传入数据的合理性之后，允许将解析出的数据转换为复杂类型. </p>
<p>rest-framework中的serializers与Django的Form和ModelForm类非常像, Serializer类提供了通用方法来控制响应的输出，ModelSerializer类为创建用于处理模型实例和查询集的序列化程序提供了有用的快捷实现方式. </p>
<a id="more"></a>

<h3 id="声明序列化器"><a href="#声明序列化器" class="headerlink" title="声明序列化器"></a>声明序列化器</h3><p>首先创建一个Model, 以及一个该Model的对象.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email, content, created=None)</span>:</span></span><br><span class="line">        self.email = email</span><br><span class="line">        self.content = content</span><br><span class="line">        self.created = created <span class="keyword">or</span> datetime.now()</span><br><span class="line"></span><br><span class="line">comment = Comment(email=<span class="string">'leila@example.com'</span>, content=<span class="string">'foo bar'</span>)</span><br></pre></td></tr></table></figure>

<p>然后声明一个序列化器, 字段和该Model保持一致, 可以用来序列化和反序列化该对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="将一个对象序列化"><a href="#将一个对象序列化" class="headerlink" title="将一个对象序列化"></a>将一个对象序列化</h3><p>像使用Django的Form类一样使用Serializer.</p>
<p>实例化一个序列化器, 使用<code>instance</code>参数传入想要进行序列化的对象, 并在之后访问<code>.data</code>属性获得序列化结果.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(instance=comment)</span><br><span class="line">serializer.data</span><br><span class="line"><span class="comment"># &#123;'email': 'leila@example.com', 'content': 'foo bar', 'created': '2016-01-27T15:17:10.375877'&#125;</span></span><br></pre></td></tr></table></figure>

<p>序列化结果是原生的python类型, 接下来我们将其渲染为json类型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"></span><br><span class="line">json = JSONRenderer().render(serializer.data)</span><br><span class="line">json</span><br><span class="line"><span class="comment"># b'&#123;"email":"leila@example.com", "content":"foo bar", "created":"2016-01-27T15:17:10.375877"&#125;'</span></span><br></pre></td></tr></table></figure>

<p>当然, 在rest-framework中, 渲染器的选择和渲染过程通常是在视图处理函数返回Response后自动进行的, 我们只需要确保Response中包含的数据是合法的即可. 具体查阅<code>Renderer</code>一节.</p>
<hr>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化过程中, 序列化器接收数据, 在验证其合法性后将其转为python基本数据类型, 并允许将其重新构建为复杂数据类型(即<strong>构造数据类型</strong>, 在python中就是<strong>对象</strong>, 在rest-framework中则通常专指<strong>Model的实例</strong>), 以便进一步操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的json指的是上面代码中生成的json</span></span><br><span class="line">stream = io.BytesIO(json)</span><br><span class="line">data = JSONParser().parse(stream)</span><br></pre></td></tr></table></figure>

<p>在传入数据后, serializer根据自己的字段, 自动验证其数据合法性, 并转换为原生python数据类型, 放入<code>validated_data</code>属性中.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(data=data)</span><br><span class="line">serializer.is_valid()</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">serializer.validated_data</span><br><span class="line"><span class="comment"># &#123;'content': 'foo bar', 'email': 'leila@example.com', 'created': datetime.datetime(2012, 08, 22, 16, 20, 09, 822243)&#125;</span></span><br></pre></td></tr></table></figure>

<p>之后使用<code>validated_data</code>属性进行操作, 例如更新对象的属性, 并存储入数据库.</p>
<hr>
<h3 id="存储实例对象"><a href="#存储实例对象" class="headerlink" title="存储实例对象"></a>存储实例对象</h3><p>为了将数据(<code>validated_data</code>)重构为对象, 我们需要实现create方法或者update方法, 或同时实现两者.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Comment(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        instance.email = validated_data.get(<span class="string">'email'</span>, instance.email)</span><br><span class="line">        instance.content = validated_data.get(<span class="string">'content'</span>, instance.content)</span><br><span class="line">        instance.created = validated_data.get(<span class="string">'created'</span>, instance.created)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>

<p>在实现了以上方法之后, 我们就可以使用serializer.save(), 该方法会自动调用create或update, 重构实例.</p>
<p>如果该实例是Django Model的某个实例, 需要将其保存至数据库, 代码则应该如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Comment.objects.create(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        instance.email = validated_data.get(<span class="string">'email'</span>, instance.email)</span><br><span class="line">        instance.content = validated_data.get(<span class="string">'content'</span>, instance.content)</span><br><span class="line">        instance.created = validated_data.get(<span class="string">'created'</span>, instance.created)</span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>

<p>这样, 当我们使用<code>.save()</code>方法时, 会使用<code>validated_data</code>创建一个Model实例并储存至数据库, 然后返回该实例.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">comment = serializer.save()</span><br></pre></td></tr></table></figure>

<p>调用<code>.save()</code>方法时, 可能创建一个新的实例(<code>create</code>), 或是更新一个现有实例(<code>update</code>), 取决于实例化序列化器时是否传入了一个现有实例(<code>instance</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .save()将会调用.create()创建一个新的实例</span></span><br><span class="line">serializer = CommentSerializer(data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># .save将会调用.update()更新一个现有的Comment实例</span></span><br><span class="line">serializer = CommentSerializer(instance=comment, data=data)</span><br></pre></td></tr></table></figure>

<p><code>create</code>和<code>update</code>的实现都是可选的, 你可以实现其中任意一个, 或者实现两者, 取决于实际需要.</p>
<hr>
<h4 id="为-save-方法传递额外关键字参数"><a href="#为-save-方法传递额外关键字参数" class="headerlink" title="为.save()方法传递额外关键字参数"></a>为<code>.save()</code>方法传递额外关键字参数</h4><p>在调用时可以为<code>.save</code>传递任意关键字参数, 这些关键字参数在保存/更新实例时, 都会被注入到实例中, 作为实例的属性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># view.py</span></span><br><span class="line">serializer.save(owner=request.user)</span><br></pre></td></tr></table></figure>

<p>所有的附加关键字参数将被包含至<code>validated_data</code>中, 在<code>.create()</code>和<code>.update()</code>被调用时使用.</p>
<hr>
<h4 id="直接重写-save"><a href="#直接重写-save" class="headerlink" title="直接重写.save()"></a>直接重写<code>.save()</code></h4><p>有时候, 单独实现create或者update意义不大, 例如我们想要在验证数据合法性之后将其使用email发送, 就应该直接重写<code>.save()</code>方法, 确保表意明确.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactForm</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    message = serializers.CharField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        email = self.validated_data[<span class="string">'email'</span>]</span><br><span class="line">        message = self.validated_data[<span class="string">'message'</span>]</span><br><span class="line">        send_email(<span class="keyword">from</span>=email, message=message)</span><br></pre></td></tr></table></figure>

<p>注意在这种情况下, 直接访问<code>serializer</code>的<code>validated_data</code>属性.</p>
<hr>
<h2 id="验证数据合法性"><a href="#验证数据合法性" class="headerlink" title="验证数据合法性"></a>验证数据合法性</h2><p>在访问<code>validated_data</code>属性或存储一个实例之前, 应该总是调用<code>is_valid</code>方法来验证数据是否合法, 如果验证未通过, <code>.errors</code>属性将会包含一个字典, 描述产生错误的字段和信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(data=&#123;<span class="string">'email'</span>: <span class="string">'foobar'</span>, <span class="string">'content'</span>: <span class="string">'baz'</span>&#125;)</span><br><span class="line">serializer.is_valid()</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">serializer.errors</span><br><span class="line"><span class="comment"># &#123;'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']&#125;</span></span><br></pre></td></tr></table></figure>

<p>字典中的每个键是字段名, 对应的值则是该字段的出错信息. 一个可能存在的特殊键是<code>non_field_errors</code>, 里面会存储一些通用的验证错误(不具体与某个字段相关).</p>
<p>该特殊键的键名可以通过<code>NON_FIELD_ERRORS_KEY</code>设置项进行修改.</p>
<hr>
<h4 id="在数据验证失败时抛出异常"><a href="#在数据验证失败时抛出异常" class="headerlink" title="在数据验证失败时抛出异常"></a>在数据验证失败时抛出异常</h4><p><code>is_valid</code>方法的<code>raise_exception</code>参数为<code>True</code>时, 数据验证失败会抛出<code>serializers.ValidationError</code>异常(而非存储出错信息).</p>
<p>该异常会由REST-framework提供的默认异常处理程序自动处理，默认情况下将返回<code>HTTP 400 Bad Request</code>响应.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="为字段添加自定义验证"><a href="#为字段添加自定义验证" class="headerlink" title="为字段添加自定义验证"></a>为字段添加自定义验证</h4><p>在定义序列化器时, 添加名为<code>.validate_&lt;field_name&gt;</code>的方法, 该方法会自动用于对应字段的数据验证.</p>
<p><code>.validate_&lt;field_name&gt;</code>方法仅接收一个参数<code>value</code>, 即该字段的数据, 返回值为经过验证(或进一步处理)的数据, 或在此之前就抛出<code>serializers.ValidationError</code>异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPostSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = serializers.CharField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_title</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Check that the blog post is about Django.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'django'</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">"Blog post is not about Django"</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>注意, 可选字段(required=False)如果没有获得数据, 该字段的验证也就不会进行.</p>
<hr>
<h4 id="为对象添加自定义验证"><a href="#为对象添加自定义验证" class="headerlink" title="为对象添加自定义验证."></a>为对象添加自定义验证.</h4><p>对象级别的验证, 即针对整个对象的验证, 与任何字段无关, 自定义<code>.validate()</code>方法来进行该验证.</p>
<p><code>validate</code>方法接收一个<code>data</code>参数, 即传入序列化器的所有数据.返回值为经过验证(处理)的数据, 或在此之前就抛出<code>serializers.ValidationError</code>异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    description = serializers.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    start = serializers.DateTimeField()</span><br><span class="line">    finish = serializers.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Check that the start is before the stop.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">'start'</span>] &gt; data[<span class="string">'finish'</span>]:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">"finish must occur after start"</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h4><p>对象级别的验证和字段级别的验证都是通过重写/添加特定方法名的方法在验证流程中调用，除此之外，我们还可以直接定义一个验证器函数，在定义字段时指定.</p>
<p>一些可复用的验证行为应当被写为验证器, 并酌情添加至字段或对象级别, 详情参考<strong>验证器</strong>(Validator)一节.</p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple_of_ten</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value % <span class="number">10</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Not a multiple of ten'</span>)</span><br></pre></td></tr></table></figure>

<p>为字段添加验证器, 在定义字段时添加.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameRecord</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    score = IntegerField(validators=[multiple_of_ten])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>为对象添加验证器, 在Meta属性中添加.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    name = serializers.CharField()</span><br><span class="line">    room_number = serializers.IntegerField(choices=[<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">201</span>])</span><br><span class="line">    date = serializers.DateField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># Each room only has one event per day.</span></span><br><span class="line">        validators = UniqueTogetherValidator(</span><br><span class="line">            queryset=Event.objects.all(), </span><br><span class="line">            fields=[<span class="string">'room_number'</span>, <span class="string">'date'</span>]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>验证器不需要返回初始数据, 仅需要在验证失败时抛出<code>serializers.ValidationError</code>异常. </p>
<p>每个字段/对象可包含多个验证器.</p>
<hr>
<h3 id="访问初始数据和实例"><a href="#访问初始数据和实例" class="headerlink" title="访问初始数据和实例"></a>访问初始数据和实例</h3><p>实例化序列化器之后, 使用<code>.instance</code>属性访问初始传入实例的属性, 使用<code>.initial_data</code>访问未经验证的初始数据. </p>
<hr>
<h3 id="部分更新"><a href="#部分更新" class="headerlink" title="部分更新"></a>部分更新</h3><p>在实例化序列化器时, 需要传入所有必填字段的值, 但在更新实例时仅需要部分字段的值, 此时需要将<code>partial</code>参数设为<code>True</code>来允许仅传入部分字段.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(instance=comment, data=&#123;<span class="string">'content'</span>: <span class="string">u'foo bar'</span>&#125;, partial=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="嵌套序列化器"><a href="#嵌套序列化器" class="headerlink" title="嵌套序列化器"></a>嵌套序列化器</h3><p>如果一个Model的某个字段指向的是另一个模型(例如外键，多对多字段), 则外模型本身也就是一个对象, 而非单纯的原生python数据类型.</p>
<p>如果对应某个外键字段的序列化器字段被指定为(另)一个序列化器，就形成了序列化器的嵌套，该外模型被指定的序列化器进行序列化, 且由此生成的序列化结果也是嵌套的. </p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    username = serializers.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    user = UserSerializer()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<p>示例序列化结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"content"</span>: <span class="string">"some content"</span>, </span><br><span class="line">	<span class="string">"created"</span>: <span class="string">"2019-09-30"</span>, </span><br><span class="line">	<span class="string">"user"</span>: &#123;</span><br><span class="line">		<span class="string">"email"</span>: <span class="string">"example@gmail.com"</span>, </span><br><span class="line">		<span class="string">"username"</span>: <span class="string">"username"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该外键字段允许为空, 则为其添加<code>reuqired=False</code>参数.</p>
<p>如果该外键字段为只读, 则为其添加<code>read_only=True</code>参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    user = UserSerializer(required=<span class="literal">False</span>)  <span class="comment"># 可能是匿名用户. </span></span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<p>如果该字段可能对应多个外模型, 例如一对多, 多对多字段, 则需要添加<code>many=True</code>参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    user = UserSerializer(required=<span class="literal">False</span>)</span><br><span class="line">    edits = EditItemSerializer(many=<span class="literal">True</span>)  <span class="comment"># edit'项的嵌套列表</span></span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="可写的嵌套序列化器"><a href="#可写的嵌套序列化器" class="headerlink" title="可写的嵌套序列化器"></a>可写的嵌套序列化器</h3><p>嵌套序列化器一般不用来进行反序列化, 不过也可以实现这一点. 嵌套序列化器涉及到两个模型, 因此如果涉及到数据库相关操作, 我们需要在重写<code>update</code>和<code>create</code>方法时保存多个对象.</p>
<h4 id="验证数据合法性-1"><a href="#验证数据合法性-1" class="headerlink" title="验证数据合法性"></a>验证数据合法性</h4><p>嵌套的数据在验证合法性时, 如果未通过, 那么其错误信息也会是嵌套结构, 与数据保持一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(data=&#123;<span class="string">'user'</span>: &#123;<span class="string">'email'</span>: <span class="string">'foobar'</span>, <span class="string">'username'</span>: <span class="string">'doe'</span>&#125;, <span class="string">'content'</span>: <span class="string">'baz'</span>&#125;)</span><br><span class="line">serializer.is_valid()</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">serializer.errors</span><br><span class="line"><span class="comment"># &#123;'user': &#123;'email': ['Enter a valid e-mail address.']&#125;, 'created': ['This field is required.']&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用嵌套数据进行create"><a href="#使用嵌套数据进行create" class="headerlink" title="使用嵌套数据进行create"></a>使用嵌套数据进行<code>create</code></h4><p>从嵌套数据中取出(pop)内层的数据, 并分别处理.</p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    profile = ProfileSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = [<span class="string">'username'</span>, <span class="string">'email'</span>, <span class="string">'profile'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        profile_data = validated_data.pop(<span class="string">'profile'</span>)</span><br><span class="line">        user = User.objects.create(**validated_data)</span><br><span class="line">        Profile.objects.create(user=user, **profile_data)</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<h4 id="使用嵌套数据进行update"><a href="#使用嵌套数据进行update" class="headerlink" title="使用嵌套数据进行update"></a>使用嵌套数据进行<code>update</code></h4><p>在更新时处理好关系模型需要慎重考虑, 例如外模型部分的字段可能未提供, 或者为空值, 在这些情况下, 如何更新模型? 可选项:</p>
<ol>
<li>在数据库中将关联字段设置成NULL. </li>
<li>删除关联的实例. </li>
<li>忽略数据并保留这个实例. </li>
<li>抛出验证错误. </li>
</ol>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">   profile_data = validated_data.pop(<span class="string">'profile'</span>)</span><br><span class="line">   <span class="comment"># 当该字段不存在时会抛出DoesNotExist异常, 所以要么保证必须传入该字段, 要么处理该异常.</span></span><br><span class="line">   profile = instance.profile</span><br><span class="line"></span><br><span class="line">   instance.username = validated_data.get(<span class="string">'username'</span>, instance.username)</span><br><span class="line">   instance.email = validated_data.get(<span class="string">'email'</span>, instance.email)</span><br><span class="line">   instance.save()</span><br><span class="line"></span><br><span class="line">   profile.is_premium_member = profile_data.get(</span><br><span class="line">       <span class="string">'is_premium_member'</span>, </span><br><span class="line">       profile.is_premium_member</span><br><span class="line">   )</span><br><span class="line">   profile.has_support_contract = profile_data.get(</span><br><span class="line">       <span class="string">'has_support_contract'</span>, </span><br><span class="line">       profile.has_support_contract</span><br><span class="line">    )</span><br><span class="line">   profile.save()</span><br></pre></td></tr></table></figure>

<p>因为嵌套关系的创建和更新行为可能不明确，并且可能需要关联模型间的复杂依赖关系，REST framework 3 要求始终明确的定义这些方法, 而非依赖于默认行为.</p>
<p>注意: 在<code>ModelSerializer</code>中, 默认不提供对嵌套序列化器的可写支持.</p>
<hr>
<h3 id="处理多个对象"><a href="#处理多个对象" class="headerlink" title="处理多个对象"></a>处理多个对象</h3><p><strong>序列化多个对象</strong></p>
<p>在实例化一个序列化器时, 如果传入的实例是一个查询集而非单个对象, 则需要将<code>many</code>参数置为<code>True</code>, 以便序列化器依次作用于每个对象.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryset = Book.objects.all()</span><br><span class="line">serializer = BookSerializer(instance=queryset, many=<span class="literal">True</span>)</span><br><span class="line">serializer.data</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#     &#123;'id': 0, 'title': 'The electric kool-aid acid test', 'author': 'Tom Wolfe'&#125;, </span></span><br><span class="line"><span class="comment">#     &#123;'id': 1, 'title': 'If this is a man', 'author': 'Primo Levi'&#125;, </span></span><br><span class="line"><span class="comment">#     &#123;'id': 2, 'title': 'The wind-up bird chronicle', 'author': 'Haruki Murakami'&#125;</span></span><br><span class="line"><span class="comment"># ]</span></span><br></pre></td></tr></table></figure>

<h4 id="反序列化多个对象"><a href="#反序列化多个对象" class="headerlink" title="反序列化多个对象"></a>反序列化多个对象</h4><p>反序列化多个对象默认支持多个对象的创建，但是不支持多个对象的更新. 有关如何支持或自定义这些情况的更多信息，请查看<code>ListSerializer</code>部分. </p>
<hr>
<h3 id="额外的上下文"><a href="#额外的上下文" class="headerlink" title="额外的上下文"></a>额外的上下文</h3><p>在某些情况下，除了要序列化的对象之外，还需要为序列化程序提供额外的上下文. 一个常见的情况是，如果使用包含超链接关系字段的序列化器, 需要序列化器能够访问当前的请求以便正确生成完全限定的URL. </p>
<p>你可以在实例化序列化器的时候传递一个context参数来传递任意的附加上下文. 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = AccountSerializer(account, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">serializer.data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	'id': 6, </span></span><br><span class="line"><span class="string">	'owner': u'denvercoder9', </span></span><br><span class="line"><span class="string">	'created': datetime.datetime(2013, 2, 12, 09, 44, 56, 678870), </span></span><br><span class="line"><span class="string">	'details': 'http://example.com/accounts/6/details'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>这个上下文的字典可以在任何序列化器字段的逻辑中使用，例如<code>.to_representation()</code>方法中可以通过访问<code>self.context</code>属性获取上下文字典. </p>
<p>注: 在通用视图中, 自动传递给序列化器上下文中包括了<code>request</code>, <code>format</code>等信息, 因此可以直接使用, 详情查看<strong>通用视图</strong>一节.</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简而言之, 在rest-framework 序列化器的作用: </p>
<ol>
<li>序列化: 接受一个模型实例, 并将其序列化为原生的python数据类型, 例如字典, 以便可以简单地被渲染为json, xml或者其他内容类型.</li>
<li>反序列化: 接受一个json, xml或者其他内容类型的数据, 将其转为python原生数据类型, 以便进行一些相关操作, 例如创建实例并存储进数据库.</li>
</ol>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 渲染器 Renderers</title>
    <url>/2019/10/03/8.%20%E6%B8%B2%E6%9F%93%E5%99%A8/</url>
    <content><![CDATA[<p>处理函数中返回的<code>Response</code>只包含纯粹的数据, 之后在<code>finalize_response</code>中被进一步处理, 并在合适的时机渲染为真正的HTTP响应.</p>
<p>渲染器完成的就是将Response渲染为http响应的任务, 选择合适的渲染器需要根据<strong>内容协商</strong>的结果进行(内容协商主要依据<code>Accept</code>头和URL后缀, 具体参见内容协商一节)</p>
<p>例如, 一个在url中带有<code>.json</code>后缀的请求, 期望得到一个json格式的数据, 所以应该使用<code>JSONRenderer</code>返回纯json数据.</p>
<p>而通过浏览器进行访问时, <code>Accpet</code>头被浏览器自动设置为<code>text/html</code>, rest-framework会选择<code>BrowsableAPIRenderer</code>, 将数据放在<code>rest_framework/api.html</code>模板中进行渲染, 返回一个友好的完整HTML页面.</p>
<hr>
<a id="more"></a>

<h2 id="设置渲染器"><a href="#设置渲染器" class="headerlink" title="设置渲染器"></a>设置渲染器</h2><p>可用的渲染器类应当被设置为一个列表, 且从前向后, 优先级依次递减. rest-framework会根据内容协商结果来判断应当使用哪个渲染器.</p>
<p>全局设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>, </span><br><span class="line">        <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>, </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在视图中通过<code>renderer_classes</code>属性进行设置.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCountView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A view that returns the count of active users in JSON.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    renderer_classes = [JSONRenderer]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        user_count = User.objects.filter(active=<span class="literal">True</span>).count()</span><br><span class="line">        content = &#123;<span class="string">'user_count'</span>: user_count&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure>

<p>在设置渲染器类时, <strong>顺序</strong>是很关键的因素.</p>
<p>例如, 如果API提供JSON响应和适于浏览的API响应，则可能需要将JSONRenderer放在首位，以便向不指定Accept标头的客户端发送JSON响应, 因为这才是常规请求.<br>或者, 如果API提供常规页面和API响应, 那么需要将<code>TemplateHTMLRenderer</code>放在首位, 因为一些旧版本浏览器会发送不当的<code>Accept</code>, 服务端需要避免向其发送JSON数据. </p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h3 id="JSONRenderer"><a href="#JSONRenderer" class="headerlink" title="JSONRenderer"></a>JSONRenderer</h3><p>使用utf-8编码将请求的数据渲染为JSON，默认包括<code>unicode</code>字符，并使用紧凑格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"unicode black star"</span>:<span class="string">"★"</span>, <span class="string">"value"</span>:<span class="number">999</span>&#125;</span><br></pre></td></tr></table></figure>

<p>该渲染器可以接收<code>Accept</code>头的<code>indent</code>参数, 并在结果中响应该缩进请求.</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: application/json; indent=4</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"unicode black star"</span>: <span class="string">"★"</span>, </span><br><span class="line">    <span class="string">"value"</span>: <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>UNICODE_JSON</code>和<code>COMPACT_JSON</code>更改默认JSON编码样式</p>
<p>响应信息:</p>
<p>媒体类型: <strong>application/json</strong><br>格式: <strong>.json</strong><br>编码: <strong>None</strong></p>
<hr>
<h3 id="TemplateHTMLRenderer"><a href="#TemplateHTMLRenderer" class="headerlink" title="TemplateHTMLRenderer"></a>TemplateHTMLRenderer</h3><p>使用Django的标准模板将数据渲染成HTML. 在view中创建Response时需要指定<code>template_name</code>参数, 且传递给Response的数据无需序列化</p>
<p>因为只是将数据内容渲染进模板中, 与常规的Django的render操作相同</p>
<p>模板名称优先级</p>
<ol>
<li>创建Response时指定的<code>template_name</code>参数。</li>
<li>在view中定义的<code>.template_name</code>属性。</li>
<li>调用view.get_template_names()的返回结果。</li>
</ol>
<p>使用示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDetail</span><span class="params">(generics.RetrieveAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回给定用户的模板HTML表示的视图。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    renderer_classes = (TemplateHTMLRenderer, )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        self.object = self.get_object()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'user'</span>: self.object&#125;, template_name=<span class="string">'user_detail.html'</span>)</span><br></pre></td></tr></table></figure>

<p>可以使用TemplateHTMLRenderer来返回使用REST框架的常规HTML页面，或者从单个路径返回HTML和API响应。<br>如果打算构建使用<code>TemplateHTMLRenderer</code>和其他渲染类的网站，应该将<code>TemplateHTMLRenderer</code>列为<code>renderer_classes</code>列表中的第一个类，当接收到不正确格式的ACCEPT头的请求时，会默认使用该渲染器。</p>
<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.html</strong><br>编码: <strong>utf-8</strong></p>
<hr>
<h3 id="StaticHTMLRenderer"><a href="#StaticHTMLRenderer" class="headerlink" title="StaticHTMLRenderer"></a>StaticHTMLRenderer</h3><p>一个简单的渲染器，返回预渲染的HTML, 与其他渲染器不同，传递给Response的数据应该是表示要返回的响应的字符串(这些内容都不会被转义)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(('GET', ))</span></span><br><span class="line"><span class="meta">@renderer_classes((StaticHTMLRenderer, ))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_html_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    data = <span class="string">'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.html</strong><br>编码: <strong>utf-8</strong></p>
<hr>
<h3 id="BrowsableAPIRenderer"><a href="#BrowsableAPIRenderer" class="headerlink" title="BrowsableAPIRenderer"></a>BrowsableAPIRenderer</h3><p>将数据渲染成易于浏览的API界面, rest-framework专属, 开发时相当有用.</p>
<p><img src="https://www.django-rest-framework.org/img/quickstart.png" alt></p>
<p>这个渲染器根据其他渲染器的优先级使用最优先的渲染器，生成api数据，然后使用rest框架提供的模板，将数据渲染为在页面中包含api风格(数据)的响应</p>
<h4 id="自定义BrowsableAPIRenderer"><a href="#自定义BrowsableAPIRenderer" class="headerlink" title="自定义BrowsableAPIRenderer"></a>自定义BrowsableAPIRenderer</h4><p>默认情况下，在使用BrowsableAPIRenderer时, <strong>数据</strong>部分将使用<strong>其他</strong>渲染器中优先级最高的一个进行渲染, 然后再渲染进rest-framework提供的模板.</p>
<p>如果需要自定义此行为，例如使用HTML作为默认返回格式，但在可浏览的API中使用JSON，则可以通过重写get_default_renderer()方法来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomBrowsableAPIRenderer</span><span class="params">(BrowsableAPIRenderer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_default_renderer</span><span class="params">(self, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> JSONRenderer()</span><br></pre></td></tr></table></figure>

<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.api</strong><br>编码: <strong>utf-8</strong><br>模板: <strong>rest_framework/api.html</strong></p>
<hr>
<h3 id="AdminRenderer"><a href="#AdminRenderer" class="headerlink" title="AdminRenderer"></a>AdminRenderer</h3><p>将数据渲染给HTML以进行类似后台管理风格的展示：</p>
<p><img src="https://q1mi.github.io/Django-REST-framework-documentation/img/admin.png" alt></p>
<p>此渲染器适用于CRUD风格的Web API, 还提供用于管理数据的用户友好界面. 不支持嵌套序列器以及列表序列化器，因为html表单无法支持这些类型</p>
<p>注意: 只有当数据中存在正确配置的<code>URL_FIELD_NAME</code>属性(默认为指向detail页面的url)时，AdminRenderer才能够包含指向detail页面的链接。</p>
<p>对于HyperlinkedModelSerializer来说，该属性会被自动设置, 因此不会出现问题. 但是对于ModelSerializer 或者简单的Serializer类，则必须手动设置.</p>
<p>例如，我们使用模型get_absolute_url方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    url = serializers.CharField(source=<span class="string">'get_absolute_url'</span>, read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br></pre></td></tr></table></figure>

<p>这里可能需要进一步描述: 数据的<code>属性</code>, 即对应渲染器中的<code>字段</code>, 因为渲染器会将数据渲染为 <code>{&quot;filed&quot;: &quot;value&quot;}</code></p>
<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.admin</strong><br>编码: <strong>utf-8</strong><br>模板: <strong>rest_framework/admin.html</strong></p>
<hr>
<h3 id="HTMLFormRenderer"><a href="#HTMLFormRenderer" class="headerlink" title="HTMLFormRenderer"></a>HTMLFormRenderer</h3><p>将序列化程序返回的数据渲染为HTML表单。此渲染器的输出不包括封闭的<code>&lt;form&gt;</code>标签，隐藏的CSRF输入或任何提交按钮。</p>
<p>此渲染器不是直接使用，而是可以通过将序列化器实例传递给render_form模板标记来替代模板。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;% load rest_framework %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/submit-report/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;% render_form serializer %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Save"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如需详细了解，查阅 HTML &amp; Forms 文档。</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>form</strong><br>编码: <strong>utf-8</strong><br>模板: <strong>rest_framework/horizontal/form.html</strong></p>
<hr>
<h3 id="MultiPartRenderer"><a href="#MultiPartRenderer" class="headerlink" title="MultiPartRenderer"></a>MultiPartRenderer</h3><p>此渲染器用于渲染HTML multipart表单数据。 它不适合作为响应渲染器，而是用于创建测试请求，使用REST framework的 测试客户端和测试请求工厂。</p>
<p>媒体类型: <strong>multipart/form-data; boundary=BoUnDaRyStRiNg</strong><br>格式: <strong>.multipart</strong><br>编码: <strong>utf-8</strong></p>
<hr>
<h2 id="自定义渲染器"><a href="#自定义渲染器" class="headerlink" title="自定义渲染器"></a>自定义渲染器</h2><p>子类化BaseRenderer，设置<code>.media_type</code>和<code>.format</code>属性，并且实现 <code>.render(self, data, media_type=None, renderer_context=None)</code> 方法, 该方法应当返回一个字节<code>bytestring</code>，它将被用于HTTP响应的主体. </p>
<p>render方法参数解释:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
<th>default</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>视图处理函数所返回数据</td>
<td>无</td>
</tr>
<tr>
<td>media_type</td>
<td>如果提供，应为内容协商阶段确定的所接受的媒体类型。 该类型会优先根据客户端的Accept头来确定，因为Accept头的内容可能比渲染器的media_type属性更具体，例如可能包括媒体类型<strong>参数</strong>, 例如”application/json; nested=true”</td>
<td>None</td>
</tr>
<tr>
<td>renderer_context</td>
<td>如果提供，应当为视图提供的上下文字典，默认会包含如下关键字<code>view</code>, <code>request</code>, <code>response</code>, <code>args</code>, <code>kwargs</code></td>
<td>None</td>
</tr>
</tbody></table>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.encoding <span class="keyword">import</span> smart_unicode</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> renderers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainTextRenderer</span><span class="params">(renderers.BaseRenderer)</span>:</span></span><br><span class="line">    media_type = <span class="string">'text/plain'</span></span><br><span class="line">    format = <span class="string">'txt'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, data, media_type=None, renderer_context=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> data.encode(self.charset)</span><br></pre></td></tr></table></figure>

<h4 id="设定字符集"><a href="#设定字符集" class="headerlink" title="设定字符集"></a>设定字符集</h4><p>默认会使用urf-8编码，如果需要改变，则设置渲染器的<code>charset</code>属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainTextRenderer</span><span class="params">(renderers.BaseRenderer)</span>:</span></span><br><span class="line">    media_type = <span class="string">'text/plain'</span></span><br><span class="line">    format = <span class="string">'txt'</span></span><br><span class="line">    charset = <span class="string">'iso-8859-1'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, data, media_type=None, renderer_context=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> data.encode(self.charset)</span><br></pre></td></tr></table></figure>

<p>注意，如果一个渲染类返回了一个<code>unicode</code>字符串，则响应内容将被<code>Response</code>类强制转换成<code>bytestring</code>，渲染器上的设置的<code>charset</code>属性将用于确定编码。</p>
<p>如果渲染器返回一个<code>bytestring</code>表示原始的二进制内容，则应该设置字符集的值为<code>None</code>，确保响应请求头的<code>Content-Type</code>中不会设置<code>charset</code>值。</p>
<p>在某些情况下你可能还需要将<code>render_style</code>属性设置成<code>&#39;binary&#39;</code>。这么做也将确保可浏览的API不会尝试将二进制内容显示为字符串。</p>
<p><strong>图片渲染器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPEGRenderer</span><span class="params">(renderers.BaseRenderer)</span>:</span></span><br><span class="line">    media_type = <span class="string">'image/jpeg'</span></span><br><span class="line">    format = <span class="string">'jpg'</span></span><br><span class="line">    charset = <span class="literal">None</span></span><br><span class="line">    render_style = <span class="string">'binary'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, data, media_type=None, renderer_context=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="进阶渲染器使用"><a href="#进阶渲染器使用" class="headerlink" title="进阶渲染器使用"></a>进阶渲染器使用</h2><p>使用REST框架来做一些非常灵活的事，例如</p>
<ul>
<li>根据请求的媒体类型，从同一个路径既能提供单独的或者嵌套的表示。</li>
<li>提供常规HTML网页和来自同一路径的基于JSON的API响应。</li>
<li>为API客户端指定要使用的多种类型的HTML表示形式。</li>
<li>未指定渲染器的媒体类型，例如使用<code>media_type = &#39;image/*&#39;</code>，并使用<code>Accept</code>标头来更改响应的编码。</li>
</ul>
<hr>
<h3 id="根据媒体类型的不同行为"><a href="#根据媒体类型的不同行为" class="headerlink" title="根据媒体类型的不同行为"></a>根据媒体类型的不同行为</h3><p>在某些情况下，你可能希望视图根据所接受的媒体类型使用不同的序列化样式. </p>
<p>如果需要实现这个功能, 可以根据 request.accepted_renderer 在运行时确定已选择的渲染器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@api_view(('GET', ))</span></span><br><span class="line"><span class="meta">@renderer_classes((TemplateHTMLRenderer, JSONRenderer))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_users</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一个可以返回系统中用户的JSON或HTML表示的视图。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Users.objects.filter(active=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.accepted_renderer.format == <span class="string">'html'</span>:</span><br><span class="line">        <span class="comment"># TemplateHTMLRenderer 采用一个上下文的字典，</span></span><br><span class="line">        <span class="comment"># 并且额外需要一个 'template_name'。</span></span><br><span class="line">        <span class="comment"># 它不需要序列化。</span></span><br><span class="line">        data = &#123;<span class="string">'users'</span>: queryset&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(data, template_name=<span class="string">'list_users.html'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># JSONRenderer 需要正常的序列化数据。</span></span><br><span class="line">    serializer = UserSerializer(instance=queryset)</span><br><span class="line">    data = serializer.data</span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="不明确的媒体类型"><a href="#不明确的媒体类型" class="headerlink" title="不明确的媒体类型"></a>不明确的媒体类型</h3><p>在某些情况下你可能希望渲染器提供一系列媒体类型。 在这种情况下，你可以通过为 media_type 设置诸如 image/* 或 <em>/</em>这样的值来指定应该响应的媒体类型。</p>
<p>如果你指定了渲染器的媒体类型，你应该确保在返回响应时使用 content_type 属性明确指定媒体类型。 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Response(data, content_type=<span class="string">'image/png'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义媒体类型"><a href="#自定义媒体类型" class="headerlink" title="自定义媒体类型"></a>自定义媒体类型</h3><p>许多Web API的目标，简单的具有超链接的<code>JSON</code>响应可能就已经足够了。如果你想完全拥抱RESTful设计和HATEOAS则需要更详细地考虑媒体类型的设计和使用。</p>
<p>用Roy Fielding的话来说，”REST API 应该花费所有的描述性努力来定义用于表示资源和驱动应用程序状态的媒体类型（们），或者为现有的标准媒体类型定义扩展关系名称和/或超文本启用标记。”。</p>
<p>有关自定义媒体类型的优秀示例，请参阅GitHub关于自定义 application/vnd.github+json 媒体类型的应用以及 Mike Amundsen的IANA认可的 application/vnd.collection+json JSON超媒体。</p>
<hr>
<h3 id="处理渲染异常-amp-HTML错误视图"><a href="#处理渲染异常-amp-HTML错误视图" class="headerlink" title="处理渲染异常&amp;HTML错误视图"></a>处理渲染异常&amp;HTML错误视图</h3><p>通常渲染器都具有相同的行为，无论它处理的是正常的响应还是由异常引起的响应, 如 <code>Http404</code>, <code>PermissionDenied</code>异常, 或者一个<code>APIException</code>的子类。</p>
<p>如果你正在使用 TemplateHTMLRenderer 或 StaticHTMLRenderer 时抛出了异常，行为略有不同。 并且反映 Django对错误视图的默认处理.</p>
<p>由HTML渲染器引发和处理的异常将尝试按照优先顺序使用以下方法之一进行渲染。</p>
<ol>
<li>加载并渲染一个名为 {status_code}.html的模板。</li>
<li>加载并渲染一个名为 api_exception.html的模板。</li>
<li>渲染HTTP状态码和文本，例如 “404 Not Found”。</li>
<li>使用一个包括status_code和details的 RequestContext 渲染。</li>
</ol>
<p>注意: 如果设置<code>DEBUG=True</code>，Django将展示它的标准回溯错误页面而不是渲染HTTP状态码和文本, 所以不会看到以上的HTML错误页面.</p>
<hr>
<h2 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h2><p>YAML<br>XML<br>JSONP<br>MessagePack<br>CSV<br>UltraJSON<br>CamelCase JSON<br>Pandas (CSV, Excel, PNG)<br>LaTeX</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 解析器 Parsers</title>
    <url>/2019/10/03/7.%20%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>resquest携带的数据可能是json格式，可能是一个完整的表单数据, 还可能是xml类型的数据，解析器的工作内容就是从中获取到清洁的数据, 并转换为python原生数据类型放入<code>request.data</code>属性中以供调用.</p>
<p>rest-framework提供了大量内建的解析器, 允许接受多种媒体类型的请求. </p>
<p>在开发客户端应用时, 发送请求时应该包含<code>Content-Type</code>头, 以便后端确定需要使用的解析. 如果未包含该HTTP头, 大多数客户端会将<code>Content-Type</code>设置为<code>application/x-www-form-urlencoded</code>, 可能与实际的内容格式不符.</p>
<p>例如, 在使用<code>ajax</code>发送<code>json</code>格式的数据时, 应该确保包含<code>contentType：&#39;application / json&#39;</code>设置.</p>
<a id="more"></a>

<hr>
<h3 id="设置解析器"><a href="#设置解析器" class="headerlink" title="设置解析器"></a>设置解析器</h3><p>可用的解析器类总是通过一个列表进行设置, 且优先级从前向后递减.</p>
<p>设置全局解析器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settigns.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>, </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用<code>parser_classes</code>属性为视图指定解析器类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A view that can accept POST requests with JSON content.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser_classes = [JSONParser]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'received data'</span>: request.data&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h3 id="JSONParser"><a href="#JSONParser" class="headerlink" title="JSONParser"></a>JSONParser</h3><p>.media_type: application/json</p>
<hr>
<h3 id="FormParser"><a href="#FormParser" class="headerlink" title="FormParser"></a>FormParser</h3><p>.media_type: application/x-www-form-urlencoded</p>
<p>request.data将被填充一个QueryDict的数据。</p>
<p>注: QueryDict 允许一个键对应多个值.</p>
<hr>
<h3 id="MultiPartParser"><a href="#MultiPartParser" class="headerlink" title="MultiPartParser"></a>MultiPartParser</h3><p>.media_type: multipart/form-data</p>
<p>解析 multipart HTML表单内容，支持文件上传. request.data 将被一个 QueryDict填充。</p>
<p>你通常会同时使用FormParser和MultiPartParser两者，以便完全支持HTML表单数据。</p>
<hr>
<h3 id="FileUploadParser"><a href="#FileUploadParser" class="headerlink" title="FileUploadParser"></a>FileUploadParser</h3><p>.media_type: <code>*/*</code></p>
<p>解析<strong>原始</strong>文件上传内容. request.data 属性将是有单个key<code>file</code>的包含上传文件的<code>字典</code>。</p>
<p>如果使用<code>FileUploadParser</code>的请求的url中包含名为<code>filename</code>的关键字参数, 该参数的值将被作为文件名.(参见示例代码)</p>
<p>如果api路径中不包含该关键字, 客户端必须在在<code>Content-Disposition</code>头中设置文件名, 例如 <code>Content-Disposition: attachment; filename=upload.jpg</code></p>
<p>注意: 该解析器仅当客户端将文件流作为原始数据请求时使用, 即请求的body中不包含任何的结构化数据, 而是文件本身(这就是为什么无法直接在body中包含文件名), FileUploadParser也仅仅会将请求的body视为文件本身.</p>
<p>在使用FileUploadParser时, 除了文件本身, 附加信息的传递需要通过请求头或者从url中获取. 理论上来说, 在上传文件方面, 它的效率可能更高.</p>
<p>只有构建一个纯粹的文件上传接口时才需要使用FileUploadParser, 基于web的文件上传都应当使用<code>MultiPartParser</code>.</p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUploadView</span><span class="params">(views.APIView)</span>:</span></span><br><span class="line">    parser_classes = [FileUploadParser]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, filename, format=None)</span>:</span></span><br><span class="line">        file_obj = request.data[<span class="string">'file'</span>]</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># do some stuff with uploaded file</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">return</span> Response(status=<span class="number">204</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    url(<span class="string">r'^upload/(?P&lt;filename&gt;[^/]+)$'</span>, FileUploadView.as_view())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他扩展解析器"><a href="#其他扩展解析器" class="headerlink" title="其他扩展解析器"></a>其他扩展解析器</h3><p>YAMLParser <code>djangorestframework-yaml</code>包提供<br>XMLParser <code>djangorestframework-xml</code>包提供<br>MessagePack <code>djangorestframework-msgpack</code>包提供<br>CamelCase JSON <code>djangorestframework-camel-case</code>包提供</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 路由器 Router</title>
    <url>/2019/10/03/6.%20%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h3><p><code>路由器</code>这个名称似乎存在歧义, 不过翻译为<code>路由</code>似乎也是不合适的, 毕竟是<code>Router</code>而不是<code>Route</code></p>
<p>rest-framework的<code>Router</code>所提供的是自动将一组url映射至特定处理函数的功能, 在上一节viewsets中已有提及.</p>
<a id="more"></a>


<p>简单示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"></span><br><span class="line">router = routers.SimpleRouter()</span><br><span class="line">router.register(<span class="string">r'users'</span>, UserViewSet)</span><br><span class="line">router.register(<span class="string">r'accounts'</span>, AccountViewSet)</span><br><span class="line">urlpatterns = router.urls</span><br></pre></td></tr></table></figure>

<p>实例化一个Router, 调用<code>register</code>方法, 然后将<code>Router.url</code>包含至urlpatterns.</p>
<p>register方法需要至少两个必要参数: </p>
<ul>
<li><code>prefix</code>, 该组路由的前缀.</li>
<li><code>viewset</code>, 改组路由映射的视图集.</li>
</ul>
<p>以及可能可选的参数</p>
<ul>
<li><code>base_name</code> 该组路由的url-name的基础部分, 如果设置了<code>.queryset</code>属性, 则为Model名.如果是通过<code>get_queryset</code>提供视图集, 则必须手动指定该参数.</li>
</ul>
<p>以上Router注册了两个视图集, 生成的 URL patterns 如下</p>
<p>URL pattern: ^users/$ Name: ‘user-list’<br>URL pattern: ^users/{pk}/$ Name: ‘user-detail’<br>URL pattern: ^accounts/$ Name: ‘account-list’<br>URL pattern: ^accounts/{pk}/$ Name: ‘account-detail’</p>
<p>使用<code>include</code>函数, 将生成的路由包含至现存的urlpatterns</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^forgot-password/$'</span>, ForgotPasswordFormView.as_view()), </span><br><span class="line">    url(<span class="string">r'^'</span>, include(router.urls)), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>还可以在使用<code>include</code>的时候添加命名空间(APP命名空间, 实例命名空间均可)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^forgot-password/$'</span>, ForgotPasswordFormView.as_view()), </span><br><span class="line">    url(<span class="string">r'^api/'</span>, include((router.urls, <span class="string">'app_name'</span>))), </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^forgot-password/$'</span>, ForgotPasswordFormView.as_view()), </span><br><span class="line">    url(<span class="string">r'^api/'</span>, include((router.urls, <span class="string">'app_name'</span>), namespace=<span class="string">'instance_name'</span>)), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>查看Django的<a href="https://docs.djangoproject.com/en/stable/topics/http/urls/" target="_blank" rel="noopener">URL namespace docs</a>和<code>include</code><a href="https://docs.djangoproject.com/en/stable/ref/urls/#include" target="_blank" rel="noopener">API reference</a>获得更多细节.</p>
<hr>
<p>注意: 如果使用了命名空间和超链接序列化器, 需要确保<code>view_name</code>参数能正确地反映命名空间. 在以上例子中, 应当为<code>view_name=&#39;app_name:user-detail&#39;</code>以确保超链接关系字段能生成正确的超链接.</p>
<p>注意, view_name的默认值为<code>%(model_name)-detail</code>, 因此, 除非是Model命名冲突, 否则不应该使用命名空间.</p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h3 id="SimpleRouter"><a href="#SimpleRouter" class="headerlink" title="SimpleRouter"></a>SimpleRouter</h3><table border="1">
    <tr><th>URL Style</th><th>HTTP Method</th><th>Action</th><th>URL Name</th></tr>
    <tr><td rowspan="2">{prefix}/</td><td>GET</td><td>list</td><td rowspan="2">{basename}-list</td></tr>
    <tr><td>POST</td><td>create</td></tr>
    <tr><td rowspan="4">{prefix}/{lookup}/</td><td>GET</td><td>retrieve</td><td rowspan="4">{basename}-detail</td></tr>
    <tr><td>PUT</td><td>update</td></tr>
    <tr><td>PATCH</td><td>partial_update</td></tr>
    <tr><td>DELETE</td><td>destroy</td></tr>
    <tr><td>{prefix}/{methodname}/</td><td>GET, 或被`methods`参数声明的方法</td><td>@action(detail=False)装饰的方法</td><td>{basename}-{methodname}</td></tr>
    <tr><td>{prefix}/{lookup}/{methodname}/</td><td>GET, 或被`methods`参数声明的方法</td><td>@action(detail=True)装饰的方法</td><td>{basename}-{methodname}</td></tr>
</table>

<p>默认情况下，由SimpleRouter创建的URL将附加尾部斜杠。 在实例化路由器时，可以通过将trailing_slash参数设置为<code>False</code>来修改此行为, 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">router = SimpleRouter(trailing_slash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>尾部斜杠在Django中是常见的，但是在其他一些框架（如Rails）中默认不使用. 选择使用哪种风格在很大程度上是个人偏好问题，虽然一些javascript框架可能需要一个特定的路由风格。</p>
<p>路由器将匹配包含除斜杠和句点字符以外的任何字符的查找值。对于更严格（或更宽松）的查找模式，请在视图集上设置lookup_value_regex属性。例如，你可以将查找限制为有效的UUID：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModelViewSet</span><span class="params">(mixins.RetrieveModelMixin, viewsets.GenericViewSet)</span>:</span></span><br><span class="line">    lookup_field = <span class="string">'my_model_id'</span></span><br><span class="line">    lookup_value_regex = <span class="string">'[0-9a-f]&#123;32&#125;'</span></span><br></pre></td></tr></table></figure>

<h3 id="DefaultRouter"><a href="#DefaultRouter" class="headerlink" title="DefaultRouter"></a>DefaultRouter</h3><p>与SimpleRouter不同之处有两点:</p>
<ol>
<li>支持可选后缀以确定返回具体的页面形式，是带有html元素的页面，还是纯json</li>
<li>额外生成一个默认返回所有列表视图的超链接的API根视图 api-root</li>
</ol>
<table border="1">
    <tr><th>URL 样式</th><th>HTTP 方法</th><th>动作</th><th>URL 名称</th></tr>
    <tr><td>[.format]</td><td>GET</td><td>automatically generated root view</td><td>api-root</td></tr>
    <tr><td rowspan="2">{prefix}/[.format]</td><td>GET</td><td>list</td><td rowspan="2">{basename}-list</td></tr>
    <tr><td>POST</td><td>create</td></tr>
    <tr><td rowspan="4">{prefix}/{lookup}/[.format]</td><td>GET</td><td>retrieve</td><td rowspan="4">{basename}-detail</td></tr>
    <tr><td>PUT</td><td>update</td></tr>
    <tr><td>PATCH</td><td>partial_update</td></tr>
    <tr><td>DELETE</td><td>destroy</td></tr>
    <tr><td>{prefix}/{methodname}/[.format]</td><td>GET, or as specified by `methods` argument</td><td>`@list_route` decorated method</td><td>{basename}-{methodname}</td></tr>
    <tr><td>{prefix}/{lookup}/{methodname}/[.format]</td><td>GET, or as specified by `methods` argument</td><td>`@detail_route` decorated method</td><td>{basename}-{methodname}</td></tr>
</table>

<p>同样可以使用trailing_slash=False来取消url样式的尾端斜杠:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">router = DefaultRouter(trailing_slash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义Routers"><a href="#自定义Routers" class="headerlink" title="自定义Routers"></a>自定义Routers</h2><p>通常这个并不需要，不过仍然可以给出参数来定义特定要求的API网址，之所以自定义Router而不是直接为其指定url的原因是可以增加复用.</p>
<p>具体可参阅<a href="https://www.django-rest-framework.org/api-guide/routers/#custom-routers" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 视图集 viewsets</title>
    <url>/2019/10/03/5.%20%E8%A7%86%E5%9B%BE%E9%9B%86/</url>
    <content><![CDATA[<p>rest-framework 允许将一组相关逻辑的视图组合在同一个视图类中, 叫做<code>视图集</code>(viewset).</p>
<p>一个视图集是一个单纯的CBV, 只提供<code>行为</code>(action)例如<code>list</code>和<code>create</code>, 不提供任何处理函数(handler)例如<code>get</code>或<code>post</code>.</p>
<p>视图集的处理函数需要通过在as_view()方法中传入映射字典对各个处理函数和行为进行映射.</p>
<p>(注: viewset的as_view()方法已重写, 可以接收一个字典作为参数, 完成行为和处理方法之间的绑定)</p>
<p>当然, 通常我们使用Router对视图集进行注册. </p>
<a id="more"></a>

<p>例如定义一个视图集, 可以列出所有用户, 或取得其中任一个用户的信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404</span><br><span class="line"><span class="keyword">from</span> myapps.serializers <span class="keyword">import</span> UserSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A simple ViewSet for listing or retrieving users.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        queryset = User.objects.all()</span><br><span class="line">        serializer = UserSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        queryset = User.objects.all()</span><br><span class="line">        user = get_object_or_404(queryset, pk=pk)</span><br><span class="line">        serializer = UserSerializer(user)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>该视图集应当如下注册: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'/user/'</span>, UserViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>&#125;), name=<span class="string">'user-list'</span>), </span><br><span class="line">    path(<span class="string">'/user/&lt;pk&gt;'</span>, UserViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'retrieve'</span>&#125;), name=<span class="string">'user-detail'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>对于普通的viewset, 以上的绑定行为是非常模式化的, 所以通常使用<code>Router</code>完成绑定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> myapp.views <span class="keyword">import</span> UserViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"></span><br><span class="line">router = DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'users'</span>, UserViewSet, basename=<span class="string">'user'</span>)</span><br><span class="line">urlpatterns = router.urls</span><br></pre></td></tr></table></figure>

<p>与手动绑定的效果一致, 甚至还支持额外的路由, 详情可查看Router一节.</p>
<p>相较于自己写视图集, 通常使用已有的提供各种action的ModelViewSet更为合算. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset for viewing and editing user instances.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    queryset = User.objects.all()</span><br></pre></td></tr></table></figure>

<p>ViewSet相较于View有两个主要优势:</p>
<ol>
<li>重复的逻辑可以最大程度地复用, 例如上例中, 只需要定义一次queryset, 而在之前的UserViewSet中, 需要在每个方法中获取queryset.</li>
<li>通过使用Router注册, 免去手写 URL conf.</li>
</ol>
<p>当然, 有得有失, 使用ViewSet意味着可以更快地构建API, 并提供相当统一的API格式, 而使用View则可以最大限度且更加清晰地控制视图行为.</p>
<hr>
<h3 id="内省viewset动作"><a href="#内省viewset动作" class="headerlink" title="内省viewset动作"></a>内省viewset动作</h3><p>在dispatch执行过程中, 以下属性可用:</p>
<ol>
<li>basename: 创建url时的 url name.</li>
<li>action 当前执行的action, 例如<code>list</code>, <code>create</code>, 字符串.</li>
<li>detail 当前执行的action是否针对某个具体对象, 还是针对查询集.</li>
<li>suffix 视图集展示的后缀.</li>
<li>name 视图集展示的名字.</li>
<li>description 视图集展示的描述.</li>
</ol>
<p>可以用这些属性来在执行时获取当前信息, 便于执行不同的逻辑.</p>
<p>例如, 动态获取序列化器, 为retrieve行为提供特定的序列化器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewset</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.action == <span class="string">'retrieve'</span>:</span><br><span class="line">			<span class="keyword">return</span> FullAccountSerializer</span><br><span class="line">		<span class="keyword">return</span> BasicAccountSerializer</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="添加额外行为"><a href="#添加额外行为" class="headerlink" title="添加额外行为"></a>添加额外行为</h3><p>为viewset添加额外action, 需要使用<code>@action</code>装饰器, </p>
<p>该装饰器一般需要</p>
<ol>
<li>必要参数<code>detail</code>, 布尔型, 以指明该方法应当作用于单个对象或是查询集.</li>
<li>可选参数 methods, 列表, 指明该额外的行为应当允许何种http method进行访问, 默认值为<code>[&quot;get&quot;]</code></li>
<li>可选参数<code>url_name</code>, 指明该路由所绑定至路由的url name</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status, viewsets</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> myapp.serializers <span class="keyword">import</span> UserSerializer, PasswordSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset that provides the standard actions</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=True, methods=['post'])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        user = self.get_object()</span><br><span class="line">        serializer = PasswordSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            user.set_password(serializer.data[<span class="string">'password'</span>])</span><br><span class="line">            user.save()</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'status'</span>: <span class="string">'password set'</span>&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.errors, </span><br><span class="line">                            status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recent_users</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        recent_users = User.objects.all().order_by(<span class="string">'-last_login'</span>)</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(recent_users)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(recent_users, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p><code>@action</code>还可以包含任意关键字参数, 仅会生效至该路由.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@action(detail=True, methods=['post'], permission_classes=[IsAdminOrIsSelf])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>以上的<code>set_password</code>会在访问<code>users/{pk}/set_password/</code>时被调用, 具体自定义路由的url请查阅<code>Router</code>一节. </p>
<p>注意应用于实例对象的action需要包含<code>pk</code>参数, 而启用后缀协商则需要包含<code>format</code>参数, 或者直接接收任意关键字参数<code>**kwargs</code>.</p>
<p>在程序中查看所有额外行为, 调用<code>.get_extra_actions()</code>方法.</p>
<hr>
<h3 id="为自定义行为根据http-method提供不同行为"><a href="#为自定义行为根据http-method提供不同行为" class="headerlink" title="为自定义行为根据http method提供不同行为"></a>为自定义行为根据http method提供不同行为</h3><p>通常需要在<code>@action</code>中提供包含多个http method的<code>methods</code>参数, 然后在函数体中进行判断</p>
<p>不过更好的选择是使用额外路由对象自带的合并功能, 将多个自定义行为合并, 共用同一个路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@action(detail=True, methods=['put'], name='Change Password')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">    <span class="string">"""Update the user's password."""</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@password.mapping.delete</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">    <span class="string">"""Delete the user's password."""</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>以上代码, 可以对<code>users/{pk}/password/</code>使用<code>PUT</code>和<code>DELETE</code>, 会分别执行password行为和delete_password行为.</p>
<hr>
<h3 id="反查action的路由"><a href="#反查action的路由" class="headerlink" title="反查action的路由"></a>反查action的路由</h3><p>在运行时获得某个行为所对应的路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>view.reverse_action(<span class="string">'set-password'</span>, args=[<span class="string">'1'</span>])</span><br><span class="line"><span class="string">'http://localhost:8000/api/users/1/set_password'</span></span><br></pre></td></tr></table></figure>

<p>或是在使用<code>@action</code>时传入了<code>url_name</code>参数的话, 可以通过该属性进行反查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>view.reverse_action(view.set_password.url_name, args=[<span class="string">'1'</span>])</span><br><span class="line"><span class="string">'http://localhost:8000/api/users/1/set_password'</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><h3 id="ViewSet"><a href="#ViewSet" class="headerlink" title="ViewSet"></a>ViewSet</h3><p>ViewSet继承自APIView, 本身并不提供任何的操作和处理方法，所以如果直接子类化ViewSet类，需要自己实现<code>action</code>，并完成请求方法和处理方法的绑定. </p>
<h3 id="GenericViewSet"><a href="#GenericViewSet" class="headerlink" title="GenericViewSet"></a>GenericViewSet</h3><p>通用视图集继承自通用视图 <code>GenericViewSet</code>, 提供了<code>get_object</code>, <code>get_queryset</code>等方法和通用视图的基本行为, 但并不包含任何<code>行为</code>, 与通用视图的设计理念类似, 需要通过<code>混入</code>混合类来提供行为, 并组合成为可用的视图集.</p>
<h3 id="ModelViewSet"><a href="#ModelViewSet" class="headerlink" title="ModelViewSet"></a>ModelViewSet</h3><p>由通用视图集GenericViewSet 混入<code>所有</code>的混合类而形成的视图集. ModelViewSet 最低仅需给出查询集和序列化器就可以自动构建出一套完整的包含所有行为的视图集.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A simple ViewSet for viewing and editing accounts.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Account.objects.all()</span><br><span class="line">    serializer_class = AccountSerializer</span><br><span class="line">    permission_classes = [IsAccountAdminOrReadOnly]</span><br></pre></td></tr></table></figure>

<p>所支持的行为包括 <code>retrieve</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>partial_update</code>, <code>destory</code> 行为, 使用Router类注册即可直接进行访问.</p>
<h3 id="ReadOnlyModelViewSet"><a href="#ReadOnlyModelViewSet" class="headerlink" title="ReadOnlyModelViewSet"></a>ReadOnlyModelViewSet</h3><p>由通用视图集GenericViewSet混合<code>mixins.ListModelMixin</code>和<code>mixins.RetrieveModelMixin</code>实现的视图集, 仅支持<code>list</code>和<code>retrieve</code>行为, 即<code>只读</code>行为.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountViewSet</span><span class="params">(viewsets.ReadOnlyModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A simple ViewSet for viewing accounts.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Account.objects.all()</span><br><span class="line">    serializer_class = AccountSerializer</span><br></pre></td></tr></table></figure>

<h3 id="自定义视图集"><a href="#自定义视图集" class="headerlink" title="自定义视图集"></a>自定义视图集</h3><p>使用通用视图集GenericViewSet提供基本架构, 并混入所需的混合类, 即可迅速构建自定义视图集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixins</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateListRetrieveViewSet</span><span class="params">(mixins.CreateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                                mixins.ListModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                                mixins.RetrieveModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                                viewsets.GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset that provides `retrieve`, `create`, and `list` actions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To use it, override the class and set the `.queryset` and</span></span><br><span class="line"><span class="string">    `.serializer_class` attributes.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 通用视图 Generic views</title>
    <url>/2019/10/03/4.%20%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>API的构建总是与Model打交道,所以如何抽象与之相关的重复代码是设计rest-framework的重中之重.</p>
<p>CBV最大的好处在于可以组合一些可复用的行为.例如常用的<code>混入</code>(Mixin)就是极佳的设计思路.</p>
<p>rest-framework提供了很多预置的view用以提供常规功能. </p>
<p>当然也可以使用最基本的APIView, 或是使用genericView以及<code>混入</code>(mixins)来进行组合.</p>
<a id="more"></a>

<p>示例: </p>
<p>通常在使用通用视图的时候,需要重写一些属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django`.contrib.auth.models`<span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> myapp`.serializers`<span class="keyword">import</span> UserSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> generics</span><br><span class="line"><span class="keyword">from</span> rest_framework`.permissions`<span class="keyword">import</span> IsAdminUser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    permission_classes = [IsAdminUser]</span><br></pre></td></tr></table></figure>

<p>或者在复杂的情况下,需要重写一些<code>方法</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    permission_classes = (IsAdminUser, )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># Note the use of `get_queryset()` instead of `self.queryset`</span></span><br><span class="line">        queryset = self.get_queryset()</span><br><span class="line">        serializer = UserSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>而对于最简单的一些情况,直接在<code>.as_view</code>方法中添加参数即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r'^/users/'</span>, </span><br><span class="line">	ListCreateAPIView.as_view(</span><br><span class="line">		queryset=User`.objects.all(),`</span><br><span class="line">		serializer_class=UserSerializer</span><br><span class="line">		), </span><br><span class="line">	name=<span class="string">'user-list'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>API参考</p>
<p><code>GenericAPIView</code> 继承自APIView, 提供了list的detil的基本行为前提: 获得查询集和获得某一个对象</p>
<p>属性</p>
<ul>
<li><code>.queryset</code> 用于从视图返回对象的查询结果集, 设置此属性或者重写get_queryset()来取得结果集。结果会<code>缓存</code>, 以供后续请求的调用。</li>
<li><code>.serializer_class</code> 用于验证和反序列化输入以及序列化输出的Serializer类, 设置此属性或者重写get_serializer_class()方法</li>
<li><code>.lookup_field</code> 用于执行各个model实例的对象查找时使用的字段, 默认是’pk’, 如果使用超链接api的时候, 需要改动这一项, 必须在api视图和序列化类都设置查找字段</li>
<li><code>.lookup_url_kwarg</code> 应用对象查找的url关键字参数, 默认情况下使用与lookup_field相同的值</li>
<li><code>.pagination_class</code> 指定分页类, 默认为settings中的DEFAULT_PAGINATION_CLASS, 该项的默认值为rest_framework.pagination.PageNumberPagination</li>
<li><code>.filter_backends</code> 用于过滤查询集的过滤器后端类的列表。默认值取决于DEFAULT_FILTER_BACKENDS设置项.</li>
</ul>
<p>方法</p>
<ul>
<li><code>.get_queryset(self)</code> 获得查询集.</li>
<li><code>.get_object(self)</code> 获得实例对象(指某条记录构建的Model实例).</li>
<li><code>.get_serializer_class(self)</code> 获得用于序列化的类.</li>
<li><code>.filter_queryset(self,</code>queryset) 进行过滤操作.</li>
</ul>
<p>其他钩子函数:</p>
<p>以下钩子函数由相应的混入类提供, 并可以简单地重写以改变保存或删除时地行为.</p>
<p><code>perform_create(self, serializer)</code> 在创建一个新的对象之前被<code>CreateModelMixin</code>调用<br><code>perform_update(self, serializer)</code> 在更新一个已存对象之前由<code>UpdateModelMixin</code>调用<br><code>perform_destroy(self, instance)</code> 在删除一个现存对象之前由<code>DestroyModelMixin</code>调用</p>
<p>其他方法</p>
<ul>
<li><code>get_serializer_context(self)</code> 获取为序列化器提供的上下文,返回值须为Dict类型.默认<code>已包含&#39;request&#39;</code>,’view’和’format’.</li>
<li><code>get_serializer(self, instance=None, data=None, many=False, partial=False)</code> 获取已被传入数据的序列化器实例.</li>
<li><code>get_paginated_response(self, data)</code> 获得应用分页风格后的Response实例.</li>
<li><code>paginate_queryset(self, queryset)</code> 将查询集进行分页,返回一个分页对象或是在无分页器时返回None.</li>
<li><code>filter_queryset(self, queryset)</code> 需求一个查询集,并返回一个新的过滤后的查询集.</li>
</ul>
<p>建立一个API的两个基本要素为<code>查询集</code>和<code>序列化器</code>,因此在以上属性或方法中</p>
<ol>
<li>必须设置<code>.queryset</code>属性或重写<code>get_queryset</code>来给定<code>查询集</code></li>
<li>必须设置<code>serializer_class</code>属性或重写<code>get_serializer_class</code>来给定<code>序列化器</code></li>
</ol>
<p>其他所有的属性和方法因为已有默认值或默认实现,因此都是可选的.</p>
<p>示例代码:</p>
<p>通过重写<code>get_queryset</code>获得查询集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">    user = self.request.user</span><br><span class="line">    <span class="keyword">return</span> user.accounts.all()</span><br></pre></td></tr></table></figure>

<p>通过重写<code>get_object</code>获得某个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self)</span>:</span></span><br><span class="line">    queryset = self.get_queryset()</span><br><span class="line">    filter = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> self.multiple_lookup_fields:</span><br><span class="line">        filter[field] = self.kwargs[field]</span><br><span class="line"></span><br><span class="line">    obj = get_object_or_404(queryset, **filter)</span><br><span class="line">    self.check_object_permissions(self.request, obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>重写<code>filter_queryset</code>过滤查询集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_queryset</span><span class="params">(self, queryset)</span>:</span></span><br><span class="line">    filter_backends = [CategoryFilter]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'geo_route'</span> <span class="keyword">in</span> self.request.query_params:</span><br><span class="line">        filter_backends = [GeoRouteFilter, CategoryFilter]</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'geo_point'</span> <span class="keyword">in</span> self.request.query_params:</span><br><span class="line">        filter_backends = [GeoPointFilter, CategoryFilter]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> list(filter_backends):</span><br><span class="line">        queryset = backend().filter_queryset(self.request, queryset, view=self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queryset</span><br></pre></td></tr></table></figure>

<p>重写<code>get_serializer_class</code>为不同状态的请求动态提供序列化器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">        <span class="keyword">return</span> FullAccountSerializer</span><br><span class="line">    <span class="keyword">return</span> BasicAccountSerializer</span><br></pre></td></tr></table></figure>

<p>使用钩子函数,在创建一条记录前为其添加属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    serializer.save(user=self.request.user)</span><br></pre></td></tr></table></figure>

<p>使用钩子函数,在创建一条记录后进行邮件通知</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_update</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    instance = serializer.save()</span><br><span class="line">    send_email_confirmation(user=self.request.user, modified=instance)</span><br></pre></td></tr></table></figure>

<p>使用钩子函数,为其进行额外的数据合法性检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    queryset = SignupRequest.objects.filter(user=self.request.user)</span><br><span class="line">    <span class="keyword">if</span> queryset.exists():</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'You have already signed up'</span>)</span><br><span class="line">    serializer.save(user=self.request.user)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="混入-Mixins"><a href="#混入-Mixins" class="headerlink" title="混入(Mixins)"></a>混入(Mixins)</h2><p>GenericAPIView无法被作为视图类直接使用,因为它没有实现任何与HTTP METHOD同名的处理函数, 例如<code>get</code>或是<code>post</code>等,因此GenericAPIView不能处理任何请求.</p>
<p>GenericAPIView仅仅是提供了基本架构, 以及获取数据的接口,而如何将获取的查询集或是对象转为响应,这些<code>行为</code>都由以下的混入类完成.</p>
<p>(导出路径均为<code>rest_framework.mixins</code>)</p>
<ul>
<li><code>ListModelMixin</code> 提供 <code>list</code>行为,可以将查询集列出.</li>
<li><code>CreateModelMixin</code> 提供<code>create</code>行为, 可以创建一个新的model实例。</li>
<li><code>etrieveModelMixin</code> 提供<code>retrieve</code>行为, 可以取回一个现有的model实例。</li>
<li><code>UpdateModelMixin</code> 提供 <code>.update</code>和<code>partial_update</code>行为, 可以更新/部分更新现有模型实例</li>
<li><code>DestroyModelMixin</code> 提供一个 <code>.destroy</code>行为, 可以删除现有模型实例。</li>
</ul>
<p>当我们谈<code>行为</code>(action)的时候,指的是:<code>list</code> <code>detail</code> <code>update</code> <code>retrieve</code> <code>destory</code>这些对数据的操作,而非<code>get</code>,<code>post</code>, <code>update</code>这些真正执行的<code>视图函数</code>, 这些视图函数当然会调用这些已实现的行为,但不能将他们混为一谈.</p>
<p>使用多重继承的方式来构建我们的视图函数,首先根据需求酌情继承混入类, 最后继承GenericAPIView</p>
<p>示例代码: 实现一个列出数据的视图类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixins</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListAPIView</span><span class="params">(mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  GenericAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Concrete view for listing a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>或者一个能读取,修改,删除实例的视图类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetrieveUpdateDestroyAPIView</span><span class="params">(mixins.RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                   mixins.UpdateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                   mixins.DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                   GenericAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Concrete view for retrieving, updating or deleting a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">patch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.partial_update(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.destroy(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>以GenericAPIView提供基本架构,以混入类提供<code>行为</code>,并在处理方法调用<code>行为</code>,就形成了可用的视图类.</p>
<hr>
<p>已混合的类(Mixined)</p>
<p>以下类都是根据常用需求,按照以上思路混合好的一些类,这些类都能作为视图类,只要设定好查询集和序列化器就可以直接投入使用.</p>
<table>
<thead>
<tr>
<th>Mixined</th>
<th>inherit from</th>
<th>method</th>
</tr>
</thead>
<tbody><tr>
<td>CreateAPIView</td>
<td>GenericAPIView, CreateModelMixin</td>
<td>post</td>
</tr>
<tr>
<td>ListAPIView</td>
<td>GenericAPIView, ListModelMixin</td>
<td>get</td>
</tr>
<tr>
<td>RetrieveAPIView</td>
<td>GenericAPIView, RetrieveModelMixin</td>
<td>get</td>
</tr>
<tr>
<td>DestroyAPIView</td>
<td>GenericAPIView, DestroyModelMixin</td>
<td>delete</td>
</tr>
<tr>
<td>UpdateAPIView</td>
<td>GenericAPIView, UpdateModelMixin</td>
<td>update</td>
</tr>
<tr>
<td>ListCreateAPIView</td>
<td>GenericAPIView, ListModelMixin, CreateModelMixin</td>
<td>get,post</td>
</tr>
<tr>
<td>RetrieveUpdateAPIView</td>
<td>GenericAPIView, RetrieveModelMixin, UpdateModelMixin</td>
<td>get, put,patch</td>
</tr>
<tr>
<td>RetrieveDestroyAPIView</td>
<td>GenericAPIView, RetrieveModelMixin, DestroyModelMixin</td>
<td>get, delete</td>
</tr>
<tr>
<td>RetrieveUpdateDestroyAPIView</td>
<td>GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin</td>
<td>get,put, patch,delete</td>
</tr>
</tbody></table>
<hr>
<h2 id="自定义通用视图"><a href="#自定义通用视图" class="headerlink" title="自定义通用视图"></a>自定义通用视图</h2><p>通常情况下, 应该使用现有通用视图并自定义某些行为. 当然, 如果想要对多个视图作出更改并重用某些行为, 有必要直接重写通用视图.</p>
<h4 id="创建自定义混合类"><a href="#创建自定义混合类" class="headerlink" title="创建自定义混合类"></a>创建自定义混合类</h4><p>例如, 如果想要基于url中多个字段来查找数据对象, 可以创建如下混合类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleFieldLookupMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Apply this mixin to any view or viewset to get multiple field filtering</span></span><br><span class="line"><span class="string">    based on a `lookup_fields` attribute, instead of the default single field filtering.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self)</span>:</span></span><br><span class="line">        queryset = self.get_queryset()             <span class="comment"># Get the base queryset</span></span><br><span class="line">        queryset = self.filter_queryset(queryset)  <span class="comment"># Apply any filter backends</span></span><br><span class="line">        filter = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> self.lookup_fields:</span><br><span class="line">            <span class="keyword">if</span> self.kwargs[field]: <span class="comment"># Ignore empty fields.</span></span><br><span class="line">                filter[field] = self.kwargs[field]</span><br><span class="line">        obj = get_object_or_404(queryset, **filter)  <span class="comment"># Lookup the object</span></span><br><span class="line">        self.check_object_permissions(self.request, obj)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>然后可以简单地将该混合类混入视图中来应用自定义行为.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetrieveUserView</span><span class="params">(MultipleFieldLookupMixin, generics.RetrieveAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    lookup_fields = [<span class="string">'account'</span>, <span class="string">'username'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="创建自定义通用视图基类"><a href="#创建自定义通用视图基类" class="headerlink" title="创建自定义通用视图基类"></a>创建自定义通用视图基类</h4><p>如果需要在多个视图函数中混入该类, 则可以更进一步, 直接将该类与现有混合类创建新的基本视图, 并在整个项目中使用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRetrieveView</span><span class="params">(MultipleFieldLookupMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                       generics.RetrieveAPIView)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRetrieveUpdateDestroyView</span><span class="params">(MultipleFieldLookupMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                    generics.RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 基于类的视图 Class-based Views</title>
    <url>/2019/10/03/3.%20%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%A7%86%E5%9B%BE%20Class-based%20Views/</url>
    <content><![CDATA[<h3 id="基于类的视图"><a href="#基于类的视图" class="headerlink" title="基于类的视图"></a>基于类的视图</h3><p>基于类的视图具有很多的优点,因此是推荐使用的不二选择.</p>
<p>rest-framework的<code>APIView</code>类继承自Django的<code>View</code>类, 它与View的不同之处包括如下几点:</p>
<ol>
<li>确定将请求封装为<code>Response</code>, 而非Django的<code>HttpRequest</code>.</li>
<li>进行内容协商并为<code>Response</code>选择正确的渲染器.</li>
<li>捕获任何<code>APIException</code>异常,并渲染为合适的响应.</li>
<li>在为请求分配任何处理函数前进行合适的权限/限流验证.</li>
</ol>
<p>使用APIView的方式与View类似,定义与HTTP METHOD同名的方法,然后相关的请求就会被分配至对应的方法中处理:</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> authentication, permissions</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListUsers</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    View to list all users in the system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * Requires token authentication.</span></span><br><span class="line"><span class="string">    * Only admin users are able to access this view.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    authentication_classes = [authentication.TokenAuthentication]</span><br><span class="line">    permission_classes = [permissions.IsAdminUser]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return a list of all users.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        usernames = [user.username <span class="keyword">for</span> user <span class="keyword">in</span> User.objects.all()]</span><br><span class="line">        <span class="keyword">return</span> Response(usernames)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="基于函数的视图"><a href="#基于函数的视图" class="headerlink" title="基于函数的视图"></a>基于函数的视图</h3><p>当然, 在某些情况下,使用基于函数的视图函数也可能是更好的选择</p>
<p>基于函数的视图,必须使用@api_view装饰器以确保以上基本特性,并为任何附加方案增添对应的装饰器.</p>
<p>所以基于函数的视图在rest-framework中总是附加着一连串装饰器,可用的装饰器包括</p>
<ul>
<li>@renderer_classes(…)</li>
<li>@parser_classes(…)</li>
<li>@authentication_classes(…)</li>
<li>@throttle_classes(…)</li>
<li>@permission_classes(…)</li>
</ul>
<p>以上所有装饰器的参数都必须是一个列表或者元组,包含相应的类.</p>
<p>使用基于函数的视图的示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view, throttle_classes</span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> UserRateThrottle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OncePerDayUserThrottle</span><span class="params">(UserRateThrottle)</span>:</span></span><br><span class="line">        rate = <span class="string">'1/day'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(['GET'])</span></span><br><span class="line"><span class="meta">@throttle_classes([OncePerDayUserThrottle])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(&#123;<span class="string">"message"</span>: <span class="string">"Hello for today! See you tomorrow!"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>基于函数的视图在rest-framework中仅在实现非常简单的功能的情况下值得一用,绝大多数情况下使用CBV才是最佳选择.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 响应 Responses</title>
    <url>/2019/10/03/2.%20%E5%93%8D%E5%BA%94%20Response/</url>
    <content><![CDATA[<p>rest-framework的Response继承自Django的<code>SimpleTemplateResponse</code></p>
<p>Response 初始化时本身只包含纯粹的数据,而在之后被rest-framework通过内容协商确定客户端所需格式后,渲染为真正的HTTP响应.</p>
<p>推荐使用Response而非常规的<code>HttpResponse</code>或<code>StreamingHttpResponse</code>理由是Response提供了更好的接口可以根据内容协商以渲染为各种不同的格式.</p>
<p>除非需要深度化定制, 应当一直使用APIView或者使用同样返回Response的@api_view装饰的view函数,以确保视图可以进行内容协商和渲染不同类型的响应.</p>
<hr>
<a id="more"></a>

<p>签名: <code>Response(data, status=None, template_name=None, headers=None, content_type=None)</code></p>
<p>参数解释:</p>
<ul>
<li>data 作为响应主体内容的data, 需要为简单数据类型,例如Dict</li>
<li>status 响应的状态码, 默认为200</li>
<li>template_name: 可选,使用<code>HTMLRenderer</code>时要使用的模板名称。</li>
<li>headers: 额外添加的HTTP响应头的字典</li>
<li>content_type：通常由renderer自主决定，但也有可能需要明确指定</li>
</ul>
<p>属性:</p>
<ul>
<li><code>.data</code> 未渲染但应当是序列化过后的简单数据类型的data</li>
<li><code>.status_code</code> 状态码</li>
<li><code>.content</code> 渲染后的响应内容,调用该属性等于强制立即渲染.</li>
<li><code>.template_name</code> 用以渲染的html模板.仅在渲染器为<code>HTMLRenderer</code>(或类似的自定义渲染器)时不为空.</li>
<li><code>.accepted_renderer</code> 将用于进行渲染的渲染器类</li>
<li><code>.accepted_media_type</code> 在内容协商阶段确定响应内容的媒体类型</li>
<li><code>.renderer_context</code> 其他需要被传递给渲染器的额外上下文.</li>
</ul>
<p>当然,还包含标准<code>HttpResponse</code>包含的所有属性/方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = Response()</span><br><span class="line">response[<span class="string">'Cache-Control'</span>] = <span class="string">'no-cache'</span></span><br></pre></td></tr></table></figure>

<p>还包括继承自<code>SimpleTemplateResponse</code>的<code>render()</code>方法, 当然通常并不需要手动调用该方法,因为它是由Django的标准响应周期来处理的。</p>
<p>注: <code>SimpleTemplateResponse</code>与默认的<code>HttpResponse</code>行为模式不同,包括延迟渲染等特性,可以查阅Django文档了解.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 请求 Requests</title>
    <url>/2019/10/03/1.%20%E8%AF%B7%E6%B1%82%20request/</url>
    <content><![CDATA[<p>APIView的子类中的request不是django标准的HttpRequest类，而是经由rest_framework扩展的Request类</p>
<p>相较于HttpRequest添加的属性如下</p>
<p>请求解析相关:</p>
<ul>
<li><code>.data</code>类似于Django中request的<code>.POST</code>或者<code>.files</code>, 但在REST API中, put方法和putch方法也会被经常使用,因此这样可以避免命名带来的歧义.</li>
<li><code>.query_params</code>请求的查询参数, 等同于Django中的request.GET, 但命名更加准确.</li>
<li><code>.parsers</code>该请求所使用的parsers类,具体参看parsers一节.</li>
</ul>
<p>内容协商相关:</p>
<ul>
<li><code>.accepted_renderer</code>由内容协商阶段选择的renderer实例</li>
<li><code>.accepted_media_type</code>由内容协商阶段接受的媒体类型的字符串</li>
</ul>
<a id="more"></a>

<p>用户身份认证相关:</p>
<ul>
<li><code>.user</code>已认证的请求返回一个<code>django.contrib.auth.models.User</code>实例，未认证的请求返回一个<code>django.contrib.auth.models.AnonymousUser</code>实例。</li>
<li><code>.auth</code>未认证或没有其他上下文，则为None</li>
<li><code>.authenticators</code>用于进行认证的实例类</li>
</ul>
<p>浏览器增强:</p>
<ul>
<li><code>.method</code> 请求的HTTP METHOD, 全大写</li>
<li><code>.content_type</code>请 求体内容的媒体类型</li>
<li><code>.stream</code> 一个表示请求主体内容的流，通常依赖于rest_framework的默认请求解析行为</li>
</ul>
<p>标准HttpRequest属性:</p>
<p>其他Django标准HttpRequest的<code>所有</code>属性,例如</p>
<ul>
<li>.META</li>
<li>.session</li>
</ul>
<p>等等.</p>
<p>但Response不是<code>继承</code>(inherited)自HttpRequest,而是使用<code>聚合</code>(compostion)的方式拓展HttpRequest的实例.</p>
<p>关于继承和聚合,查看我的<a href>另一篇博客</a></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>uWSGI设置项</title>
    <url>/2019/09/24/uWSGI%E8%AE%BE%E7%BD%AE%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="通过不同方式进行设置"><a href="#通过不同方式进行设置" class="headerlink" title="通过不同方式进行设置"></a>通过不同方式进行设置</h3><ol>
<li>在启动时添加命令行参数</li>
<li>使用.ini文件</li>
<li>使用xml文件</li>
<li>使用yaml格式文件</li>
<li>…</li>
</ol>
<p>使用命令行参数示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uwsgi --http :9090 --wsgi-file foobar.py</span><br></pre></td></tr></table></figure>

<p>使用<code>.ini</code>文件示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:3031</span><br><span class="line">chdir = /home/foobar/myproject/</span><br><span class="line">wsgi-file = myproject/wsgi.py</span><br><span class="line">processes = 4</span><br><span class="line">threads = 2</span><br><span class="line">stats = 127.0.0.1:9191</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uwsgi yourfile.ini</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="uWSGI常用配置项"><a href="#uWSGI常用配置项" class="headerlink" title="uWSGI常用配置项"></a>uWSGI常用配置项</h3><table>
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>chdir</code></td>
<td>指定项目目录</td>
</tr>
<tr>
<td><code>wsgi-file</code></td>
<td>项目的WSGI接口文件</td>
</tr>
<tr>
<td><code>processes</code></td>
<td>指定工作进程数量</td>
</tr>
<tr>
<td><code>threads</code></td>
<td>指定每个工作进程的线程数量</td>
</tr>
<tr>
<td><code>socket</code></td>
<td>指定某个socket文件或端口, 使用<code>uwsgi</code>协议接收请求</td>
</tr>
<tr>
<td><code>http</code></td>
<td>指定某个端口, 使用<code>http</code>协议接收请求</td>
</tr>
<tr>
<td><code>stats</code></td>
<td>指定某个端口, 以json格式输出uWSGI内部统计信息</td>
</tr>
<tr>
<td><code>harakiri</code></td>
<td>指定进程被阻塞的最长时间, 超时的进程被master进程摧毁并重建</td>
</tr>
</tbody></table>
<hr>
<h3 id="部署Django"><a href="#部署Django" class="headerlink" title="部署Django"></a>部署Django</h3><p>Nginx作为反向代理, 使用<code>uwsgi</code>协议与<code>uWSGI</code>服务器进行通信, 因此</p>
<ol>
<li><code>uWSGI</code>服务器使用<code>uwsgi</code>协议启动.</li>
<li><code>Nginx</code>服务器使用<code>uwsgi</code>协议转发.</li>
</ol>
<hr>
<h4 id="uWSGI侧设置"><a href="#uWSGI侧设置" class="headerlink" title="uWSGI侧设置"></a>uWSGI侧设置</h4><p>假设Django项目位置为<code>/home/foobar/myproject</code>, 即<code>manage.py</code>放在该目录下.</p>
<p>命令行方式, 使用uwsgi协议, 设置工作目录<code>/home/foobar/myproject</code>, 4进程, 每个进程2线程, 输出统计信息到9191端口, 启动uWSGI:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uwsgi --socket 127.0.0.1:3031 --<span class="built_in">chdir</span> /home/foobar/myproject/ --wsgi-file myproject/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191</span><br></pre></td></tr></table></figure>

<p>以上命令较长, 但考虑可以使用Docker部署时写入到dockerfile的CMD/ENTERYPOINT指令中, 所以跟写成<code>.ini</code>配置文件没有太大的区别.</p>
<p>特别注意, 如果使用docker进行部署, <code>--socket</code>不能包含<code>127.0.0.1</code>, 即实际启动端口需为<code>0.0.0.0:3031</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uwsgi --socket :3031 --<span class="built_in">chdir</span> /home/foobar/myproject/ --wsgi-file myproject/wsgi.py --master --processes 4 --threads 2</span><br></pre></td></tr></table></figure>

<p>否则Nginx无法连接至uWSGI.</p>
<hr>
<h4 id="Nginx侧设置"><a href="#Nginx侧设置" class="headerlink" title="Nginx侧设置"></a>Nginx侧设置</h4><p>Nginx作为反向代理, 通过<code>uwsgi</code>协议转发, 即使用<code>uwsgi_pass</code>而非<code>proxy_pass</code>, 反向代理部分设置如下:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">include</span> uwsgi_params;</span><br><span class="line">    <span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:3031</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uwsgi_params中会自动进行远程ip, 请求头等字段的重写以确保uWSGI服务器收到的是原始请求的信息, 而非Nginx请求的信息, 无需再手动设置.</p>
<hr>
<p>参考</p>
<p><a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/WSGIquickstart.html#django" target="_blank" rel="noopener">uWSGI官方文档</a><br><a href="https://henulwj.github.io/2016/04/20/uwsgi-common-use-parameters/" target="_blank" rel="noopener">uWSGI常用参数介绍-米刀文</a></p>
]]></content>
      <tags>
        <tag>uWSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next添加访问统计</title>
    <url>/2019/08/25/Hexo%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>如果使用的是Next主题的话, 已经集成了busuanzi统计, 但默认处于禁用状态.</p>
<a id="more"></a>

<hr>
<h3 id="开启busuanzi统计"><a href="#开启busuanzi统计" class="headerlink" title="开启busuanzi统计"></a>开启busuanzi统计</h3><p>打开主题配置文件<code>next/_config.yml</code>, 找到<code>busuanzi_count</code>部分:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line"><span class="attr">  site_uv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line"><span class="attr">  site_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line"><span class="attr">  page_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="attr">  page_pv_footer:</span></span><br></pre></td></tr></table></figure>

<p>将<code>enable</code>设为<code>true</code>, 即可开启busuanzi统计.</p>
<hr>
<h3 id="更改外链"><a href="#更改外链" class="headerlink" title="更改外链"></a>更改外链</h3><p>在<strong>当前版本</strong>中, 由于busuanzi网址失效, 而next中未及时更新该部分, 所以需要手动更改</p>
<p>打开<code>next/layout/_third-party/analytic/</code>, 打开<code>busuanzi-counter.swig</code>, 找到</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>更改为:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="统计量"><a href="#统计量" class="headerlink" title="统计量"></a>统计量</h3><p><code>site_uv</code>: 网站访问用户<br><code>site_pv</code>: 网站访问次数<br><code>page_pv</code>: 页面访问次数</p>
<p>前两者是网站访问的统计量, 会显示在首页的页脚部分, 后者则是页面访问的统计量, 会显示在博客的标题下方.</p>
<p>在开启busuanzi统计之后, 如果是在本地4000端口运行服务器, 前两者的数据会非常大, 因为所有不蒜子用户共用一个统计空间, 所有使用<code>localhost:4000</code>网址的用户会累计到同一个记录上.</p>
<p>在部署至与别人不重复的网址时, 就可以恢复正常.</p>
<hr>
<h3 id="自定义统计前缀和后缀"><a href="#自定义统计前缀和后缀" class="headerlink" title="自定义统计前缀和后缀"></a>自定义统计前缀和后缀</h3><p>在以上设置项中, </p>
<ol>
<li><code>*_header</code>是显示在统计数字之前的前缀, 默认为一个<code>font-awesome</code>图标</li>
<li><code>*_footer</code>是显示在统计数字之后的后缀, 默认无.</li>
</ol>
<p>可以直接修改进行自定义.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line"><span class="attr">  site_uv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_uv_header:</span> <span class="string">本站访问人数</span></span><br><span class="line"><span class="attr">  site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line"><span class="attr">  site_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_pv_header:</span> <span class="string">本站访问量</span></span><br><span class="line"><span class="attr">  site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line"><span class="attr">  page_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  page_pv_header:</span> <span class="string">本文阅读量</span></span><br><span class="line"><span class="attr">  page_pv_footer:</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="更新-2019-10-14"><a href="#更新-2019-10-14" class="headerlink" title="更新(2019.10.14)"></a>更新(2019.10.14)</h3><p>在最新版本的Next中, <code>busuanzi-counter.swig</code>移至<code>next/layout/_partials/analytic/</code>, 外链失效问题已被修复.</p>
<p>主题配置文件的busuanzi_count部分少量更改, 不再提供<code>*_header</code>和<code>*_footer</code>项, 如果有需要, 直接修改<code>busuanzi-counter.swig</code>文件的html代码即可.</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2019/08/23/Hexo+Github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://hexo.io/index.html" target="_blank" rel="noopener">Hexo</a>是一个快速、简洁且高效的博客框架, 基于Node.js</p>
<p><a href="https://github.com" target="_blank" rel="noopener">Github</a>可以为每一个repository提供一个Github Pages, 但默认是不开启的.</p>
<p>我们通过Hexo生成静态页面, 然后将其同步至远程仓库, 作为某个repository的Github Page, 这样就可以直接在Github上访问了.</p>
<a id="more"></a>

<p>搭建过程分为三步:</p>
<ol>
<li>在github上建立一个repository并开启Github Page.</li>
<li>用Hexo在本地创建博客.</li>
<li>安装git, 并将Hexo部署到远程仓库.</li>
</ol>
<p>之后, 就可以访问搭建在Github的博客页面了.</p>
<hr>
<h3 id="创建repository并开启Github-Page"><a href="#创建repository并开启Github-Page" class="headerlink" title="创建repository并开启Github Page"></a>创建repository并开启Github Page</h3><ol>
<li>创建一个repository, repository name 设置为<strong><span style="color: deeppink;">username</span>.github.io</strong>(推荐, 这样生成的访问地址最为简短)</li>
<li>进入repository的setting页面, 找到GitHub Pages一节, 点击<code>choose a theme</code></li>
<li>选中一个主题, 然后select theme, 再之后会自动创建一个<code>index.md</code>文件, 无需修改, 直接commit changes</li>
<li>之后再进入repository的setting界面, 找到Github Pages一节, 已经出现提示:<strong>Your site is published at <span style="color: deeppink;">URL<span></span></span></strong></li>
<li>直接在浏览器中访问该URL, 至此Github Page开启成功.</li>
</ol>
<hr>
<h3 id="使用Hexo创建个人博客"><a href="#使用Hexo创建个人博客" class="headerlink" title="使用Hexo创建个人博客"></a>使用Hexo创建个人博客</h3><ol>
<li>安装node.js </li>
<li>阅读Hexo文档, 安装Hexo, 并使用Hexo创建一个博客项目, 搭建个人博客.</li>
</ol>
<hr>
<h3 id="使用git部署博客"><a href="#使用git部署博客" class="headerlink" title="使用git部署博客"></a>使用git部署博客</h3><ol>
<li><p>安装git, 完成后在命令行输入<code>git version</code>确认安装成功</p>
</li>
<li><p>打开repostory页面, 点击<code>Clone or download</code>, 弹出来的小框里选择右上角<code>Use HTTPS</code>, 之后复制出现的URL</p>
</li>
<li><p>在上一步中, repository的URL为<code>https</code>开头, 意味着会使用https协议进行远程仓库的连接</p>
</li>
<li><p>打开Hexo创建的项目的根目录下<code>_config.yml</code>文件, 该文件是一个<strong>YAML</strong> <em>[/ˈjæməl/]</em>语法的配置文件</p>
</li>
<li><p>找到deploy一节, 更改为如下形式, URL指的是第2步获得的URL.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: URL</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换至本地hexo项目根目录, 安装相关库, <code>npm install hexo-deployer-git —save</code></p>
</li>
<li><p>之后使用hexo部署命令: <code>hexo d</code>, 进行远程部署</p>
</li>
<li><p>在部署过程中, 会弹出github的账号密码输入框, 正确输入并确认, 之后会进行部署</p>
</li>
</ol>
<p>到此, 部署成功, 访问该repostory的Github Page的URL, 显示效果与本地一致.</p>
<p>之后每次写博客之后, 使用<code>hexo d</code>命令部署即可. </p>
<p>如果更新博客之后, 部署命令显示无新内容, 使用<code>hexo clean</code>清除缓存, 然后再次尝试部署.</p>
<p>因为缓存的原因, 每次同步之后可能要稍等几分钟才能在Github Page中生效.</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo自定义代码高亮</title>
    <url>/2019/08/22/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<p>以Next主题为例, 只提供了五种代码高亮样式, 在都不满足需要的情况下, 可能需要进行自定义.</p>
<p>因为Next并没有提供接口, 所以需要直接修改相关css代码.</p>
<a id="more"></a>

<hr>
<h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>被一对反引号标记的行内代码, 默认情况下是灰色背景, 文本颜色不变, 如果需要修改, 则找到<code>&lt;code&gt;</code>选择器部分:</p>
<p>行内代码高亮的css部分定义在<code>next/source.css/_common/component/highlight/highlight.styl</code>中.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">  <span class="attribute">color</span>: $code-foreground;</span><br><span class="line">  <span class="attribute">background</span>: $code-background;</span><br><span class="line">  <span class="attribute">border-radius</span>: $code-border-radius;</span><br><span class="line">  font-size $code-font-size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如更改行内代码样式为红色文本, 淡红色背景, 则重设<code>color</code>和<code>background</code>属性:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(255,192,203, 0.1);</span><br><span class="line">  <span class="attribute">border-radius</span>: $code-border-radius;</span><br><span class="line">  font-size $code-font-size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体显示效果如本文所示.</p>
<hr>
<h3 id="高亮主题"><a href="#高亮主题" class="headerlink" title="高亮主题"></a>高亮主题</h3><p>Hexo提供了五种代码高亮主题: <code>normal</code>, <code>night</code>, <code>night blue</code>, <code>night bright</code>, <code>night eighties</code>.</p>
<p>高亮主题的css部分定义在<code>next/source.css/_common/component/highlight/theme.styl</code>中, 在这里我们能看到具体的方案配色:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> $highlight_theme == <span class="string">"normal"</span></span><br><span class="line">  $highlight-background   = #f7f7f7</span><br><span class="line">  $highlight-current-line = #efefef</span><br><span class="line">  $highlight-selection    = #d6d6d6</span><br><span class="line">  $highlight-foreground   = #4d4d4c</span><br><span class="line">  $highlight-comment      = #8e908c</span><br><span class="line">  $highlight-red          = #c82829</span><br><span class="line">  $highlight-orange       = #f5871f</span><br><span class="line">  $highlight-yellow       = #eab700</span><br><span class="line">  $highlight-green        = #718c00</span><br><span class="line">  $highlight-aqua         = #3e999f</span><br><span class="line">  $highlight-blue         = #4271ae</span><br><span class="line">  $highlight-purple       = #8959a8</span><br><span class="line">  $highlight-gutter       = &#123;</span><br><span class="line">    color: #869194,</span><br><span class="line">    bg-color: #eff2f3</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>直接更改某个主题的配色, 或是创建新的配色主题:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> $highlight_theme == <span class="string">"solarized light"</span></span><br><span class="line">  $highlight-background   = #FDF6E3</span><br><span class="line">  $highlight-constant     = #00FF00</span><br><span class="line">  $highlight-current-line = #FDF6E3</span><br><span class="line">  $highlight-selection    = #ECE7D5</span><br><span class="line">  $highlight-foreground   = #657A81</span><br><span class="line">  $highlight-comment      = #93A1A1</span><br><span class="line">  $highlight-red          = #D30102</span><br><span class="line">  $highlight-orange       = #657A81</span><br><span class="line">  $highlight-yellow       = #657A81</span><br><span class="line">  $highlight-green        = #2AA198</span><br><span class="line">  $highlight-aqua         = #657A81</span><br><span class="line">  $highlight-blue         = #657A81</span><br><span class="line">  $highlight-purple       = #B58900</span><br><span class="line">  $highlight-gutter       = &#123;</span><br><span class="line">    color: #586E75</span><br><span class="line">    bg-color: #FDF6E3</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后到<strong>站点配置文件</strong>(即项目根目录下<code>_config.yml</code>文件)中, 更改使用的配色主题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight_theme: solarized light</span><br></pre></td></tr></table></figure>

<p>保存生效即可.</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法基础</title>
    <url>/2019/07/31/SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>暂时未搬运.</p>
]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS 跨源资源共享</title>
    <url>/2019/07/07/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>由于浏览器的安全限制, 因此需要一种机制来保证允许安全的跨域请求.</p>
<a id="more"></a>

<hr>
<h3 id="CORS-Cross-Origin-Resource-Sharing-跨源资源共享"><a href="#CORS-Cross-Origin-Resource-Sharing-跨源资源共享" class="headerlink" title="CORS(Cross-Origin Resource Sharing)跨源资源共享"></a>CORS(Cross-Origin Resource Sharing)跨源资源共享</h3><p>CORS是一种机制, 它定义了一组HTTP头部, 用以对浏览器声明可以允许对哪些网站发起跨域请求</p>
<p>即：浏览器拦不拦截该跨域请求, 要询问过被请求的网站之后再做决定. 当然, 也必须浏览器能支持CORS才能理解并使用CORS机制来完成跨域请求.</p>
<p>基本所有的主流浏览器都支持CORS.</p>
<p>跨域请求的流程:</p>
<p>发起跨域请求的B网站, 浏览器, 以及接收到跨域请求的A网站</p>
<ol>
<li>B网页中内嵌的js要求浏览器对A发送请求</li>
<li>浏览器并不直接对A发起请求, 而是通过预检请求(请求方式一般为OPTION)先询问A, 是否接受该请求</li>
<li>A收到浏览器的请求, 并通过响应的头部告诉浏览器, 它允许B引用自己的资源</li>
<li>浏览器得到肯定的答复, 真正对A发起(B要求浏览器发起的)请求</li>
</ol>
<p>这样, 浏览器就实现了跨域请求, 所有跨域请求都要得到目标域的允许, 不会影响安全性. </p>
<hr>
<h3 id="CORS头"><a href="#CORS头" class="headerlink" title="CORS头"></a>CORS头</h3><p>CORS新增了一些HTTP header字段, 这些字段用于目标域返回给浏览器用以告诉浏览器是否允许该跨域请求</p>
<table>
<thead>
<tr>
<th>HTTP头</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Access-Control-Allow-Origin</td>
<td>指定允许访问该资源的外域URL, 如果是通配符<code>*</code>, 代表允许来自所有域的请求</td>
</tr>
<tr>
<td>Access-Control-Allow-Methods</td>
<td>指定允许进行跨域请求的method, 如果是通配符<code>*</code>,代表允许所有method的请求</td>
</tr>
<tr>
<td>Access-Control-Allow-Headers</td>
<td>指定实际请求中允许携带的首部字段,如果是通配符<code>*</code>,代表允许携带任意首部的请求</td>
</tr>
<tr>
<td>Access-Control-Max-Age</td>
<td>指定本次预检请求的结果能够被缓存多久(无论是允许, 还是不允许)</td>
</tr>
<tr>
<td>Access-Control-Expose-Headers</td>
<td>指定浏览器可以在跨域访问中获得的除了基本头之外的响应头</td>
</tr>
<tr>
<td>Access-Control-Allow-Credentials</td>
<td>布尔型, 指定实际请求中是否允许携带Cookie,  默认为不允许</td>
</tr>
</tbody></table>
<p>以下字段用于发送预检或发送实际跨域请求时, 浏览器告知服务器端的信息</p>
<table>
<thead>
<tr>
<th>HTTP头部</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Origin</td>
<td>给出预检请求和实际请求的源站</td>
</tr>
<tr>
<td>Access-Control-Request-Method</td>
<td>预检时使用, 将实际请求所使用的HTTP方法告知服务器</td>
</tr>
<tr>
<td>Access-Control-Request-Headers</td>
<td>预检时使用, 将实际请求所携带的首部字段告知服务器</td>
</tr>
</tbody></table>
<hr>
<h3 id="在Django中允许跨站请求"><a href="#在Django中允许跨站请求" class="headerlink" title="在Django中允许跨站请求"></a>在Django中允许跨站请求</h3><p><a href="https://pypi.org/project/django-cors-headers/" target="_blank" rel="noopener">django-cors-headers</a>包是对CORS的服务器端实现,允许django服务器接收来自浏览器的跨域请求</p>
<p>通过pip安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>

<p>添加到INSTALLED_APP中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'corsheaders'</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>添加中间件, 通过中间件为响应添加CORS相关的头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [ </span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'corsheaders.middleware.CorsMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>corsheaders.middleware.CorsMiddleware</code>要放在尽量靠前的位置, 以便能够为最终的响应添加头</p>
<hr>
<p>设置项</p>
<p><code>CORS_ORIGIN_WHITELIST</code>: 字符串列表, 给出所有允许跨域请求的源<br><code>CORS_ORIGIN_REGEX_WHITELIST</code>: 正则表达式列表, 给出所有允许跨院请求的源的格式<br><code>CORS_ORIGIN_ALLOW_ALL</code>: 布尔型, 是否允许所有的跨域请求<br><code>CORS_URLS_REGEX</code>: 正则表达式列表, 给出本网站允许跨域请求的URL, 在网站只有部分URL允许跨域请求时有用<br><code>CORS_ALLOW_METHODS</code>：字符串列表, 给出所有允许跨域请求的方式<br><code>CORS_ALLOW_HEADERS</code>：字符串列表, 允许实际请求携带的头<br><code>CORS_EXPOSE_HEADERS</code>: 字符串列表, 允许在跨域请求中暴露的额外响应头<br><code>CORS_PREFLIGHT_MAX_AGE</code>: 整数, 给出该预检请求的结果缓存时间(秒), 默认为一天<br><code>CORS_ALLOW_CREDENTIALS</code>：布尔型, 是否允许实际请求携带cookie</p>
<hr>
<h4 id="如何让跨域请求通过CSRF中间件"><a href="#如何让跨域请求通过CSRF中间件" class="headerlink" title="如何让跨域请求通过CSRF中间件:"></a>如何让跨域请求通过CSRF中间件:</h4><p>Django的CORS和CSRF保护是分离的, 所以CSRF的防御并不会自动允许CORS所允许的域的POST请求.<br>如果想允许跨域的不安全请求方式, 除了要将源添加入django-cors-headers的CORS_ORIGIN_WHITELIST<br>还需要将其添加入<a href="https://docs.djangoproject.com/en/dev/ref/settings/#csrf-trusted-origins" target="_blank" rel="noopener">CSRF_TRUSTED_ORIGINS</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    &apos;http://read.only.com&apos;,</span><br><span class="line">    &apos;http://change.allowed.com&apos;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">CSRF_TRUSTED_ORIGINS = (</span><br><span class="line">    &apos;change.allowed.com&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p>如果除了需要设置项, 还需要使用代码来判断请求是否被允许, 可以使用django信号来完成. 可以参考<a href="https://pypi.org/project/django-cors-headers/" target="_blank" rel="noopener">官方文档</a></p>
<p>参考:<br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a><br><a href="https://www.jianshu.com/p/f880878c1398" target="_blank" rel="noopener">什么是跨域请求以及实现跨域的方案</a><br><a href="https://blog.csdn.net/lambert310/article/details/51683775" target="_blank" rel="noopener">什么是跨域？怎么解决跨域问题？</a><br><a href="https://www.jianshu.com/p/f880878c1398" target="_blank" rel="noopener">什么是跨域请求以及实现跨域的方案</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制</a>  </p>
]]></content>
      <tags>
        <tag>前端安全</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Contenttype使用示例(未完成)</title>
    <url>/2019/07/03/Django%20contenttype/</url>
    <content><![CDATA[<p>Django包含一个<code>conntenttypes</code>应用, 可以追踪已安装app中所有的Model.</p>
<p><code>contenttypes</code>应用的核心是一个<code>ContentType</code>模型, 每个该模型每个实例记录了Django从上面项目中已安装app的全部模型信息.</p>
<p>通过<code>ContentType</code>, 我们可以获得任何一个app中的某个<code>Model</code>.</p>
<p>所以, 当某个模型与<code>ContentType</code>建立约束关系之后, 该模型也就能通过<code>ContentType</code>访问多个不同的模型.</p>
<p>即: 外键约束至<code>ContentType</code>, 意味着该外键被约束至<strong>多个</strong>模型, 该外键的实体可能是其中任意一个模型的实例.</p>
<p>所以, contenttypes的使用场景是, 某个模型的外键需要指向不同模型的情况.</p>
<hr>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>我们打算建立一个标签系统, 多个Model例如书籍, 相册, 文章, 都可以添加标签, 如何建立标签模型?</p>
<p>普通的约束关系(例如<code>ForeignKey</code>)只能建立与一个模型之间的约束关系, 所以我们的Tag模型至少需要三个外键, 约束至上述各个模型.</p>
<p>而这三个外键中, 可能只有一个不为空, 这意味着空间的浪费, 而假如以后我们又增添了唱片模型, 怎么办? 只能增加Tag模型的外键.</p>
<p>这意味着更低的空间利用率和数据表结构的改变, 当然, 存储实例对应不同外键时, 还要写不同的存储代码.</p>
<p>关键是, 我们压根确定到底还有多少需要使用标签的<code>Model</code>, 难道以后要为这些Model一一添加外键? </p>
<hr>
<h4 id="通用关系"><a href="#通用关系" class="headerlink" title="通用关系"></a>通用关系</h4><p>上述问题的关键就在于, 每个外键都只能约束至<strong>一个</strong>模型, 而实际上, 通过<code>contentypes</code>, 我们可以将外键约束至不同的模型.</p>
<p>在我们tag模型中, 我们需要增加三个字段, 通常, 这些字段的命名和定义都是固定的.</p>
<ol>
<li>一个外键字段<code>ForeignKey</code>, 约束至代理模型<code>ContentType</code>的某个实例, 实际上就是某个<code>Model</code>, 该字段名通常为<code>content_type</code>.</li>
<li>一个正整数字段<code>PositiveIntegerField</code>, 存储外模型实例的主键值, 通常为’id’字段的值, 该字段名通常为<code>object_id</code>.</li>
<li>一个通用外键字段<code>GenericForeignKey</code>, 约束至具体的实例, 需要指定前两者的字段名, 即<code>content_type</code>和<code>object_id</code>, 并作为访问关联实例的入口, 该字段名通常为<code>content_object</code>.</li>
</ol>
<p>通用外键通过代理模型<code>ContentType</code>和<code>object_id</code>进行约束, 这就是为什么在定义该字段时, 要将前两者的字段名作为初始化参数.</p>
<p>在以上三个字段中, <code>content_type</code>指定(通过代理模型)约束至哪个外模型, 而<code>object_id</code>指明该实例的主键, 而<code>content_object</code>通过前两者确保约束至指定模型的某个实例.</p>
<p>在存储时, 以上三个字段只需要填充<code>content_object</code>即可, 其余两者会根据传入的实例自行填充.</p>
<p>而恰恰相反的是, 以上三个字段, 只有<code>content_object</code>是实际上不存在的字段, 它只是一个操作的入口, 每个实例的<code>content_type</code>和<code>object_id</code>就包含了约束外模型实例的全部信息.</p>
<p>也因此, <code>content_object</code>并不能直接作为filter()的参数, 因为它实际上并不存在.</p>
<hr>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h3 id="Tag模型"><a href="#Tag模型" class="headerlink" title="Tag模型"></a>Tag模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.fields <span class="keyword">import</span> GenericForeignKey</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.models <span class="keyword">import</span> ContentType</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    tag = models.SlugField() <span class="comment"># 后三个字段是模式化的定义</span></span><br><span class="line">    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    content_object = GenericForeignKey(<span class="string">'content_type'</span>, <span class="string">'object_id'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.tag</span><br></pre></td></tr></table></figure>

<p>相关模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	title = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><p>给书籍实例添加标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python_tutorial = Book.objects.create(title=<span class="string">"python web tutorial"</span>)  <span class="comment"># 创建一个书籍实例</span></span><br><span class="line"></span><br><span class="line">TaggedItem.objects.create(content_object=python_tutorial, tag=<span class="string">"python"</span>) <span class="comment"># 创建一条标签记录</span></span><br><span class="line">TaggedItem.objects.create(content_object=python_tutorial, tag=<span class="string">"django"</span>) <span class="comment"># 再增加一个标签</span></span><br></pre></td></tr></table></figure>

<p>查看书名为<code>python web tutorial</code>的这本书的标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book_type = ContentType.objects.get_for_model(Book) <span class="comment"># 获取Book类在Contentype中的具体记录</span></span><br><span class="line">book = Book.object.get(title=<span class="string">'python web tutorial'</span>) <span class="comment"># 获取这本书的实例</span></span><br><span class="line">TaggedItem.objects.filter(content_type__pk=book_type.id, object_id=book.id ) <span class="comment"># 通过两个实际存在的字段, 进行filter查询</span></span><br></pre></td></tr></table></figure>

<p>查看书名中包含<code>python</code>一词的所有书的标签记录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book_type = ContentType.objects.get_for_model(Book)</span><br><span class="line">books = Book.objects.filter(title__contains=<span class="string">"python"</span>)</span><br><span class="line">TaggedItem.objects.filter(content_type__pk=book_type.id, object_id__in=books)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p>以上的操作方法, 相较于普通的查询更复杂, 一种快捷方法是在相关的外模型中设置反向关联字段和反向查询名:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.fields <span class="keyword">import</span> GenericRelation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	title = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">	tags = GenericRelation(TaggedItem, related_query_name=<span class="string">'book'</span>)</span><br></pre></td></tr></table></figure>

<p>下面使用反向关联名和反向查询名完成相同操作:</p>
<p>创建标签记录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python_tutorial = Book.objects.create(title=<span class="string">"python web tutorial"</span>) </span><br><span class="line">python_tutorial.tags.create(tag=<span class="string">"python"</span>)</span><br><span class="line">python_tutorial.tags.create(tag=<span class="string">"django"</span>)</span><br></pre></td></tr></table></figure>

<p>查看书名为<code>python web tutorial</code>的这本书的标签:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TaggedItem.objects.filter(book__title=<span class="string">"python web tutorial"</span>)</span><br></pre></td></tr></table></figure>

<p>查看书名中包含<code>python</code>一词的所有书的标签记录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TaggedItem.objects.filter(book__titile__contains=<span class="string">'python'</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到, 设置通用关系字段和反向查询名之后, 查询的复杂度大大降低.</p>
<p>值得注意的是, 该字段也是一个接口, 并不存在于数据库中.</p>
]]></content>
      <tags>
        <tag>Django</tag>
        <tag>Contenttype</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+Mysql实现赞踩系统</title>
    <url>/2019/07/03/Django%E7%82%B9%E8%B5%9E%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>主要包括两个部分: </p>
<ol>
<li>通用赞踩模型, 可以记录多个不同模型实例的赞同/反对记录</li>
<li>通用赞踩混合类, 任何希望提供赞踩功能的模型应当混入该混合类</li>
</ol>
<p>前者提供了对赞同/反对操作进行记录的Model, 会生成一个数据表<br>后者提供了统计字段和赞同/反对的实例方法, Abstract模型, 只用于继承.</p>
<hr>
<h3 id="通用赞踩记录模型"><a href="#通用赞踩记录模型" class="headerlink" title="通用赞踩记录模型"></a>通用赞踩记录模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.fields <span class="keyword">import</span> GenericRelation, GenericForeignKey, ContentType</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoteReference</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)</span><br><span class="line">    created = models.DateTimeField(default=timezone.now)</span><br><span class="line">    upvote = models.BooleanField()</span><br><span class="line"></span><br><span class="line">    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    content_object = GenericForeignKey(<span class="string">'content_type'</span>, <span class="string">'object_id'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'-created'</span>,]</span><br><span class="line">        verbose_name = <span class="string">"VotedItemRecord"</span></span><br><span class="line">        verbose_name_plural = <span class="string">"VoteReference"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.username +<span class="string">" voted to "</span> + str(self.content_object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(VoteReference)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoteReferenceAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (</span><br><span class="line">        <span class="string">'id'</span>,</span><br><span class="line">        <span class="string">'user'</span>, </span><br><span class="line">        <span class="string">'upvote'</span>, </span><br><span class="line">        <span class="string">'created'</span>, </span><br><span class="line">        <span class="string">'content_type'</span>, </span><br><span class="line">        <span class="string">'object_id'</span>, </span><br><span class="line">        <span class="string">'content_object'</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ol>
<li>使用<code>contenttypes</code>创建通用赞踩模型, 获得当前用于认证的用户Model作为user字段的约束.</li>
<li>在后台登记该模型, 因为逻辑简单所以直接写在<code>models.py</code>.</li>
</ol>
<p><em>Django默认<code>INSTALLED_APPS</code>包含了<code>contenttypes</code>.</em></p>
<hr>
<h3 id="自定义Manager"><a href="#自定义Manager" class="headerlink" title="自定义Manager"></a>自定义Manager</h3><p>自定义Manager提供获取本Model内被某个用户赞同/反对过的实例查询集的方法, 因为要在<code>VoteMixin</code>使用通用关系字段, 而且为了即插即用, 无法指定反向关联查询名, 操作略显复杂, 有封装的必要.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoteManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_upvoted</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        self_type = ContentType.objects.get_for_model(self.model)</span><br><span class="line">        vote_qs = VoteReference.objects.filter(</span><br><span class="line">            user=user, </span><br><span class="line">            upvote=<span class="literal">True</span>,</span><br><span class="line">            content_type__pk=self_type.id</span><br><span class="line">        )</span><br><span class="line">        ids = [r.get(<span class="string">'object_id'</span>) <span class="keyword">for</span> r <span class="keyword">in</span> vote_qs.values(<span class="string">'object_id'</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.get_queryset().filter(id__in=ids)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_downvoted</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        self_type = ContentType.objects.get_for_model(self.model)</span><br><span class="line">        vote_qs = VoteReference.objects.filter(</span><br><span class="line">            user=user, </span><br><span class="line">            upvote=<span class="literal">False</span>,</span><br><span class="line">            content_type__pk=self_type.id</span><br><span class="line">        )</span><br><span class="line">        ids = [r.get(<span class="string">'object_id'</span>) <span class="keyword">for</span> r <span class="keyword">in</span> vote_qs.values(<span class="string">'object_id'</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.get_queryset().filter(id__in=vote_qs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_popular</span><span class="params">(self, min_upvote_rate=<span class="number">0.7</span>, min_up_count=<span class="number">10</span>, limit=<span class="number">20</span>)</span>:</span></span><br><span class="line">        qs = self.get_queryset().filter(</span><br><span class="line">            upvote_rate__gte=min_upvote_rate, </span><br><span class="line">            up_count__gte=min_up_count</span><br><span class="line">        ).order_by(<span class="string">'-up_count'</span>)</span><br><span class="line">        <span class="keyword">return</span> qs[:limit] <span class="keyword">if</span> limit <span class="keyword">else</span> qs</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="混合类VoteMixin提供通用赞踩操作"><a href="#混合类VoteMixin提供通用赞踩操作" class="headerlink" title="混合类VoteMixin提供通用赞踩操作"></a>混合类<code>VoteMixin</code>提供通用赞踩操作</h3><p>逻辑:</p>
<ol>
<li>点赞和反对, 会同步更新统计字段的值.</li>
<li>每个用户对同一对象的点赞和反对仅能生效一次.</li>
<li>点赞的同时会取消反对(如果已反对), 反之亦然.</li>
<li>提供一个bulk_vote方法, 可以在常数次查询中执行多个用户的赞踩操作.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> get_user_model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoteMixin</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    up_count = models.PositiveIntegerField(default=<span class="number">0</span>)</span><br><span class="line">    down_count = models.PositiveIntegerField(default=<span class="number">0</span>)</span><br><span class="line">    upvote_rate = models.FloatField(default=<span class="number">0</span>)</span><br><span class="line">    vote_reference = GenericRelation(VoteReference)</span><br><span class="line">    voter = VoteManager()</span><br><span class="line">    objects = models.Manager()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(self, user, upvote)</span>:</span></span><br><span class="line">        <span class="string">""" 赞同/反对操作方法 """</span></span><br><span class="line">        r = self.vote_reference.filter(user=user).first()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">            self.vote_reference.create(upvote=upvote, user=user)</span><br><span class="line">            <span class="keyword">if</span> upvote:</span><br><span class="line">                self.up_count += <span class="number">1</span></span><br><span class="line">                self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">                self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                    up_count=F(<span class="string">'up_count'</span>)+<span class="number">1</span>, </span><br><span class="line">                    upvote_rate=self.upvote_rate</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.down_count += <span class="number">1</span></span><br><span class="line">                self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">                self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                    down_count=F(<span class="string">'down_count'</span>)+<span class="number">1</span>, </span><br><span class="line">                    upvote_rate=self.upvote_rate</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> upvote != r.upvote:</span><br><span class="line">                <span class="keyword">if</span> upvote:</span><br><span class="line">                    self.up_count += <span class="number">1</span></span><br><span class="line">                    self.down_count -= <span class="number">1</span></span><br><span class="line">                    self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">                    self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                        down_count=F(<span class="string">'down_count'</span>)<span class="number">-1</span>, </span><br><span class="line">                        up_count=F(<span class="string">'up_count'</span>)+<span class="number">1</span>, </span><br><span class="line">                        upvote_rate=self.upvote_rate</span><br><span class="line">                    )</span><br><span class="line">                    self.vote_reference.filter(id=r.id).update(upvote=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.up_count -= <span class="number">1</span></span><br><span class="line">                    self.down_count += <span class="number">1</span></span><br><span class="line">                    self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">                    self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                        down_count=F(<span class="string">'down_count'</span>)+<span class="number">1</span>, </span><br><span class="line">                        up_count=F(<span class="string">'up_count'</span>)<span class="number">-1</span>, </span><br><span class="line">                        upvote_rate=self.upvote_rate</span><br><span class="line">                    )</span><br><span class="line">                    self.vote_reference.filter(id=r.id).update(upvote=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">voteneutral</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        r = self.vote_reference.filter(user=user).first()</span><br><span class="line">        <span class="keyword">if</span> r:</span><br><span class="line">            r.delete()</span><br><span class="line">            <span class="keyword">if</span> r.upvote:</span><br><span class="line">                self.up_count -= <span class="number">1</span> </span><br><span class="line">                self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">                self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                    up_count=F(<span class="string">'up_count'</span>)<span class="number">-1</span>, </span><br><span class="line">                    upvote_rate=self.upvote_rate</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.down_count -= <span class="number">1</span></span><br><span class="line">                self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">                self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                    down_count=F(<span class="string">'down_count'</span>)<span class="number">-1</span>, </span><br><span class="line">                    upvote_rate=self.upvote_rate</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_upvote_rate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._calc_upvote_rate(self.up_count, self.down_count)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_calc_upvote_rate</span><span class="params">(up_count, down_count)</span>:</span></span><br><span class="line">        total_vote_count = up_count + down_count</span><br><span class="line">        base = total_vote_count <span class="keyword">if</span> total_vote_count <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        upvote_rate = round((up_count/base), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> upvote_rate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_voted_user</span><span class="params">(self, upvote=True)</span>:</span></span><br><span class="line">        vote_qs = self.vote_reference.filter(upvote=upvote).values(<span class="string">'user'</span>)</span><br><span class="line">        user_ids = [r.get(<span class="string">'user'</span>) <span class="keyword">for</span> r <span class="keyword">in</span> vote_qs]</span><br><span class="line">        <span class="keyword">return</span> get_user_model().objects.filter(id__in=user_ids)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_upvoted</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.vote_reference.filter(user=user, upvote=<span class="literal">True</span>).exists()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_downvoted</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.vote_reference.filter(user=user, upvote=<span class="literal">False</span>).exists()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bulk_vote</span><span class="params">(self, users_pk, upvote)</span>:</span></span><br><span class="line">        existed_record_count = self.vote_reference.filter(user__id__in=users_pk, upvote=upvote).count()</span><br><span class="line">        conflicted_record_count = self.vote_reference.filter(user__id__in=users_pk, upvote=<span class="keyword">not</span> upvote).count()</span><br><span class="line">        <span class="keyword">if</span> upvote:</span><br><span class="line">            self.up_count -= existed_record_count</span><br><span class="line">            self.down_count -= conflicted_record_count</span><br><span class="line">            self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                up_count=F(<span class="string">'up_count'</span>)-existed_record_count,</span><br><span class="line">                down_count=F(<span class="string">'down_count'</span>)-conflicted_record_count</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.down_count -= existed_record_count</span><br><span class="line">            self.up_count -= conflicted_record_count</span><br><span class="line">            self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                down_count=F(<span class="string">'down_count'</span>)-existed_record_count,</span><br><span class="line">                up_count=F(<span class="string">'up_count'</span>)-conflicted_record_count</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        self.vote_reference.filter(user__id__in=users_pk).delete()</span><br><span class="line"></span><br><span class="line">        users = get_user_model().objects.filter(id__in=users_pk)</span><br><span class="line">        self_type = ContentType.objects.get_for_model(self.__class__)</span><br><span class="line">        ready_records = [VoteReference(</span><br><span class="line">            content_type=self_type, </span><br><span class="line">            object_id=self.id, </span><br><span class="line">            user=user, </span><br><span class="line">            upvote=upvote</span><br><span class="line">        ) <span class="keyword">for</span> user <span class="keyword">in</span> users]</span><br><span class="line">        VoteReference.objects.bulk_create(ready_records)</span><br><span class="line">        <span class="keyword">if</span> upvote:</span><br><span class="line">            self.up_count +=  len(users)</span><br><span class="line">            self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">            self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                up_count=F(<span class="string">'up_count'</span>)+<span class="number">1</span>,</span><br><span class="line">                upvote_rate=self.upvote_rate</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.down_count += len(users)</span><br><span class="line">            self.upvote_rate = self.get_upvote_rate()</span><br><span class="line">            self.__class__.objects.filter(id=self.id).update(</span><br><span class="line">                up_count=F(<span class="string">'down_count'</span>)+<span class="number">1</span>,</span><br><span class="line">                upvote_rate=self.upvote_rate</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ol>
<li>update在执行sql之后不会更新当前实例的值, 因此在update之前先修改当前对象的属性, 以保持数据一致性</li>
<li>使用update而非save, 首先因为update只更新部分值, 比save写入全部属性要快, 其次对应同一记录可能有多个对象副本(例如通过某个外键引用)使用F函数能确保vote操作的结果不被覆盖.</li>
<li>提供两个Manger, 自定义manager:<code>voter</code>字段, 以及通用Manager: <code>objects</code>字段.</li>
<li>使用get_user_model函数, 获得当前认证用户模型本身.(settings.AUTH_USER_MODEL默认为’auth.User’)</li>
<li>提供一个bulk_vote方法, 可以一次操作多个用户的投票操作, 多个用户的操作会在常数次查询中完成.</li>
</ol>
<hr>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设以上代码放置于名为<code>voter</code>的APP的<code>models.py</code>中, 在INTALLED_APPS添加<code>voter</code>之后, 在其他<code>APP</code>中需要投票功能的Model直接继承<code>VoteMixin</code>即可.</p>
<p>例如某个名为<code>post</code>的APP中, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> voter.models <span class="keyword">import</span> VoteMixin</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span><span class="params">(VoteMixin, models.Model)</span>:</span> </span><br><span class="line">    <span class="comment"># VoteMixin本身就继承自models.Model, 但最好仍然显式继承models.Model以确保明晰语义</span></span><br><span class="line">    <span class="comment"># VoteMixin必须置于models.Model之前, 正如任何基类都必须置于object之前, 否则无法构建MRO</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    created = models.DateTimeField(default=timezone.now)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(Post)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'created'</span>, <span class="string">'up_count'</span>, <span class="string">'down_count'</span>, <span class="string">'upvote_rate'</span>]</span><br></pre></td></tr></table></figure>

<p>进入项目目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/project</span><br></pre></td></tr></table></figure>

<p>初始化数据表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>创建用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<p>打开shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> post.models <span class="keyword">import</span> Post</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post = Post.objects.create(title=<span class="string">"test"</span>) <span class="comment">#创建并获得一个Post实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user = User.objects.first() <span class="comment"># 获得某个用户实例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.vote(user, upvote=<span class="literal">True</span>) <span class="comment"># 赞同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.vote(user, upvote=<span class="literal">False</span>) <span class="comment">#反对</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.voteneutral(user) <span class="comment"># 取消赞踩</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.is_upvoted(user) <span class="comment"># 该用户是否赞同了该post</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.is_downvoted(user) <span class="comment"># 用户是否反对了该post</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.get_voted_user(upvote=<span class="literal">True</span>) <span class="comment"># 查询所有赞同过该post的用户</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.get_voted_user(upvote=<span class="literal">False</span>) <span class="comment"># 查询所有反对过该post的用户</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>post.bulk_vote([<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>], upvote=<span class="literal">True</span>) <span class="comment"># 一次操作多个用户</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Post.voter.get_upvoted(user) <span class="comment"># 获得该用户赞同过的Post实例查询集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Post.voter.get_downvoted(user) <span class="comment">#获得该用户反对过的Post实例查询集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Post.voter.get_popular() <span class="comment"># 获得当前被点赞次数最多的Post实例查询集</span></span><br></pre></td></tr></table></figure>

<p>可以同步运行django自带的服务器, 打开admin后台, 查看数据变动.</p>
<hr>
<h3 id="用于多个Model"><a href="#用于多个Model" class="headerlink" title="用于多个Model"></a>用于多个Model</h3><p>如果还有其他任何需要提供赞踩功能的Model, 同样继承VoteMixin即可, 所有赞踩记录都会被保存在同一张表中.</p>
<p>并且同样通过实例的vote/vote_neutral或者Model的<code>voter</code>Manager操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># book/models.py</span></span><br><span class="line"><span class="keyword">from</span> voter.models <span class="keyword">import</span> VoteMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(VoteMixin)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>python manage.py shell</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from django.contrib.auth.models import User</span><br><span class="line">&gt;&gt;&gt; from book.models import Book</span><br><span class="line">&gt;&gt;&gt; book = Book.objects.first()</span><br><span class="line">&gt;&gt;&gt; user = User.objects.first()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; book.vote(user, upvote=True) <span class="comment"># 用户为该书籍点赞</span></span><br><span class="line">&gt;&gt;&gt; Book.voter.get_upvoted(user) <span class="comment"># 获得该用户赞同过的书籍</span></span><br><span class="line">&gt;&gt;&gt; book.is_upvoted(user) <span class="comment"># 该书籍是否被指定用户赞过</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>鉴于Mysql的操作代价较大, 只适合小型项目, 中型以上项目至少应该使用redis作缓存, 然后使用<code>bulk_vote</code>方法进行操作.</p>
]]></content>
      <tags>
        <tag>Django</tag>
        <tag>赞踩系统</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击原理和防御</title>
    <url>/2019/07/02/XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>XSS(Cross Site Script)跨站脚本攻击，属于一种注入攻击，黑客通过”HTML注入”篡改了网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器。</p>
<p>前提条件:</p>
<ol>
<li>向web页面注入恶意html代码</li>
<li>恶意代码能被浏览器成功执行</li>
</ol>
<a id="more"></a>


<p>根据攻击来源不同，XSS分为两类:</p>
<ol>
<li>反射型XSS: 给用户发送页面或者链接，让用户点击来发起攻击，也叫做”非持久型XSS”</li>
<li>存储型XSS: 把攻击存放在服务器端，每个打开网页的用户都自动加载恶意代码，也叫做”持久性XSS”</li>
</ol>
<p>如何防御?</p>
<ol>
<li>避免在cookie中存放重要敏感信息.</li>
<li>进行字符转义，用户输入的信息应当被转义后使用，无论是URL还是表单内容甚至cookie.</li>
<li>表单提交使用post方式而非get方式.</li>
</ol>
]]></content>
      <tags>
        <tag>前端安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF攻击原理和防御</title>
    <url>/2019/07/02/CSRF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>CSRF(Cross-site request forgery) 跨站请求伪造, 也被缩写为XSRF</p>
<p>CSRF的本质是外站盗用用户的身份并伪造成用户发送请求, 造成隐私和财产安全</p>
<a id="more"></a>

<p>实现攻击的原理</p>
<ol>
<li>用户浏览并登录信任网站A</li>
<li>A在浏览器生成Cookie, 并以此来保持在A网站登录状态</li>
<li>在未登出A网站的情况下, 访问了危险网站B</li>
<li>B网站页面中, 通过内嵌的js向A某个url发出请求</li>
<li>既然是访问A页面, 浏览器自动携带由网站A的Cookie</li>
<li>A并不清楚该请求来自何处, 但拥有正确的Cookie, 所以视为用户的操作</li>
<li>该危险请求被A所接受, B成功伪造用户身份, 成功让A网站执行了操作</li>
</ol>
<p>防御CSRF攻击主要可以从两个方面入手, 客户端和服务器端.</p>
<hr>
<h4 id="客户端的防御"><a href="#客户端的防御" class="headerlink" title="客户端的防御"></a>客户端的防御</h4><p>从客户端来说, 用户主要通过浏览器进行对网站的访问, 因此出于安全方面的考虑, 浏览器默认对跨域请求做出限制, 拦截掉所有不同源的请求. </p>
<p>同源策略: <strong>协议</strong>, <strong>域名</strong>, <strong>端口</strong>均相同, 就是同源, 三者任一不同, 则为跨域.</p>
<p>如何做出限制?</p>
<ol>
<li>DOM层面:不同源的js或document, 不可读取或设置当前DOM的属性</li>
<li>Cookie和XMLHttprequest层面: 浏览器直接拦截当前页面中Ajax的跨域请求,  对于同源的Ajax请求, 不可携带与本网站不同源的Cookie</li>
<li><code>&lt;script&gt;&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;</code>等带有src属性的标签不受该限制</li>
<li>其他插件的同源策略</li>
</ol>
<p>在以上的例子中, 在B网站页面中内嵌的js对与其不同源的A网站发起的请求被浏览器拦截, 因此也就无法完成伪造请求. </p>
<hr>
<h4 id="服务器端的防御"><a href="#服务器端的防御" class="headerlink" title="服务器端的防御"></a>服务器端的防御</h4><p>从服务器端来说, 主要方案是在客户端页面增加伪随机数, 并在验证时需要验证该伪随机数, 这样, 在外域直接发起的请求不可能携带该随机数:</p>
<ol>
<li>所有表单包含同一个伪随机数, 且该随机数为一直不变, 例如可以根据用户的cookie算出, 因为B无法访问A在客户端设置的Cookie, 所以B不可能得知正确的伪随机数</li>
<li>每个表单都包含不同的伪随机数, 该伪随机数每次都在变化, 并将每次的伪随机数都保存在服务器端, 并添加一份到表单的隐藏字段中, 只有包含对应的伪随机数的post请求提交到服务器端时, 该请求才被接受</li>
<li>验证码, 用以保证用户的敏感操作需要手动进行.</li>
</ol>
<p>当然, 考虑到用户可能每次都要请求多个表单, 该伪随机数必须支持多个表单并行提交, 而非每次只接受最后一次请求的表单的提交请求. </p>
<hr>
<h4 id="Django的CSRF验证"><a href="#Django的CSRF验证" class="headerlink" title="Django的CSRF验证"></a>Django的CSRF验证</h4><p>Django的csrftoken放置于cookie的<code>csrftoken</code>字段中, 因此任何其他网站不可以访问到csrftoken.</p>
<p>在用户发起请求时, 先访问当前域的cookie, 获得csrftoken, 然后将其包含在表单数据中, 或放置于某个HTTP头中(取决于Django的<code>CSRF_HEADER_NAME</code>设置项).</p>
<p>如果使用Django Template, 则该字段在初始化时就作为隐藏字段被包含在表单中, 在提交时会随之提交.</p>
<hr>
<h4 id="前后端分离项目如何自动包含csrftoken"><a href="#前后端分离项目如何自动包含csrftoken" class="headerlink" title="前后端分离项目如何自动包含csrftoken?"></a>前后端分离项目如何自动包含csrftoken?</h4><p>例如使用axios, 仅需设置如下两行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.xsrfCookieName = <span class="string">'csrftoken'</span></span><br><span class="line">axios.defaults.xsrfHeaderName = <span class="string">"X-CSRFToken"</span></span><br></pre></td></tr></table></figure>

<p>前者设置axios应当从cookies获得csrftoken的字段名, 后者则是应当将csrftoken作为哪个HTTP头中发送.</p>
<p>后者的设置值具体可能还要参考Django的<a href="https://docs.djangoproject.com/en/2.2/ref/settings/#csrf-header-name" target="_blank" rel="noopener"><code>CSRF_HEADER_NAME</code></a>设置项.</p>
<p>这样, 在每个发送请求时, axios都会自动获取csrftoken, 并自动包含csrftoken.</p>
<hr>
<h4 id="在跨域请求时-如何解决csrftoken问题"><a href="#在跨域请求时-如何解决csrftoken问题" class="headerlink" title="在跨域请求时, 如何解决csrftoken问题?"></a>在<strong>跨域</strong>请求时, 如何解决csrftoken问题?</h4><p>跨域时可以指定跨域请求<strong>携带</strong>外域的cookie, 但在当前域内不可以<strong>访问</strong>该cookie, 因此也无法获取该cookie中包含的csrftoken.</p>
<p>即, 跨域请求不可能从cookie中获得csrftoken, 任何获取外域cookie的行为都被浏览器阻止.</p>
<p>如果必须开启CSRF验证, 则需要后端给出csrftoken接口, 跨域请求需要先访问该接口获得csrftoken, 该csrftoken应当包含在响应的<code>body</code>部分, 而非放置在cookie中.</p>
<p>获取到csrftoken后, 将其包含在表单或HTTP头中发起跨域请求.</p>
<hr>
<h4 id="cookie的samesite属性"><a href="#cookie的samesite属性" class="headerlink" title="cookie的samesite属性"></a>cookie的samesite属性</h4><p>cookie的<code>samesite</code>属性是尚未被广泛使用的防御CSRF的设, 该属性可以被设置为三个值:</p>
<ol>
<li><code>Strict</code>: Set-Cookie: CookieName=CookieValue; SameSite=Strict;</li>
<li><code>Lax</code>: Set-Cookie: CookieName=CookieValue; SameSite=Lax;</li>
<li><code>None</code>: Set-Cookie: widget_session=abc123; SameSite=None; Secure</li>
</ol>
<p>设置为<code>Strict</code>时, 任何跨域请求不允许携带cookie.<br>设置为<code>Lax</code>时, 链接, 预加载请求, GET表单请求允许携带cookie<br>设置为<code>None</code>时, 允许在任意请求中携带cookie, 但必须同时设置<code>Secure</code>属性.</p>
<hr>
<p>参考:</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noopener">Cookie 的 SameSite 属性</a><br><a href="https://vsupalov.com/avoid-csrf-errors-axios-django/" target="_blank" rel="noopener">How to avoid CSRF errors with axios and Django?</a><br><a href="https://stackoverflow.com/questions/39254562/csrf-with-django-reactredux-using-axios" target="_blank" rel="noopener">CSRF with Django, React+Redux using Axios</a></p>
]]></content>
      <tags>
        <tag>CSRF</tag>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多继承协同任务</title>
    <url>/2019/06/01/python%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%8D%8F%E5%90%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>理解了python的MRO之后, 我们就可以更加准确地使用super()函数, 以及使用super()完成<strong>多继承协同任务</strong></p>
<p>super().method()是调用父类中的方法, 这个搜索顺序按照MRO从前向后进行.</p>
<a id="more"></a>

<p><code>super([type][, object-or-type])</code></p>
<p>根据官方文档, <code>super</code>函数返回一个委托类<code>type</code>的父类或者兄弟类方法调用的代理对象. <code>super</code>函数用来调用已经在子类中重写过的父类方法. </p>
<p>这句话其实很难看明白, 为什么除了父类还可能是兄弟类?</p>
<p>要理解这句话, 先谈谈<code>super</code>的参数的传入方式不同带来的不同之处</p>
<p>常见的是直接调用<code>super()</code>,这其实是<code>super(type, obj)</code>的简写方式, 将当前的类传入<code>type</code>参数, 同时将实例对象传入<code>type-or-object</code>参数, 这两个实参必须确保<code>isinstance(obj, type)</code>为<code>True</code>. </p>
<p>使用该方法调用的<code>super</code>函数返回的代理类是<code>obj</code>所属类的MRO中, 排在type之后的下一个父类. </p>
<p>示例:<br>类的继承结构如下<br> <img src="https://img2018.cnblogs.com/blog/1249301/201905/1249301-20190525170912709-1726985906.png" alt></p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>类C的MRO为[C, A, B, object]</p>
<p>现在我们为其添加一个方法<code>x()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run A.x'</span>)</span><br><span class="line">		super().x()</span><br><span class="line">		print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run B.x'</span>)</span><br><span class="line">		print(self)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run C.x'</span>)</span><br><span class="line">		super().x()</span><br><span class="line">		print(self)</span><br><span class="line"></span><br><span class="line">C().x()</span><br></pre></td></tr></table></figure>

<p>该方法最先被调用时是作为C的实例方法, 根据MRO, 我们很清楚, 下一步它会调用其MRO父类中的同名方法, 即A中的x()方法, 但是, 我们在A的x()方法中再次使用了super(), 这时候会怎么样呢?</p>
<p>查看结果输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">run C.x</span><br><span class="line">run A.x</span><br><span class="line">run B.x</span><br><span class="line">&lt;__main__.C object at <span class="number">0x000002B5041BB710</span>&gt;</span><br><span class="line">&lt;__main__.C object at <span class="number">0x000002B5041BB710</span>&gt;</span><br><span class="line">&lt;__main__.C object at <span class="number">0x000002B5041BB710</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在调用了A中的<code>x()</code>方法之后, 下一个调用的是B中的<code>x()</code>方法, 在继承结构中, 类A和类B互为兄弟关系, <code>super()</code>在A中调用的时候, 最终却调用其兄弟的同名方法, 这就是之前说的, <em><code>super</code>函数返回一个委托类<code>type</code>的父类或者兄弟类方法调用的代理对象</em>. </p>
<p>那么, 为什么?<br>根据<code>print(self)</code>的输出, 所有在这些<code>super()</code>的调用过程中, self参数传入的是同一个obj, 就是我们初始化的<code>C()</code>, 在内存中位置为<strong>0x000002B5041BB710</strong>的对象. </p>
<p>之前已经说过, <code>super()</code>是<code>super(type, obj)</code>的简写, 在调用<code>super()</code>时, <code>type</code>参数传入的是当前的类, 而<code>obj</code>参数则是默认传入当前的实例对象, 在<code>super()</code>的后续调用中, <code>obj</code>一直未变, 而实际传入的<code>class</code>是动态变化.</p>
<p>即, 在首次调用时, MRO就已经被确定, 是<code>obj</code>所属类(即C)的MRO, 因此<code>class</code>参数的作用就是从已确定的MRO中找到位于其后紧邻的类, 作为再次调用<code>super()</code>时查找该方法的下一个类. </p>
<p>因此, <code>super</code>函数这一部分的核心逻辑应该为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(class, obj)</span>:</span></span><br><span class="line">    mro_list = obj.__class__.mro()</span><br><span class="line">    next_parent_class = mro_list[mro_list.index(<span class="class"><span class="keyword">class</span>)+1]</span></span><br><span class="line"><span class="class">    <span class="title">return</span> <span class="title">next_parent_class</span></span></span><br></pre></td></tr></table></figure>

<p>这就是为什么必须保证<code>isinstance(obj, type)</code>为<code>True</code>的原因, 如果不是, 那么可能<code>type</code>就不存在于<code>obj.__class__</code>的MRO列表中, 该算法就无法正确找到下一个应当被查找的类. </p>
<p>因此, 如果我们在某个类的父类中按照其MRO顺序, 每个父类都写一个同名方法, 同时每个该方法中都继续调用<code>super()</code>, 直到在MRO列表<code>object</code>之前的最后一个类的同名方法中不再调用<code>super()</code>, 那么在调用该方法时, 会在各个父类中按照MRO列表的顺序依次被调用, </p>
<p>这个过程中存在数据的传递, 代表它们之间可以<strong>共享</strong>某些数据, 这就实现了多继承协同工作. </p>
<hr>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>继承结构如下图<br><img src="https://img2018.cnblogs.com/blog/1249301/201905/1249301-20190525173624849-2039140699.png" alt></p>
<p>我们试图达到的目的如下:</p>
<ol>
<li>一个类<code>Final</code>继承<code>Header</code>以获得属性<code>header</code></li>
<li>通过混合其他类来快捷地修饰<code>header</code>属性, 例如继承类<code>Mixin1</code>会为<code>header</code>属性(其数据类型为列表)追加数据<code>data1</code>,而继承类<code>Minix2</code>则会为<code>header</code>属性的头部添加元素<code>data2</code>,注意, 因为这些操作并不冲突, 这些行为都不该相互覆盖. </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minix1</span>:</span></span><br><span class="line">	<span class="string">"""该混合类为header列表末尾添加data1"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run Minix1.get_header'</span>)</span><br><span class="line">		ctx = super().get_header()</span><br><span class="line">		ctx.append(<span class="string">'data1'</span>)</span><br><span class="line">		<span class="keyword">return</span> ctx</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minix2</span>:</span></span><br><span class="line">	<span class="string">"""该混合类为header列表头部添加data2"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run Minix2.get_header'</span>)</span><br><span class="line">		ctx = super().get_header()</span><br><span class="line">		ctx.insert(<span class="number">0</span>, <span class="string">'data2'</span>)</span><br><span class="line">		<span class="keyword">return</span> ctx</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span>:</span></span><br><span class="line">	header = []</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run Headers.get_header'</span>)</span><br><span class="line">		<span class="keyword">return</span> self.header <span class="keyword">if</span> self.header <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span><span class="params">(Minix1, Minix2, Header)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> super().get_header()</span><br></pre></td></tr></table></figure>

<p>当然, 我们可以定义更多的混合类, 并从中选取所需的类来快速得到想要的<code>header</code>属性, 在这个例子中, 这两个混合类已经足够说明问题. </p>
<p>我们现在使用类C的<code>get_header()</code>方法来得到其<code>header</code>属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(Final.mro())</span><br><span class="line"><span class="comment">#[Final, Minix1, Minix2, Header, object]</span></span><br><span class="line">header = Final().get_header()</span><br><span class="line"><span class="comment">#run Minix1.get_header</span></span><br><span class="line"><span class="comment">#run Minix2.get_header</span></span><br><span class="line"><span class="comment">#run Headers.get_header</span></span><br><span class="line">print(header)</span><br><span class="line"><span class="comment">#['data2', 'data1']</span></span><br></pre></td></tr></table></figure>

<p>这样, 我们就实现了多继承<strong>协同</strong>工作的目标, 通过混合不同个类, 模块化地修改<strong>同一个</strong>属性.</p>
<p>而这种工作方法, 通过单纯的重写某个方法根本无法实现的, 因为重写任何方法, 它会在MRO列表中找到最优先(也就是最靠前)的拥有同名方法的类, 然后调用该方法, 并且终止检索, 某项属性仅仅会被<strong>一个</strong>方法所影响. </p>
<p>相关文章或参考:<br><a href="https://www.cnblogs.com/crazyrunning/p/7095014.html" target="_blank" rel="noopener">Python进阶-继承中的MRO与super</a><br><a href="https://blog.csdn.net/weixin_34267123/article/details/89545060" target="_blank" rel="noopener">python 继承与多重继承</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>MRO</tag>
        <tag>super()</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法, Python描述</title>
    <url>/2019/06/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>二分查找算法(<code>binary search algorithm</code>), 也称折半搜索算法, 用于在一个<strong>有序序列</strong>查找目标元素.</p>
<p>搜索过程从数组的中间元素开始, 如果中间元素正好是要查找的元素, 则搜索过程结束; 如果某一特定元素大于或者小于中间元素, 则在数组大于或小于中间元素的那一半中查找, 而且跟开始一样从中间元素开始比较. 如果在某一步骤数组为空, 则代表找不到. 这种搜索算法每一次比较都使搜索范围缩小一半. </p>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#循环结构实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arr, element)</span>:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(arr)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">        mid = (left + right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> element&gt;arr[mid]:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> element&lt;arr[mid]:</span><br><span class="line">            right = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归结构实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arr, left, right, element)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> right&gt;=left:</span><br><span class="line">        mid = (left + right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid]&gt;element:</span><br><span class="line">            <span class="keyword">return</span> binary_search(arr, left, mid<span class="number">-1</span>, element)</span><br><span class="line">        <span class="keyword">elif</span> arr[mid]&lt;element:</span><br><span class="line">            <span class="keyword">return</span> binary_search(arr, mid+<span class="number">1</span>, right, element)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">24</span>, <span class="number">29</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">48</span>, <span class="number">97</span>, <span class="number">111</span>, <span class="number">180</span>, <span class="number">790</span>, <span class="number">1546</span>, <span class="number">6846</span>, <span class="number">31233</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    print(binary_search(array, i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    print(binary_search(array, <span class="number">0</span>, <span class="number">20</span>, i))</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h4><p>对边界的判断包含等号, 以检查所有的元素.</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度为<code>O(log2(n))</code>, 空间复杂度为O(1), </p>
<p>递归实现中空间复杂度为<code>O(log2(n))</code></p>
<hr>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>选择排序的核心思想是划分, 按照某个标准将待排序记录划分为”小记录”和”大记录”, 并通过递归不段划分, 最终得到一个排序序列.</p>
<hr>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, left, right)</span>:</span></span><br><span class="line">    <span class="comment"># 一次划分函数</span></span><br><span class="line">    pivot = arr[left]</span><br><span class="line">    i, j = left, right</span><br><span class="line">    <span class="keyword">while</span> i&lt;j:</span><br><span class="line">        <span class="keyword">while</span> arr[j]&gt;=pivot <span class="keyword">and</span> i&lt;j:</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        arr[i] = arr[j]</span><br><span class="line">        <span class="keyword">while</span> arr[i]&lt;=pivot <span class="keyword">and</span> i&lt;j:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        arr[j] = arr[i]</span><br><span class="line">    <span class="comment"># i, j相遇</span></span><br><span class="line">    arr[i] = pivot</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, left, right)</span>:</span></span><br><span class="line">    <span class="comment"># 快速排序算法</span></span><br><span class="line">    <span class="keyword">if</span> left&lt;right:</span><br><span class="line">        pivot_position = partition(arr, left, right)</span><br><span class="line">        quick_sort(arr, left, pivot_position<span class="number">-1</span>)</span><br><span class="line">        quick_sort(arr, pivot_position+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p>一次划分过程, 会将某个元素作为标准, 将所有更小的元素置于该元素的左侧, 将所有更大的元素置于该元素的右侧, 而该元素所在的位置, 就是其最终位置.<br>首先取出某个元素作为<strong>标准</strong>, 将其暂存于变量中, 这样原位置可以视为一个空位, 初始空位在左侧<br>从最右侧开始逆序比较元素, 直至找到一个比该元素小的元素, 将其与空位交换位置, 这样空位就转移到右侧.<br>从最左侧开始顺序比较元素, 直至找到一个比该元素大的元素, 将其与新空位交换位置, 空位转移到左侧.<br>重复, 直至两侧指针相遇, 该位置即为标准元素的最终位置, 同时, 得到了两个子序列.<br>继续对两个子序列进行划分, 直至子序列被划分为单个元素, 所有元素均得到其最终位置, 排序完成.</p>
<p>值得注意的是, 每当确认了一个元素的最终位置后, 其左右两侧的子序列都不包含该位置.</p>
<hr>
<h4 id="边界条件-1"><a href="#边界条件-1" class="headerlink" title="边界条件"></a>边界条件</h4><p>外层循环, 对边界的比较不包含等号, 因为相等时即找到了最终位置, 应当立即跳出<br>内层循环, 与标准元素的比较包含等号, 因为相等的元素不应该被移动. 而对边界的比较不包含等号, 原因同上.</p>
<hr>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_Quick</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_Quick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">        test_lst = [randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">        self.assertEqual(sorted(test_lst), QuickSort(test_lst, <span class="number">0</span>, len(test_lst)<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>归并排序的本质是合并两个有序表</p>
<p>待排序序列内包含<code>n</code>个元素, 单个元素视为有序, 将元素两两归并, 完成一遍后序列组里的排序序列的个数减半, 每个子序列的长度加倍.</p>
<p>重复进行归并, 直至得到长度为<code>n</code>的有序序列. 这种归并方法称之为<strong>二路归并排序</strong>.</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arr, left, mid, right)</span>:</span></span><br><span class="line">    <span class="string">""" 归并函数 """</span></span><br><span class="line">    temp = arr[:]</span><br><span class="line">    i, j = left, mid+<span class="number">1</span></span><br><span class="line">    k = left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid <span class="keyword">and</span> j&lt;=right:</span><br><span class="line">        <span class="keyword">if</span> temp[i]&lt;temp[j]:</span><br><span class="line">            arr[k] = temp[i]</span><br><span class="line">            i, k = i+<span class="number">1</span>, k+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> temp[j]&lt;temp[i]:</span><br><span class="line">            arr[k] = temp[j]</span><br><span class="line">            j, k = j+<span class="number">1</span>, k+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[k] = arr[k+<span class="number">1</span>] = temp[i]</span><br><span class="line">            i, j, k = i+<span class="number">1</span>, j+<span class="number">1</span>, k+<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid:</span><br><span class="line">        arr[k] = temp[i]</span><br><span class="line">        i, k = i+<span class="number">1</span>, k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=right:</span><br><span class="line">        arr[k] = temp[j]</span><br><span class="line">        j, k = j+<span class="number">1</span>, k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(arr, left, right)</span>:</span></span><br><span class="line">    <span class="string">""" 归并排序 """</span></span><br><span class="line">    <span class="keyword">if</span> left&lt;right:</span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        MergeSort(arr, left, mid)</span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, right)</span><br><span class="line">        merge(arr, left, mid, right)</span><br></pre></td></tr></table></figure>

<p>在归并函数中, 传入一个待排序序列, 但只对该待排序序列的<strong>一部分</strong>进行排序, 即下标由<code>left</code>到<code>right</code>的这一段.<br><strong>这段</strong>待排序序列由两个有序子序列组成, 以位置为<code>mid</code>的元素(包含在前一个子序列中)为界.<br>使用辅助数组<code>temp</code>复制原待排序序列的所有元素, <code>i</code>和<code>j</code>指向辅助数组中两个子序列的首元素<br><code>k</code>指针指向待排序数组的首元素, 并对原待排序序列进行更改.</p>
<hr>
<h4 id="边界条件-2"><a href="#边界条件-2" class="headerlink" title="边界条件"></a>边界条件</h4><p>在归并函数中, 所有对边界的判断均包含等号, 因为要保证所有元素都被遍历到, 因此在边界时不跳出</p>
<p>在归并排序算法中, 对边界的判断不包含等号, 因为当相等时意味着子序列为单元素, 无需进行归并</p>
<hr>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>做完第<code>k</code>遍归并后, 有序子序列的长度将为<code>2</code>的<code>k</code>次幂, 因此完成整个排序所需要做的归并遍数不会多于<code>log2(n+1)</code>, 而在每遍归并中做的比较次数为<code>O(n)</code>, 所以, 总的比较次数和移动次数均为<code>O(nlogn)</code>, 以上算法中使用一个与待排序序列长度相同的辅助表, 所以算法复杂度为<code>O(n)</code>.</p>
<p>该算法不具有适应性.</p>
<hr>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] </span><br><span class="line">array = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">123</span>, <span class="number">34</span>, <span class="number">6</span>]</span><br><span class="line">array = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">354</span>, <span class="number">46</span>, <span class="number">46</span>, <span class="number">465</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">654</span>, <span class="number">54</span>, <span class="number">651</span>, <span class="number">56</span>, <span class="number">16</span>, <span class="number">163</span>, <span class="number">13</span>, <span class="number">1</span>]</span><br><span class="line">MergeSort(array, <span class="number">0</span>, len(array)<span class="number">-1</span>)</span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python MRO及C3线性化算法</title>
    <url>/2019/06/01/python%20MRO%E5%8F%8AC3%E7%BA%BF%E6%80%A7%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Python中的方法解析顺序(Method Resolution Order , MRO)采用C3线性化算法来确定.</p>
<a id="more"></a>

<p>一个类的MRO应当如下确定:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[object] = [object]</span><br><span class="line">L[C(B1…BN)] = [C] + merge(L[B1]…L[BN], [B1, … ,BN])</span><br></pre></td></tr></table></figure>

<p>merge函数接收一组列表, 按照如下方式输出一个列表：</p>
<ol>
<li>检查第一个列表的头元素（如 L[B1] 的头）, 记作 H. </li>
<li>若 H 未出现在其它列表的尾部, 则将其输出, 并将其从所有列表中删除, 然后回到步骤1；否则, 取出下一个列表的头部记作 H, 继续该步骤. </li>
<li>重复上述步骤, 直至列表为空或者不能再找出可以输出的元素. 如果是前一种情况, 则算法结束；如果是后一种情况, 说明无法构建继承关系, Python 会抛出异常. </li>
</ol>
<hr>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>继承关系如下图<br><img src="https://img2018.cnblogs.com/blog/1249301/201905/1249301-20190524235050394-577481731.png" alt></p>
<p>根据上述C3算法的步骤来计算其MRO</p>
<p>首先计算B1的MRO:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[B1(A1,A2)] = [B1] + merge(L[A1], L(A2), [A1, A2])</span><br><span class="line">             = [B1] + merge([A1,Obj], [A2,Obj], [A1,A2])</span><br><span class="line">             = [B1, A1] + merge([Obj], [A2,Obj], [A2])</span><br><span class="line">             = [B1, A1, A2] + merge([Obj], [Obj])</span><br><span class="line">             = [B1, A1, A2, Obj]</span><br></pre></td></tr></table></figure>

<p>同理,计算B2的MRO(过程略):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[B2(A3)] = [B2, A3, Obj]</span><br></pre></td></tr></table></figure>

<p>最终计算并得到C的MRO</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[C(B1,B2)] = [C] + merge(L[B1(A1,A2)], L[B2(A3)], [B1,B2])</span><br><span class="line">            = [C] + merge([B1, A1, A2, Obj], [B2, A3, Obj], [B1,B2])</span><br><span class="line">            = [C, B1] + merge([A1, A2, Obj], [B2, A3, Obj], [B2])</span><br><span class="line">            = [C, B1, A1] + merge([A2, Obj], [B2, A3, Obj], [B2])</span><br><span class="line">            = [C, B1, A1, A2] + merge([Obj], [B2, A3, Obj], [B2])</span><br><span class="line">            = [C, B1, A1, A2, B2] +merge([Obj], [A3, Obj])</span><br><span class="line">            = [C, B1, A1, A2, B2, A3] +merge([Obj], [Obj])</span><br><span class="line">            = [C, B1, A1, A2, B2, A3, Obj]</span><br></pre></td></tr></table></figure>

<p>根据C3算法成功构建了MRO, 所以这个类的继承关系是被允许的, 而且根据MRO可以明确地指出应当如何去查找其父类的属性/方法, 即按照MRO列表由前向后的顺序来查找. </p>
<p>当然, 我们完全没有必要去计算这个序列, 直接使用类方法<code>.mro()</code>即可查看该类的MRO:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.mro()</span><br><span class="line"></span><br><span class="line">[&lt;class '__main__.C'&gt;, &lt;class '__main__.B1'&gt;, &lt;class '__main__.A1'&gt;, &lt;class '__main__.A2'&gt;, &lt;class '__main__.B2'&gt;, &lt;class '__main__.A3'&gt;, &lt;class 'object'&gt;]</span><br></pre></td></tr></table></figure>

<p>与我们计算的结果是相同的. </p>
<p>正确理解MRO是使用多重继承和super()完成多继承类协作任务的基础.</p>
<hr>
<p>参考:  </p>
<p><a href="https://www.cnblogs.com/whatisfantasy/p/6046991.html" target="_blank" rel="noopener">Python的方法解析顺序(MRO)[转]</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>MRO</tag>
      </tags>
  </entry>
  <entry>
    <title>Epoll IO多路复用模型</title>
    <url>/2019/04/21/Epoll%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="Send和Recv做了什么"><a href="#Send和Recv做了什么" class="headerlink" title="Send和Recv做了什么"></a>Send和Recv做了什么</h3><p><code>send</code>和<code>recv</code>只是内核缓冲区和应用程序缓冲区之间的搬运工, 严格来讲<code>send()</code>和<code>recv()</code>并不具备发送和接收功能. </p>
<p>当我们调用<code>send</code>时, 是将应用程序缓冲区的数据拷贝到内核缓冲区, 内核缓冲区的数据通过网卡, 穿过网络, 传输到另一侧主机的网卡上, 然后进入另一侧主机内核缓冲区, 然后由程序调用<code>recv</code>将数据取回应用程序缓冲区. </p>
<a id="more"></a>

<hr>
<h3 id="程序阻塞于recv调用"><a href="#程序阻塞于recv调用" class="headerlink" title="程序阻塞于recv调用"></a>程序阻塞于recv调用</h3><p>在网络编程中, <code>send</code>之后立即尝试使用<code>recv</code>接收数据, 从调用<code>recv</code>到得到结果, 等待时间分为两部分</p>
<ol>
<li>对方回复数据尚未到达, 因此完全无数据可读的时间</li>
<li>对方回复数据已到达, 将数据从内核缓冲区取回应用程序缓冲区的时间</li>
</ol>
<p>鉴于真实的网络环境, 第1段的时间远远大于第2段的时间. </p>
<p>在阻塞IO的情况下, 我们必须等待这两段时间, 而在这期间, 程序只能让出处理机. </p>
<p><img src="https://img-blog.csdnimg.cn/20190703163701716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L255YW5fcGFzcw==,size_16,color_FFFFFF,t_70" alt="同步阻塞IO模型"></p>
<hr>
<h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><p>操作将I/O状态的变化封装为事件, 并提供了专门的系统模块<code>select</code>来让应用程序可以接收事件通知, <code>Epoll</code>是改进版的<code>select</code>. </p>
<p>应用程序可以通过<code>epoll</code>注册文件描述符和回调函数, 由epoll负责监测这些文件的I/O变化. </p>
<p>当进行epoll调用时, epoll就返回可用的(指可读/可写, 取决于注册时要求监听的事件类型)文件描述符, 程序就可以获得已就绪的文件. </p>
<p>调用epoll的过程是阻塞的, 但除非<strong>所有</strong>注册文件所等待的事件均没有发生时, epoll调用才会令程序阻塞, 只要有<strong>任意</strong>一个等待的事件发生, epoll就将其返回给程序. </p>
<p>因此, 程序在<code>send</code>之后, 不再自己尝试<code>recv</code>, 而是将其注册入epoll,然后继续执行, 程序可以继续将多个文件描述符及其等待的事件注册入epoll, 然后在恰当的时机(例如完成本轮循环后)通过epoll调用来获取就绪的文件描述符.</p>
<p>当程序获得就绪的文件描述符时, 就可以直接调用recv来从内存缓冲区中拷贝数据到应用程序缓冲区. 这样我们只需要等待上述的<strong>第2段</strong>时间.</p>
<p>通过epoll来监测<strong>多个</strong>事件, 而只要<strong>任意一个</strong>事件发生, 程序就不会被阻塞, 这就是所谓<strong>多路复用</strong>. </p>
<p><img src="https://img-blog.csdnimg.cn/20190703171840419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L255YW5fcGFzcw==,size_16,color_FFFFFF,t_70" alt="多路复用IO模型"></p>
<p>(<em>即使一直没有事件发生, 仍然可以通过超时参数来结束epoll调用的阻塞</em>)</p>
<p>需要说明的是, epoll并非在被调用时才去轮询其监测的事件, 而是在事件就绪时就由内核将文件描述符放置入一个内置数组中, 当调用时直接从该数组复制数据.</p>
<hr>
<h3 id="边缘触发-ET-和水平触发-LT"><a href="#边缘触发-ET-和水平触发-LT" class="headerlink" title="边缘触发(ET)和水平触发(LT)"></a>边缘触发(ET)和水平触发(LT)</h3><p>一个事件被epoll获取之后, 如果程序没有将与之相关的套接字缓冲区处理完毕(例如epoll在报告了某个socket可读事件以后, 程序并没有一次读取完其中的数据), 如果其工作方式为:</p>
<ol>
<li>水平触发(<code>Level Triggered</code>), 在下次epoll调用时, 仍然报告该事件, 默认工作方式, 减少可能出现的编程错误</li>
<li>边缘触发(<code>Edge Triggered</code>), 在下次epoll调用时, 不会报告该事件, 高速工作方式, 效率较高</li>
</ol>
<hr>
<h3 id="Epoll系统调用和工作原理"><a href="#Epoll系统调用和工作原理" class="headerlink" title="Epoll系统调用和工作原理"></a>Epoll系统调用和工作原理</h3><ol>
<li><code>epoll_create()</code>创建一个epoll句柄</li>
<li><code>epoll_ctl()</code>注册文件描述符、对应的等待的事件, 以及触发方式到epoll句柄中</li>
<li><code>epoll_wait()</code>收集在epoll监控的事件中已经发生的事件, 返回值为一个整型</li>
</ol>
<p>调用<code>epoll_wait</code>, 需要传入一个epoll句柄, 一个结构体数组(<code>epoll_event</code>)的指针, 该数组的大小和超时时间. 结构体可以存储事件及其对应的文件描述符等相关信息, 每个结构体存放一个事件. </p>
<p>epoll是<strong>基于事件的就绪通知方式</strong>, 使用红黑树来存储监听的事件, 当一个事件发生时, 由<strong>内核</strong>调用一个回调, 激活这个文件描述符, 并将激活的文件描述符取出添加到一个双向链表中. <code>epoll_wait</code>则会检查该链表, 将就绪的事件复制入<code>epoll_event</code>数组中, 然后返回一个整型, 代表在<code>epoll_event</code>数组中就绪的描述符的数量, 程序只需要去该数组中取出所需的文件描述符即可.</p>
<hr>
<h3 id="与select不同之处"><a href="#与select不同之处" class="headerlink" title="与select不同之处"></a>与select不同之处</h3><h4 id="文件描述符数量限制"><a href="#文件描述符数量限制" class="headerlink" title="文件描述符数量限制:"></a>文件描述符数量限制:</h4><ul>
<li><code>select</code>: 2048</li>
<li><code>epoll</code>: 内存耗尽前无上限</li>
</ul>
<h4 id="对事件的检测方式"><a href="#对事件的检测方式" class="headerlink" title="对事件的检测方式"></a>对事件的检测方式</h4><p><code>select</code>: 在进行<code>select</code>调用时, 将所有文件描述符传递给select(也就是复制到内核态), 再以轮询的方式检测, 获得可用文件描述符的时间复杂度是O(n). </p>
<p><code>epoll</code>: 先通过<code>epoll_ctl</code>将文件描述符告知内核, 这样就彻底省掉了每次调用都要复制文件描述符到内核态的开销. 并且通过内核的类回调机制来激活文件描述符, 无需进行轮询, 获得可用文件描述符的时间复杂度是O(1). </p>
<p>鉴于以上特性, epoll可以高效处理数以百万计的socket句柄, 与select相比有飞跃般的提升. </p>
<hr>
<h3 id="Nginx相关"><a href="#Nginx相关" class="headerlink" title="Nginx相关"></a>Nginx相关</h3><p>严格来说Epoll是同步阻塞模型, 因为在进行IO操作时还是要阻塞, 只是可以实现单线程内的<strong>IO复用</strong>.</p>
<p>也正是因为如此, Nginx的worker进程数量通常应当与处理机数量保持一致, 但如果任务是IO密集型, 就要启动比处理机数量略多的worker进程(1.5到2倍之间). </p>
<hr>
<p>参考<br><a href="https://www.cnblogs.com/lojunren/p/3856290.html" target="_blank" rel="noopener">Linux下的I/O复用与epoll详解</a><br><a href="https://blog.csdn.net/stpeace/article/details/43719449" target="_blank" rel="noopener">send和recv</a><br><a href="https://www.programering.com/a/MDOxgzMwATQ.html" target="_blank" rel="noopener">Five kinds of I/O model under Unix</a><br><a href="https://www.cnblogs.com/longjiang-uestc/p/9605283.html" target="_blank" rel="noopener">epoll机制详解</a></p>
<!-- more -->]]></content>
      <tags>
        <tag>Epoll</tag>
        <tag>IO多路复用模型</tag>
      </tags>
  </entry>
  <entry>
    <title>DjangoCBV 处理流程及源码分析</title>
    <url>/2019/03/21/Django%20CBV/</url>
    <content><![CDATA[<p>如果要在Django的View中复用一些逻辑, 传统风格的请求处理函数需要使用装饰器, 但基于装饰器的代码复用程度不高, 而且灵活性不足.</p>
<p>因此, 使用基于类的视图(CBV)是最佳选择, 通过继承不同的混入类(<code>Mixin</code>)为视图增加模块化功能, 非常方便.</p>
<a id="more"></a>

<hr>
<h3 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>:</span></span><br><span class="line">    http_method_names = [<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>, <span class="string">'delete'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>, <span class="string">'trace'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            setattr(self, key, value)</span><br></pre></td></tr></table></figure>

<p>View的初始化方法, 该方法的逻辑十分简单, 接收任意关键字参数, 并将其设置为实例的属性和值.</p>
<p>该方法会在<code>as_view</code>方法中定义的<code>view</code>函数执行时调用.</p>
<hr>
<h3 id="as-view"><a href="#as-view" class="headerlink" title="as_view"></a>as_view</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classonlymethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls, **initkwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> initkwargs:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> cls.http_method_names:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"You tried to pass in the %s method name as a "</span></span><br><span class="line">                            <span class="string">"keyword argument to %s(). Don't do that."</span></span><br><span class="line">                            % (key, cls.__name__))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, key):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"%s() received an invalid keyword %r. as_view "</span></span><br><span class="line">                            <span class="string">"only accepts arguments that are already "</span></span><br><span class="line">                            <span class="string">"attributes of the class."</span> % (cls.__name__, key))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">        self = cls(**initkwargs)</span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'get'</span>) <span class="keyword">and</span> <span class="keyword">not</span> hasattr(self, <span class="string">'head'</span>):</span><br><span class="line">            self.head = self.get</span><br><span class="line">        self.setup(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'request'</span>):</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(</span><br><span class="line">                <span class="string">"%s instance has no 'request' attribute. Did you override "</span></span><br><span class="line">                <span class="string">"setup() and forget to call super()?"</span> % cls.__name__</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line">    view.view_class = cls</span><br><span class="line">    view.view_initkwargs = initkwargs</span><br><span class="line">    update_wrapper(view, cls, updated=())</span><br><span class="line">    update_wrapper(view, cls.dispatch, assigned=())</span><br><span class="line">    <span class="keyword">return</span> view</span><br></pre></td></tr></table></figure>

<p><code>as_view</code>是处理请求的主要入口, 它是一个类方法, 实际返回的是一个传统风格的view函数, 该view函数将被作为请求处理函数.</p>
<p>首先检查在<code>as_view</code>调用时传入的关键字参数, 这些参数的键不能与某个http方法同名, 而且键名必须是类的某个属性名.</p>
<p>前者是为了防止直接更改掉实际的处理方法, 后者则是防止为类<strong>新添加</strong>属性, 因为这些关键字参数都将被用于实例化View. </p>
<p>所有的属性都应该的View定义时实现, 如果允许新添加属性/方法可能造成处理逻辑分散, 因此有必要限定as_view传参的方式仅能做有限的修改.</p>
<p>之后定义<code>view</code>函数, 该函数首先使用as_view方法接收的关键字参数实例化一个View实例(<code>self = cls(**initkwargs)</code>), <code>View</code>的<code>__init__</code>方法也在此处被调用, 将该实例命名为<code>self</code>. </p>
<p>然后使用<code>setup</code>方法将request和view接收到的所有关键字参数作为添加至实例的属性, 之后调用<code>dispatch</code>找到与request.method同名的实例方法, 然后将request和所有参数解构传值, 将其返回值作为自己的返回值返回.</p>
<p>在启动项目时, as_view()就被调用. 而当请求被处理时, view才开始执行.</p>
<hr>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        handler = self.http_method_not_allowed</span><br><span class="line">    <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>dispatch首先检查请求的http方法是否被允许, 如果允许, 检查是否有与请求的method对应的同名实例方法, 如果有, 将其作为handler, 如果没有对应的同名实例方法, 将<code>http_method_not_allowed</code>作为handler</p>
<p>如果该method不被允许, 也将<code>http_method_not_allowed</code>作为handler</p>
<p>最后调用handler处理请求并返回结果.</p>
<hr>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdnimg.cn/20191019193418869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L255YW5fcGFzcw==,size_16,color_FFFFFF,t_70" alt="流程图"></p>
<hr>
<p><a href="http://ccbv.co.uk/" target="_blank" rel="noopener">http://ccbv.co.uk/</a></p>
<hr>
<h3 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span>:</span></span><br><span class="line">    http_method_names = [<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>, <span class="string">'delete'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>, <span class="string">'trace'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            setattr(self, key, value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classonlymethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls, **initkwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Main entry point for a request-response process."""</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> initkwargs:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> cls.http_method_names:</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">"You tried to pass in the %s method name as a "</span></span><br><span class="line">                                <span class="string">"keyword argument to %s(). Don't do that."</span></span><br><span class="line">                                % (key, cls.__name__))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, key):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">"%s() received an invalid keyword %r. as_view "</span></span><br><span class="line">                                <span class="string">"only accepts arguments that are already "</span></span><br><span class="line">                                <span class="string">"attributes of the class."</span> % (cls.__name__, key))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">            self = cls(**initkwargs)</span><br><span class="line">            <span class="keyword">if</span> hasattr(self, <span class="string">'get'</span>) <span class="keyword">and</span> <span class="keyword">not</span> hasattr(self, <span class="string">'head'</span>):</span><br><span class="line">                self.head = self.get</span><br><span class="line">            self.setup(request, *args, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'request'</span>):</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(</span><br><span class="line">                    <span class="string">"%s instance has no 'request' attribute. Did you override "</span></span><br><span class="line">                    <span class="string">"setup() and forget to call super()?"</span> % cls.__name__</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line">        view.view_class = cls</span><br><span class="line">        view.view_initkwargs = initkwargs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># take name and docstring from class</span></span><br><span class="line">        update_wrapper(view, cls, updated=())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and possible attributes set by decorators</span></span><br><span class="line">        <span class="comment"># like csrf_exempt from dispatch</span></span><br><span class="line">        update_wrapper(view, cls.dispatch, assigned=())</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize attributes shared by all view methods."""</span></span><br><span class="line">        self.request = request</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Try to dispatch to the right method; if a method doesn't exist,</span></span><br><span class="line">        <span class="comment"># defer to the error handler. Also defer to the error handler if the</span></span><br><span class="line">        <span class="comment"># request method isn't on the approved list.</span></span><br><span class="line">        <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line">        <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">http_method_not_allowed</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        logger.warning(</span><br><span class="line">            <span class="string">'Method Not Allowed (%s): %s'</span>, request.method, request.path,</span><br><span class="line">            extra=&#123;<span class="string">'status_code'</span>: <span class="number">405</span>, <span class="string">'request'</span>: request&#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> HttpResponseNotAllowed(self._allowed_methods())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">options</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Handle responding to requests for the OPTIONS HTTP verb."""</span></span><br><span class="line">        response = HttpResponse()</span><br><span class="line">        response[<span class="string">'Allow'</span>] = <span class="string">', '</span>.join(self._allowed_methods())</span><br><span class="line">        response[<span class="string">'Content-Length'</span>] = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_allowed_methods</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [m.upper() <span class="keyword">for</span> m <span class="keyword">in</span> self.http_method_names <span class="keyword">if</span> hasattr(self, m)]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Django</tag>
        <tag>CBV</tag>
      </tags>
  </entry>
  <entry>
    <title>Django请求处理流程</title>
    <url>/2019/03/20/Django%E8%AF%B7%E6%B1%82%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>每收到一次请求, Django生成一个<code>WSGIHander</code>类型的handler, 然后由其控制请求的处理流程:</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIHandler</span><span class="params">(base.BaseHandler)</span>:</span></span><br><span class="line">    initLock = Lock()</span><br><span class="line">    request_class = WSGIRequest</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="comment"># 加载中间件</span></span><br><span class="line">        <span class="keyword">if</span> self._request_middleware <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">with</span> self.initLock:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># Check that middleware is still uninitialized.</span></span><br><span class="line">                    <span class="keyword">if</span> self._request_middleware <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        self.load_middleware()</span><br><span class="line">                        <span class="comment"># 加载中间件, 并建立中间件的和View的调用链, 设置`_middleware_chain属性为一个handler.</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="comment"># Unload whatever middleware we got</span></span><br><span class="line">                    self._request_middleware = <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        set_script_prefix(get_script_name(environ))</span><br><span class="line">        <span class="comment"># 请求处理之前发送信号</span></span><br><span class="line">        signals.request_started.send(sender=self.__class__, environ=environ)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request = self.request_class(environ)</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            logger.warning(<span class="string">'Bad Request (UnicodeDecodeError)'</span>,</span><br><span class="line">                exc_info=sys.exc_info(),</span><br><span class="line">                extra=&#123;<span class="string">'status_code'</span>: <span class="number">400</span>,&#125;)</span><br><span class="line">            response = http.HttpResponseBadRequest()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            response = self.get_response(request)</span><br><span class="line"></span><br><span class="line">        response._handler_class = self.__class__</span><br><span class="line"></span><br><span class="line">        status = <span class="string">'%s %s'</span> % (response.status_code, response.reason_phrase)</span><br><span class="line">        response_headers = [(str(k), str(v)) <span class="keyword">for</span> k, v <span class="keyword">in</span> response.items()]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> response.cookies.values():</span><br><span class="line">            response_headers.append((str(<span class="string">'Set-Cookie'</span>), str(c.output(header=<span class="string">''</span>))))</span><br><span class="line">        <span class="comment"># server提供的回调方法，将响应的header和status返回给server</span></span><br><span class="line">        start_response(force_str(status), response_headers)</span><br><span class="line">        <span class="keyword">if</span> getattr(response, <span class="string">'file_to_stream'</span>, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> environ.get(<span class="string">'wsgi.file_wrapper'</span>):</span><br><span class="line">            response = environ[<span class="string">'wsgi.file_wrapper'</span>](response.file_to_stream)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>在<code>load_middleware</code>中用中间件层层包装<code>_get_response</code>, 并因此而设置各个中间件和view的内外洋葱状关系, 最后将包装好的handler放入<code>_middleware_chain</code>中等待调用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHandler</span>:</span></span><br><span class="line">    _view_middleware = <span class="literal">None</span></span><br><span class="line">    _template_response_middleware = <span class="literal">None</span></span><br><span class="line">    _exception_middleware = <span class="literal">None</span></span><br><span class="line">    _middleware_chain = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_middleware</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Populate middleware lists from settings.MIDDLEWARE.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Must be called after the environment is fixed (see __call__ in subclasses).</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._view_middleware = []</span><br><span class="line">        self._template_response_middleware = []</span><br><span class="line">        self._exception_middleware = []</span><br><span class="line"></span><br><span class="line">        handler = convert_exception_to_response(self._get_response)</span><br><span class="line">        <span class="comment"># convert_exception_to_response装饰器保证所有_get_response可能抛出的错误都会被转为response</span></span><br><span class="line">        <span class="comment"># hander为包装后的`_get_response`方法</span></span><br><span class="line">        <span class="keyword">for</span> middleware_path <span class="keyword">in</span> reversed(settings.MIDDLEWARE):</span><br><span class="line">            <span class="comment"># 用所有中间件对handler进行层层包装</span></span><br><span class="line"></span><br><span class="line">            middleware = import_string(middleware_path)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                mw_instance = middleware(handler)</span><br><span class="line">                <span class="comment"># mw_instance 是用handler初始化的middware实例.</span></span><br><span class="line">            <span class="keyword">except</span> MiddlewareNotUsed <span class="keyword">as</span> exc:</span><br><span class="line">                <span class="keyword">if</span> settings.DEBUG:</span><br><span class="line">                    <span class="keyword">if</span> str(exc):</span><br><span class="line">                        logger.debug(<span class="string">'MiddlewareNotUsed(%r): %s'</span>, middleware_path, exc)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        logger.debug(<span class="string">'MiddlewareNotUsed: %r'</span>, middleware_path)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mw_instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">                    <span class="string">'Middleware factory %s returned None.'</span> % middleware_path</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> hasattr(mw_instance, <span class="string">'process_view'</span>):</span><br><span class="line">                self._view_middleware.insert(<span class="number">0</span>, mw_instance.process_view)</span><br><span class="line">            <span class="keyword">if</span> hasattr(mw_instance, <span class="string">'process_template_response'</span>):</span><br><span class="line">                self._template_response_middleware.append(mw_instance.process_template_response)</span><br><span class="line">            <span class="keyword">if</span> hasattr(mw_instance, <span class="string">'process_exception'</span>):</span><br><span class="line">                self._exception_middleware.append(mw_instance.process_exception)</span><br><span class="line"></span><br><span class="line">            handler = convert_exception_to_response(mw_instance)</span><br><span class="line">        <span class="comment"># 将所有中间件层层包装后的heander返回, 该handler包含了所有中间件逻辑和_get_response逻辑.</span></span><br><span class="line">        self._middleware_chain = handler</span><br></pre></td></tr></table></figure>

<p><code>convert_exception_to_response</code>是一个标准的装饰器, 确保所有的错误都被处理.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_exception_to_response</span><span class="params">(get_response)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(get_response)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = get_response(request)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            response = response_for_exception(request, exc)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> inner </span><br><span class="line">    <span class="comment"># 返回内层函数. inner即warpper.</span></span><br></pre></td></tr></table></figure>

<p>附上middleware源码格式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleMiddleware</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, get_response)</span>:</span></span><br><span class="line">        self.get_response = get_response</span><br><span class="line">        <span class="comment"># One-time configuration and initialization.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># Code to be executed for each request before</span></span><br><span class="line">        <span class="comment"># the view (and later middleware) are called.</span></span><br><span class="line"></span><br><span class="line">        response = self.get_response(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Code to be executed for each request/response after</span></span><br><span class="line">        <span class="comment"># the view is called.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>核心处理函数<code>self._get_response</code>逻辑如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_response</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Resolve and call the view, then apply view, exception, and</span></span><br><span class="line"><span class="string">    template_response middleware. This method is everything that happens</span></span><br><span class="line"><span class="string">    inside the request/response middleware.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    response = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载URLconf</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(request, <span class="string">'urlconf'</span>):</span><br><span class="line">        urlconf = request.urlconf</span><br><span class="line">        set_urlconf(urlconf)</span><br><span class="line">        resolver = get_resolver(urlconf)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        resolver = get_resolver()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按顺序匹配URLconf中的URLpatterns</span></span><br><span class="line">    resolver_match = resolver.resolve(request.path_info)</span><br><span class="line">    callback, callback_args, callback_kwargs = resolver_match</span><br><span class="line">    request.resolver_match = resolver_match</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果在中间件中有对view函数的处理方法, 先调用这些方法.</span></span><br><span class="line">    <span class="keyword">for</span> middleware_method <span class="keyword">in</span> self._view_middleware:</span><br><span class="line">        response = middleware_method(request, callback, callback_args, callback_kwargs)</span><br><span class="line">        <span class="keyword">if</span> response:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 如果任一中间件在process_view方法中直接返回了响应, 则终止处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用View, callback即view</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        wrapped_callback = self.make_view_atomic(callback)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = wrapped_callback(request, *callback_args, **callback_kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            response = self.process_exception_by_middleware(e, request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Complain if the view returned None (a common error).</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> isinstance(callback, types.FunctionType):    <span class="comment"># FBV</span></span><br><span class="line">            view_name = callback.__name__</span><br><span class="line">        <span class="keyword">else</span>:                                           <span class="comment"># CBV</span></span><br><span class="line">            view_name = callback.__class__.__name__ + <span class="string">'.__call__'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">"The view %s.%s didn't return an HttpResponse object. It "</span></span><br><span class="line">            <span class="string">"returned None instead."</span> % (callback.__module__, view_name)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果响应支持`render`方法, 即模板响应, 则应用模板响应中间件, 并调用`render`方法</span></span><br><span class="line">    <span class="keyword">elif</span> hasattr(response, <span class="string">'render'</span>) <span class="keyword">and</span> callable(response.render):</span><br><span class="line">        <span class="keyword">for</span> middleware_method <span class="keyword">in</span> self._template_response_middleware:</span><br><span class="line">            response = middleware_method(request, response)</span><br><span class="line">            <span class="comment"># Complain if the template response middleware returned None (a common error).</span></span><br><span class="line">            <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">"%s.process_template_response didn't return an "</span></span><br><span class="line">                    <span class="string">"HttpResponse object. It returned None instead."</span></span><br><span class="line">                    % (middleware_method.__self__.__class__.__name__)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = response.render()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            response = self.process_exception_by_middleware(e, request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>最后, 通过<code>self.get_response</code>调用<code>_middleware_chain</code>(即包装好的handler), 逻辑如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHandler</span>:</span></span><br><span class="line">    _view_middleware = <span class="literal">None</span></span><br><span class="line">    _template_response_middleware = <span class="literal">None</span></span><br><span class="line">    _exception_middleware = <span class="literal">None</span></span><br><span class="line">    _middleware_chain = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""Return an HttpResponse object for the given HttpRequest."""</span></span><br><span class="line">        <span class="comment"># Setup default url resolver for this thread</span></span><br><span class="line">        set_urlconf(settings.ROOT_URLCONF)</span><br><span class="line">        response = self._middleware_chain(request)</span><br><span class="line">        <span class="comment">### 使用包含了中间件和View调用链的handler来处理request</span></span><br><span class="line">        response._closable_objects.append(request)</span><br><span class="line">        <span class="keyword">if</span> response.status_code &gt;= <span class="number">400</span>:</span><br><span class="line">            log_response(</span><br><span class="line">                <span class="string">'%s: %s'</span>, response.reason_phrase, request.path,</span><br><span class="line">                response=response,</span><br><span class="line">                request=request,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>至此, WSGIHandler实例获得响应, 然后通过<code>start_response</code>方法返回响应头, 最后返回响应本体.</p>
<p>处理流程: 加载中间件, 并获得自动按顺序调用中间件和view的handler, 之后使用hander处理请求, 获得响应, <code>start_response</code>返回响应头, 最终返回响应本身.</p>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django缓存系统</title>
    <url>/2019/03/18/Django%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>使用缓存可以降低动态生成响应的代价.</p>
<a id="more"></a>

<h2 id="设置缓存方式"><a href="#设置缓存方式" class="headerlink" title="设置缓存方式"></a>设置缓存方式</h2><ol>
<li>内存数据库, mencached, redis 等.</li>
<li>数据库, mysql等.</li>
<li>文件系统.</li>
</ol>
<h4 id="使用内存数据库进行缓存"><a href="#使用内存数据库进行缓存" class="headerlink" title="使用内存数据库进行缓存:"></a>使用内存数据库进行缓存:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">	<span class="string">'default'</span>:&#123;</span><br><span class="line">		<span class="string">'BACKEND'</span>:<span class="string">'django.core.cache.backends.memcached.MemcachedCache'</span>,</span><br><span class="line">		<span class="string">'LOCATION'</span>:[</span><br><span class="line">			<span class="string">'172.19.26.240:11211'</span>,</span><br><span class="line">			<span class="string">'172.19.26.241:11211'</span></span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CACHES</code>项中可以包含多个缓存, 每个缓存由缓存别名作区分, 默认缓存别名为<code>default</code>.<br><code>BACKEND</code>指定django用来连接MemcachedCache的模块(经过django二次封装)<br><code>LOCATION</code> 指定目标数据库的连接地址和端口, 可有多个</p>
<hr>
<h4 id="使用数据库缓存"><a href="#使用数据库缓存" class="headerlink" title="使用数据库缓存"></a>使用数据库缓存</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">	<span class="string">'default'</span>:&#123;</span><br><span class="line">		<span class="string">'BACKEND'</span>:<span class="string">'django.core.cache.backends.db.DatabaseCache'</span>,</span><br><span class="line">		<span class="string">'LOCATION'</span>:<span class="string">'my_cache_table'</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的数据库是设置项中的<code>database</code>项指定, <code>BACKEND</code>指定进行数据库缓存的引擎, <code>LOCATION</code>指定的是缓存使用的表名</p>
<hr>
<h4 id="使用文件系统缓存"><a href="#使用文件系统缓存" class="headerlink" title="使用文件系统缓存"></a>使用文件系统缓存</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">	<span class="string">'default'</span>:&#123;</span><br><span class="line">		<span class="string">'BACKEND'</span>:<span class="string">'django.core.cache.backends.filebased.FileBasedCache'</span>,</span><br><span class="line">		<span class="string">'LOCATION'</span>:<span class="string">'file_path'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="额外的缓存项设置"><a href="#额外的缓存项设置" class="headerlink" title="额外的缓存项设置"></a>额外的缓存项设置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TIMEOUT:<span class="number">100</span>,</span><br><span class="line">OPTIONS:&#123;</span><br><span class="line">    MAX_ENTRIES:<span class="number">100</span>, <span class="comment">#最大缓存记录数</span></span><br><span class="line">    CULL_FREQUENCY: <span class="number">10</span>, <span class="comment">#每次到达最大缓存数量时剔出缓存的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="设置缓存范围"><a href="#设置缓存范围" class="headerlink" title="设置缓存范围"></a>设置缓存范围</h2><ol>
<li>全站缓存</li>
<li>视图缓存</li>
<li>路由缓存</li>
<li>模板缓存</li>
</ol>
<h4 id="全站缓存"><a href="#全站缓存" class="headerlink" title="全站缓存"></a>全站缓存</h4><p>在中间件中添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django.middleware.cache.UpdateCacheMiddleware</span><br><span class="line">django.middleware.cache.FetchFromCacheMiddleware</span><br></pre></td></tr></table></figure>

<p>然后通过设置项指定缓存行为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHE_MIDDLEWARE_SECONDS = <span class="number">10</span> <span class="comment">#设置缓存时间</span></span><br><span class="line">CACHE_MIDDLEWARE_ALIAS = <span class="string">'default'</span> <span class="comment">#设置别名为default的缓存设置进行缓存</span></span><br><span class="line">CACHE_MIDDLEWARE_KEY_PREFIX  = <span class="string">'xxx'</span> <span class="comment">#设置缓存表字段cache_key的前缀, 用于同一个django项目多个站点之间的共享缓存.</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="视图缓存"><a href="#视图缓存" class="headerlink" title="视图缓存"></a>视图缓存</h4><p>使用<code>cache_page</code>装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache_page(timeout=10, cache='default', key_prefix='nyanpass_cache_0')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_function</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>cache_page</code>的参数含义:</p>
<ol>
<li><code>timeout</code>: 超时时间</li>
<li><code>cache</code>: 指定缓存别名</li>
<li><code>key_prefix</code>: 指定缓存表中使用的键前缀</li>
</ol>
<hr>
<h4 id="路由缓存"><a href="#路由缓存" class="headerlink" title="路由缓存"></a>路由缓存</h4><p>将<code>cache_page</code>装饰器用在urlconf中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'url_path'</span>,cache_page(timout=<span class="number">10</span>,cache=<span class="string">'default'</span>,key_prefix=<span class="string">'...'</span>)(views.function), name=<span class="string">'url_name'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="模板缓存"><a href="#模板缓存" class="headerlink" title="模板缓存"></a>模板缓存</h4><p>在模板中使用缓存标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% load cache %&#125;</span><br><span class="line">&#123;% cache timeout pre_keyfix %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endcache %&#125;</span><br></pre></td></tr></table></figure>

<p>因为模板引擎负责缓存, 所以它无需指定缓存项, 只有<code>timeout</code>和<code>prekeyfix</code>两个参数, 模板缓存的位置默认储存在数据库表<code>my_cache_table</code>中. </p>
]]></content>
      <tags>
        <tag>Django</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Django信号系统</title>
    <url>/2019/03/17/Django%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Django的信号机制是观察者模式的典型实现. </p>
<p>观察者模式定义了对象之间的依赖关系, 当被观察对象状态发生变化时, 自动通知其依赖对象, 并且依赖对象自动更新. </p>
<p>值得注意的是, Django信号机制是<strong>同步</strong>的, 而非异步的, 因此要避免滥用信号机制造成效率损失.</p>
<a id="more"></a>

<hr>
<h3 id="内置信号"><a href="#内置信号" class="headerlink" title="内置信号"></a>内置信号</h3><p>模型相关的内置信号都在<code>django.db.models.signals</code>中定义</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>发送时机</th>
</tr>
</thead>
<tbody><tr>
<td>pre_save</td>
<td>在save之前发送</td>
</tr>
<tr>
<td>pre_delete</td>
<td>在delete之前发送</td>
</tr>
<tr>
<td>post_save</td>
<td>在save之后发送</td>
</tr>
<tr>
<td>post_delete</td>
<td>在delete之后发送</td>
</tr>
<tr>
<td>m2m_changed</td>
<td>在manytomany表改动后发送</td>
</tr>
</tbody></table>
<p>请求相关的内置信号定义在<code>django.core.signals</code>中的信号</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>发送时机</th>
</tr>
</thead>
<tbody><tr>
<td>request_start</td>
<td>在接收请求之时发送</td>
</tr>
<tr>
<td>request_finished</td>
<td>在完成请求时发送</td>
</tr>
<tr>
<td>got_request_exception</td>
<td>在请求触发异常时发送</td>
</tr>
</tbody></table>
<p>完整的信号查阅<a href="https://docs.djangoproject.com/en/2.2/ref/signals/" target="_blank" rel="noopener">官方文档</a></p>
<hr>
<h3 id="信号接收的命名关键字参数"><a href="#信号接收的命名关键字参数" class="headerlink" title="信号接收的命名关键字参数"></a>信号接收的命名关键字参数</h3><p>除了有限的几个关键字参数, 每种信号所能接收的关键字参数不同, 而自定义信号则需要自己定义可接收的关键字参数</p>
<p>模型信号通用的命名关键字参数包括</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>sender</td>
<td>Model</td>
<td>触发信号的模型</td>
</tr>
<tr>
<td>instance</td>
<td>Object</td>
<td>实际触发信号的实例</td>
</tr>
<tr>
<td>using</td>
<td>字符串</td>
<td>使用的非默认数据库的别名</td>
</tr>
</tbody></table>
<p>pre_save信号额外接收的命名关键字参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>raw</td>
<td>布尔型</td>
<td>是否按照显示的方式保存(不查询/修改其他记录)</td>
</tr>
<tr>
<td>update_fields</td>
<td>Set/None</td>
<td>修改的字段集合或者None</td>
</tr>
</tbody></table>
<p>post_save信号额外接收的命名关键字参数在pre_save的基础上再多一个</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>created</td>
<td>布尔型</td>
<td>是否成功创建了该记录</td>
</tr>
</tbody></table>
<p>pre_delete&amp;post_delete不接收额外的命名关键字参数</p>
<p>而request_started接收的关键字参数包括</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>sender</td>
<td>WSGIHandler</td>
<td>处理该请求的Handler</td>
</tr>
<tr>
<td>environ</td>
<td>字典</td>
<td>为该请求提供的environ</td>
</tr>
</tbody></table>
<p>request_finish则只接收sender关键字参数, 数据类型和含义与request_start相同</p>
<hr>
<h3 id="信号相关代码位置"><a href="#信号相关代码位置" class="headerlink" title="信号相关代码位置"></a>信号相关代码位置</h3><p>一般而言, 对于简单的信号, 直接定义在关联的<code>models.py</code>中即可.</p>
<p>而比较正式的情况, 应当定义在单独的<code>signals</code>模块中, 然后在app.py添加代码确保该模块被加载, 比较合适.</p>
<p>如果自定义信号, 应当在singals的<strong>init</strong>.py中进行定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yourapp/signals___init__.py</span></span><br><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line"></span><br><span class="line">task_generate_pre_save = django.dispatch.Signal(providing_args=[<span class="string">"task"</span>])</span><br></pre></td></tr></table></figure>

<p>定义回调并绑定信号(未使用自定义信号)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yourapp/signals/handlers.py</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> MyModel</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(pre_save, sender=MyModel)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在apps.py中使用ready方法来确保该app在初始化之后加载该signals模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yourapp/apps.py</span></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">'tasks'</span></span><br><span class="line">    verbose_name = <span class="string">"Tasks"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> yourproject.yourapp.signals.handlers</span><br></pre></td></tr></table></figure>

<p>目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apps.py</span><br><span class="line">signals</span><br><span class="line">  __init__.py</span><br><span class="line">  handlers.py</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="定义处理函数"><a href="#定义处理函数" class="headerlink" title="定义处理函数"></a>定义处理函数</h3><p>一个处理信号的函数应当接收一个sender参数, 并接受任意关键字参数, 信号所提供的关键字参数会传入该函数中以供使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(sender, **kwargs)</span></span></span><br><span class="line"><span class="function">	...</span></span><br><span class="line">	xxx = kwargs['xxx']</span><br></pre></td></tr></table></figure>

<p>在完成定义后使用signal.connect或者在定义时使用装饰器<code>@receiver</code>与特定信号绑定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre_save.connect(handler, sender=<span class="string">'xxx'</span>)</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="meta">@receiver(sender='xxx')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">	instance = kwargs.get(<span class="string">'instance'</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h3><p>一个信号是<code>django.dispatch.Signal</code>的实例, 因此初始化一个Signal类即可</p>
<p>签名<code>class Signal(providing_args=list)</code></p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line">new_signal = django.dispatch.Signal(providing_args=[<span class="string">"task"</span>, <span class="string">"size"</span>, <span class="string">"time"</span>])</span><br></pre></td></tr></table></figure>

<p>使用该信号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(new_signal, )</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="如何在信号中获得可能已存在的记录"><a href="#如何在信号中获得可能已存在的记录" class="headerlink" title="如何在信号中获得可能已存在的记录?"></a>如何在信号中获得可能已存在的记录?</h4><p>如果要获得原记录需要使用<code>pre_save</code>, 此时原记录尚存.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@receiver(pre_save, sender)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">  instance = kwargs.get(<span class="string">'instance'</span>)</span><br><span class="line">  record = model.object.filter(id=instance.id).first()</span><br><span class="line">  <span class="keyword">if</span> record:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="如何在信号中判断一条记录为新增记录"><a href="#如何在信号中判断一条记录为新增记录" class="headerlink" title="如何在信号中判断一条记录为新增记录?"></a>如何在信号中判断一条记录为新增记录?</h4><p>判断<code>instance._state.adding</code>, 如果为<code>True</code>则是新增记录, 如果为<code>False</code>则未新增记录.</p>
<p>值得注意的是, 在信号中判断是否为新增记录仍然必须使用<code>pre_save</code>, 此时instance尚未存储, <code>._state.addding</code>可能被设置为<code>True</code>, 如果使用<code>post_save</code>, <code>._state.adding</code>无论如何会被设置为<code>False</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@receiver(pre_save, sender)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">  record = kwargs.get(<span class="string">'instance'</span>)</span><br><span class="line">  <span class="keyword">if</span> record._state.adding:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>通过<code>.id</code>属性判断是否为新增记录, 仍然使用<code>pre_save</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@receiver(pre_save, sender)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">  record = kwargs.get(<span class="string">'instance'</span>)</span><br><span class="line">  <span class="keyword">if</span> record.id <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#id为自增列, 存储前值为None.</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="如何让多个信号触发同一个函数"><a href="#如何让多个信号触发同一个函数" class="headerlink" title="如何让多个信号触发同一个函数?"></a>如何让多个信号触发同一个函数?</h4><p>使用多个<code>@receiver</code>装饰器即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@receiver(post_save, sender=Model1)</span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=Model2)</span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=Model3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_signal_handle</span><span class="params">(sender , **kwargs)</span></span></span><br><span class="line"><span class="function">    # <span class="title">some</span> <span class="title">code</span> <span class="title">here</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考:<br><a href="https://stackoverflow.com/questions/2719038/where-should-signal-handlers-live-in-a-django-project" target="_blank" rel="noopener">singnal代码应当放在项目的哪个位置</a><br><a href="https://stackoverflow.com/questions/907695/in-a-django-model-custom-save-method-how-should-you-identify-a-new-object" target="_blank" rel="noopener">在save()方法中如何判断为新增实例</a></p>
]]></content>
      <tags>
        <tag>Django</tag>
        <tag>Django信号系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile及常用命令</title>
    <url>/2019/02/20/Dockerfile%E7%9A%84%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p><code>Dockerfile</code>是一个文本文档, 包含所有用于构建镜像的指令, 使用<code>docker build</code>读取并执行<code>Dockerfile</code>的命令即可构建出新的镜像.</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>

<p><code>docker build</code>从一个<code>Dockerfile</code>及<code>context</code>中构建镜像, context指的是执行<code>build</code>命令时指定的<code>PATH</code>或者<code>URL</code>(Git库)中包含的所有文件和递归子文件夹.</p>
<p>构建镜像在<code>docker deamon</code>而非<code>docker CLI</code>中进行, 在进行构建前<code>docker build</code>指令首先将所有上下文发送至<code>docker deamon</code>.</p>
<p>所有的对文件的操作指令都是在上下文中进行, 因此在相关指令中所有的文件路径都是相对路径, 例如<code>COPY ./package.json /app/</code>, 指的是在展开<code>context</code>后, 复制其中的<code>package.json</code>文件.</p>
<p>例如以下例子使用当前目录作为context:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build .</span><br></pre></td></tr></table></figure>

<p>因此, 为了避免发送不必要的文件, 最好使用空白目录作为上下文, 并将dockerfile包含其中, 或者只包含必要的构建镜像所需文件.</p>
<p><code>Dockerfile</code>的文件名一般默认为<code>Dockerfile</code>, 因此在上个例子中, <code>build</code>指令会自动寻找当前目录下名为<code>Dockerfile</code>的文件, 如果需要将其他文件作为<code>Dockerfile</code>, 则通过<code>-f</code>选项指定.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>

<p>在以上例子中, 指定<code>Dockerfile</code>的路径为<code>/path/to/a/Dockerfile</code>, 同时context的Path为当前目录.</p>
<hr>
<h3 id="常用Dockerfile指令"><a href="#常用Dockerfile指令" class="headerlink" title="常用Dockerfile指令"></a>常用Dockerfile指令</h3><hr>
<h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>声明变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> extras:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-extras</span></span><br></pre></td></tr></table></figure>

<p>在<code>FROM</code>之前声明的变量在镜像构建阶段之外, 因此<code>FROM</code>之后的任何指令不能引用变量, 如果需要在构建阶段引用变量默认值, 在FROM之后再次使用<code>ARG</code>指令声明变量, 并且不进行赋值. </p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> busybox:$VERSION</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span> &gt; image_version</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><hr>
<p><code>FROM</code>指令指定用哪个镜像作为基础镜像, 基础镜像可以是任何能够从官方库拉取的镜像. 通常, 一个Dockerfile必须以<code>FROM</code>构建命令开始, 但可能出现多个<code>FROM</code>用来进行其他镜像与当前镜像的合并.</p>
<p>FROM指令有三种格式:</p>
<ol>
<li><code>FROM &lt;image&gt; [AS &lt;name&gt;]</code></li>
<li><code>FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></li>
<li><code>FROM &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code></li>
</ol>
<p>唯一一个可能出现在<code>FROM</code>之前的指令为<code>ARG</code>.</p>
<hr>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><hr>
<p>RUN命令用于在控制台中执行指令, 会在镜像的最上层执行指令并提交结果, 应用了结果的镜像作为下一步构建的基础, RUN命令有两种格式:</p>
<ol>
<li><code>RUN &lt;command&gt; (shell form, the command is run in a shell)</code></li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)</code></li>
</ol>
<p>如果命令过长, 使用<code>\</code>换行.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN /bin/bash -c <span class="string">'source $HOME/.bashrc; \</span></span><br><span class="line"><span class="string">echo $HOME'</span></span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN /bin/bash -c <span class="string">'source $HOME/.bashrc; echo $HOME'</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><hr>
<p>在没有<code>ENTRYPOINT</code>时, 可能用于执行容器<strong>主进程</strong></p>
<p>CMD命令有三种格式:</p>
<ol>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)</code></li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)</code></li>
<li><code>CMD command param1 param2 (shell form)</code></li>
</ol>
<p>CMD指令会在<code>docker run</code>命令未指定任何其他指令时作为启动主进程的指令, 可以被<code>run</code>命令所覆盖.</p>
<p>例如, Dockerfile中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMD <span class="built_in">echo</span> <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>

<p>使用<code>docker run</code>运行容器并附加指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash -c <span class="string">"echo hello docker"</span></span><br></pre></td></tr></table></figure>

<p>输出结果为 “hello docker”.</p>
<hr>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><hr>
<p><code>ENTRYPOINT</code>指定启动容器主进程的入口, 有两种格式:</p>
<ol>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form, preferred)</code></li>
<li><code>ENTRYPOINT command param1 param2 (shell form)</code></li>
</ol>
<p>当Dockerfile中同时存在<code>EMTRYPOINT</code>和<code>CMD</code>时, CMD指令自动被视为其第二种格式, 即作为ENTRYPOINT指令的参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [<span class="string">"top"</span>, <span class="string">"-b"</span>]</span><br><span class="line">CMD [<span class="string">"-c"</span>]</span><br></pre></td></tr></table></figure>

<p>ENTRYPOINT不会被<code>docker run</code>指令重写.</p>
<hr>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><hr>
<p>用于指定容器暴露的端口</p>
<p><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></p>
<hr>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>指定数据卷</p>
<p><code>VOLUME [&quot;/data&quot;]</code></p>
<hr>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><hr>
<p>指定工作目录, 之后各级的当前目录就更改为工作目录, 如果目录不存在, 则自动建立.</p>
<p><code>WORKDIR /path/to/workdir</code></p>
<hr>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>从<code>context</code>中复制文件到镜像中.</p>
<ol>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li>
</ol>
<hr>
<p>参考:</p>
<p><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker —— 从入门到实践</a></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker数据管理</title>
    <url>/2019/02/19/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>容器的生命周期与其运行的程序保持一致, 因此在运行过程中写入的数据也会在容器停止后丢失, 而数据通常有持久化的要求.</p>
<p>由于容器的隔离, 并不能直接从宿主机直接访问或操作容器中的数据, 那么如何进行Docker容器中的沙盒文件系统与宿主机之间的数据交换?</p>
<p>答案是: 通过<code>UnionFS</code>将宿主机操作系统中的文件系统的文件/目录<strong>挂载</strong>到容器中, 就能够让容器和宿主机共享该文件/目录.</p>
<a id="more"></a>

<hr>
<p>三种挂载文件的方式:</p>
<ol>
<li><code>Bind Mount</code></li>
<li><code>Volume</code></li>
<li><code>Tmpfs Mount</code></li>
</ol>
<hr>
<p><code>Bind Mount</code>: 能够直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中, 通过指定容器外的路径和容器内的路径, 就可以形成挂载映射关系, 在容器内外对文件的读写, 都是相互可见的, Docker之外的应用程序也可以更改这些数据.</p>
<hr>
<p><code>Volume</code>: 也是从宿主操作系统中挂载目录到容器内, 只不过这个挂载的目录由 Docker 进行管理, 我们只需要指定容器内的目录, 不需要关心具体挂载到了宿主操作系统中的哪里. 非Docker程序不能更改这些数据.</p>
<hr>
<p><code>Tmpfs Mount</code>: 支持挂载系统内存中的一部分到容器的文件系统里, 不过由于内存和容器的特征, 它的存储并不是持久的, 其中的内容会随着容器的停止而消失. </p>
<hr>
<h3 id="Bind-Mount"><a href="#Bind-Mount" class="headerlink" title="Bind Mount"></a>Bind Mount</h3><p>使用<code>-v</code>或<code>--volume</code>选项即可指定内外目录的映射关系. 格式为 <code>&lt;host-path&gt;:&lt;container-path&gt;</code>, 为了避免混淆, 必须使用绝对路径.</p>
<p>例如: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name some-nginx -v /some/content:/usr/share/nginx/html -d nginx</span><br></pre></td></tr></table></figure>

<p>之后使用<code>docker inspect &lt;NAME|ID&gt;</code>命令, 在<code>Mounts</code>一节中即可查看挂载信息.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="string">"Mounts"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">            <span class="string">"Source"</span>: <span class="string">"/some/content"</span>,</span><br><span class="line">            <span class="string">"Destination"</span>: <span class="string">"/usr/share/nginx/html"</span>,</span><br><span class="line">            <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>在使用<code>Bind Mount</code>方式进行挂载时, 默认容器对该文件是可读可写的, 在挂载信息中, <code>RW</code>(Read and Write)属性的值为<code>true</code></p>
<p>如果只允许容器内对该共享文件只读, 则在映射路径后添加<code>:ro</code>标识</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name some-nginx -v /some/content:/usr/share/nginx/html:ro -d nginx</span><br></pre></td></tr></table></figure>

<p>此时<code>Mounts</code>信息中, <code>Mode</code>属性为<code>ro</code>, <code>RW</code>属性为<code>false</code>.</p>
<p>在开发过程中, 对于可能经常需要手动修改的配置文件, 比较适合这种挂载方式, 安全性较低, 但是方便.</p>
<hr>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><hr>
<h4 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h4><p>数据卷方式指定容器内哪个目录需要被挂载即可, Docker会自动将其挂载至宿主机的某个目录上. 使用<code>-v</code>或<code>--volume</code>指定容器内目录.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name some-nginx -v /usr/share/nginx/html -d nginx</span><br></pre></td></tr></table></figure>

<p>虽然使用的选项(<code>-v</code>)与<code>Bind Mount</code>的方式相同, 但是因为路径的格式不同, 因此可以直接区分两种方式.</p>
<p>使用<code>docker inspect ID|NAME</code>指令查看具体挂载信息:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="string">"Mounts"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"fc67d7d8da5f8822bbe885c77fe1027893dda88d9dab07352852cf3271547c59"</span>,</span><br><span class="line">            <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/fc67d7d8da5f8822bbe885c77fe1027893dda88d9dab07352852cf3271547c59/_data"</span>,</span><br><span class="line">            <span class="string">"Destination"</span>: <span class="string">"/usr/share/nginx/html"</span>,</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">            <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p><code>Source</code>属性的值为Docker分配的宿主机的具体挂载目录, 位于Docker的资源目录下, 当然, 我们无需关心这个目录, 在操作数据卷时, 一律通过docker相关的指令进行.</p>
<p><code>Name</code>属性为该数据卷的别名, 可以通过创建时<code>-v &lt;name&gt;:&lt;container-path&gt;</code>的方式给出, 由于在<code>Bind Mount</code>的方式中<code>host-path</code>部分必须使用绝对路径, 因此此处也不会引起混淆.</p>
<p>通过数据卷别名, 我们可以明确地引用指定命名数据卷, 因此可以方便地实现数据卷共享等功能, 例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -d --name webapp -v html:/webapp/html webapp:latest</span><br><span class="line">$ sudo docker run -d --name nginx -v html:/usr/share/nginx/html:ro nginx:1.12</span><br></pre></td></tr></table></figure>

<p>在以上两个容器, 共享<code>html</code>这个数据卷: 第一次挂载数据卷时, 创建别名为<code>html</code>的数据卷, 第二次挂载同名数据卷时, Docker检索到该数据卷已存在, 直接引用该命名数据卷.</p>
<hr>
<h4 id="docker-volume-相关指令"><a href="#docker-volume-相关指令" class="headerlink" title="docker volume 相关指令"></a>docker volume 相关指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker volume create &lt;name&gt;</code></td>
<td>直接创建数据卷, 不依赖任何容器</td>
</tr>
<tr>
<td><code>docker volume inspect &lt;name&gt;[s]</code></td>
<td>查看指定数据卷的详细信息, 一个或多个</td>
</tr>
<tr>
<td><code>docker volume ls</code></td>
<td>列出现存数据卷</td>
</tr>
<tr>
<td><code>docker volume rm &lt;name&gt;[s]</code></td>
<td>删除指定数据卷, 一个或多个</td>
</tr>
<tr>
<td><code>docker volume prune</code></td>
<td>删除未被任何容器使用的数据卷</td>
</tr>
</tbody></table>
<hr>
<p>在删除数据卷时, 可以</p>
<ol>
<li>直接通过<code>docker volume rm &lt;name&gt;</code>指令来删除指定的数据卷, 如果该数据卷未被任何现存容器所引用, 则删除成功. </li>
<li>在删除容器时, 使用<code>-v</code>选项来删除与本容器相关的数据卷, 例如: <code>docker rm -v &lt;container-name&gt;</code>. </li>
<li>使用<code>docker volume prune</code>删除未被任何容器所使用的数据卷.</li>
</ol>
<p>注:<code>prune</code>指令不仅可用于数据卷, 还可以用于镜像, 容器, 网络或所有docker相关对象, 具体查看<a href="https://docs.docker.com/config/pruning/" target="_blank" rel="noopener">官方文档</a>.</p>
<hr>
<h4 id="数据卷容器-Data-Container"><a href="#数据卷容器-Data-Container" class="headerlink" title="数据卷容器(Data Container)"></a>数据卷容器(<code>Data Container</code>)</h4><p>建立一个容器, 在创建时通过<code>-v</code>选项随之创建一个数据卷, 我们创建该容器的目的就是为了定义一个或多个数据卷并通过该容器引用这些数据卷, 这样的容器就叫做数据卷容器.</p>
<p>使用任意镜像都可以创建数据卷容器, 该容器甚至可以不运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker create --name appdata -v /webapp/storage ubuntu</span><br></pre></td></tr></table></figure>

<p>该数据卷无需别名, 因为所有对该数据卷的引用都是使用<code>--volume-from</code>指令通过数据卷容器进行的, 例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name webapp --volumes-from appdata webapp:latest</span><br></pre></td></tr></table></figure>

<p>通过这种方式引用数据卷时, 无需再定义该数据卷在容器内的映射目录, 会自动应用至<strong>定义</strong>该数据卷时的路径.</p>
<p>相较于命名数据卷的方式, 数据卷容器隐藏了数据卷的配置和定义, 只需要使用数据卷来应用, 因此可以更方便地进行迁移.</p>
<h4 id="备份数据卷"><a href="#备份数据卷" class="headerlink" title="备份数据卷"></a>备份数据卷</h4><p>创建一个数据卷容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v /dbdata --name dbstore ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>假设该数据卷容器中在运行一段时间后获得了部分数据, 我们将这些数据打包, 则执行下一条命令, 包括:</p>
<ol>
<li>创建一个新的临时容器, 挂载<code>dbstore</code>中的数据卷</li>
<li>映射一个容器内目录<code>/backup</code>到宿主机当前目录</li>
<li>使用<code>tar</code>命令, 将<code>dbstore</code>的数据卷打包至<code>/backup</code>目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm --volumes-from dbstore -v $(<span class="built_in">pwd</span>):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure>

<p>之后, 我们就可以在宿主机的当前目录获得打包后的数据卷.</p>
<hr>
<h4 id="恢复数据卷"><a href="#恢复数据卷" class="headerlink" title="恢复数据卷"></a>恢复数据卷</h4><p>将打包后的数据恢复至一个新建容器内的数据卷内, 创建容器<code>dbstore2</code>, 同时创建一个与之相关的数据卷<code>/dbdata</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v /dbdata --name dbstore2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后解压打包文件的内容至新容器<code>dbsotre2</code>的数据卷目录内:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm --volumes-from dbstore2 -v $(<span class="built_in">pwd</span>):/backup ubuntu bash -c <span class="string">"cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1"</span></span><br></pre></td></tr></table></figure>

<p>查看官方文档 <a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">Backup, restore, or migrate data volumes</a></p>
<hr>
<p>参考:</p>
<p><a href="https://boxboat.com/2016/06/18/docker-data-containers-and-named-volumes/" target="_blank" rel="noopener">Docker Data Containers and Named Volumes</a><br><a href="https://juejin.im/book/5b7ba116e51d4556f30b476c/section/5b8381abe51d4538de11609a" target="_blank" rel="noopener">开发者必备的 Docker 实践指南</a></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基本原理</title>
    <url>/2019/02/18/Docker%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>容器是一种轻量级, 可移植, 自包含的软件打包技术, 使应用程序可以在几乎任何地方以相同的方式运行. <code>Docker</code>是容器技术的一个实现.</p>
<a id="more"></a>

<hr>
<h3 id="实现基础"><a href="#实现基础" class="headerlink" title="实现基础"></a>实现基础</h3><p>Docker的实现, 主要归结于三大技术：</p>
<ul>
<li>命名空间 (<code>Namespaces</code>) </li>
<li>控制组 (<code>Control Groups</code>)</li>
<li>联合文件系统 (<code>Union File System</code>)</li>
</ul>
<p>命名空间(<code>Namespaces</code>) , 是linux核心在2.4版本后逐渐引入的一项用于运行隔离的模块, 利用PID Namespace, Docker实现了容器中隔离程序运行中进程隔离这一目标. </p>
<hr>
<p>资源控制组(<code>Control Groups</code>) , 是linux在2.6 版本后逐渐引入的一项对计算机资源控制的模块. 资源控制组的作用就是控制计算机资源, CGroups主要做的是硬件资源的隔离以及控制硬件资源的分配, 即<strong>隔离</strong>和<strong>分配</strong>两个作用. </p>
<hr>
<p>联合文件系统 (<code>Union File System</code>), 将其他文件系统挂载到同一联合挂载点的文件系统服务, Docker使用<code>UnionFS</code>和<code>copy-on-write</code>(写时复制)技术提供不同的容器模块, 十分轻量和快速.</p>
<hr>
<h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><p>Docker的核心组成分为四部分</p>
<ul>
<li>镜像 (<code>Image</code>)</li>
<li>容器 (<code>Container</code>)</li>
<li>网络 (<code>Network</code>)</li>
<li>数据卷 (<code>Volume</code>)</li>
</ul>
<p>镜像(<code>Image</code>) 一个封装好的镜像是一个<strong>只读</strong>的文件包, 包含了虚拟环境运行最原始文件系统的内容. 镜像是分层结构, 所以不同的镜像版本可以建立在公共的基础层(<code>layer</code>)上, 即多个不同版本的镜像占用的空间小于这些镜像本身大小之和. </p>
<hr>
<p>容器 ( <code>Container</code>), 容器是在镜像之上新加的一层, 成为<code>Container layer</code>, 这一层是可读可写的. 镜像是只读的, 当以镜像为基础的容器启动后, 容器内也就成为了一个”活”的空间. Docker的容器应该有三项内容组成：</p>
<ol>
<li>一个 Docker 镜像</li>
<li>一个程序运行环境</li>
<li>一个指令集合</li>
</ol>
<p>PS： <code>Dockerfile</code>中只允许最后一个<code>CMD</code>或<code>ENTRYPOINT</code>生效, 与之对应, Dockerfile中其他命令生成的<code>layer</code>为<code>Read-only</code>的, CMD或ENTRYPOINT生成的layer是<code>R/W</code>的. </p>
<hr>
<p>网络 (<code>Network</code>), 在 Docker实现了强大的网络功能, 不但能够十分轻松的对每个容器的网络进行配置, 还能在容器间建立虚拟网络, 将数个容器包裹其中, 同时与其他网络环境隔离. 另外, 利用一些技术, Docker 能够在容器中营造独立的域名解析环境, 可以在不修改代码和配置的前提下直接迁移容器, Docker会完成新环境的网络适配. 这个功能能够在不同的物理服务器间实现, 让处在两台物理机上的两个Docker所提供的容器, 加入到同一个虚拟网络中, 形成完全屏蔽硬件的效果. </p>
<hr>
<p>数据卷 (<code>Volume</code>), 得益于Docker底层的 <code>Union File System</code> 技术, Docker除了能够从宿主操作系统中挂载目录外, 还能够建立独立的目录持久存放数据, 或者在容器间共享. 在Docker中, 通过这几种方式进行数据共享或持久化的文件或目录,都称为数据卷(Volume).</p>
<hr>
<h3 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h3><p>目前这款实现容器化的工具是由Docker官方进行维护的, Docker官方将其命名为<code>Docker Engine</code>, 同时定义其为工业级的容器引擎(<code>Industry-standard Container Engine</code>). 在 <code>Docker Engine</code>中, 实现了 Docker 技术中最核心的部分, 也就是容器引擎这一部分. </p>
<p>Docker Engine 是一款软件, 但实实在在去深究的话, 它其实算是由多个独立软件所组成的软件包. 在这些程序中, 最核心的就是</p>
<ul>
<li><code>docker daemon</code></li>
<li><code>docker CLI</code></li>
</ul>
<hr>
<p>Docker所能提供的容器管理、应用编排、镜像分发等功能, 都集中在了<code>docker daemon</code>中, 而之前所提到的镜像模块、容器模块、数据卷模块和网络模块也都在其中实现. </p>
<p>在操作系统里, docker daemon通常以服务的形式运行以便静默的提供这些功能, 所以也通常称之为<code>Docker服务</code>.</p>
<p>在docker daemon管理容器等相关资源的同时, 它也向外暴露了一套<code>RESTful API</code>, 通过这套接口对docker daemon中运行的容器和其他资源进行管理.</p>
<p>为了能方便地调用这套RESTful API, 在 Docker Engine 里还直接附带了<code>docker CLI</code>这个控制台程序.</p>
<p>docker daemon和docker CLI所组成的, 正是一个标准<code>C/S</code>( Client-Server )结构的应用程序. 衔接这两者的, 正是docker daemon所提供的这套RESTful API.</p>
<hr>
<p>参考：  </p>
<p><a href="https://juejin.im/book/5b7ba116e51d4556f30b476c/section/5b8381816fb9a01a087ab7b5" target="_blank" rel="noopener">开发者必备的 Docker 实践指南</a><br><a href="https://djangostars.com/blog/what-is-docker-and-how-to-use-it-with-python/" target="_blank" rel="noopener">What is Docker and How to Use it With Python</a><br><a href="https://blog.csdn.net/xftony/article/details/80569777" target="_blank" rel="noopener">Docker技术基础：Union File System</a><br><a href="https://blog.csdn.net/qq_17545293/article/details/80822310" target="_blank" rel="noopener">Docker的Container简介</a></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful风格</title>
    <url>/2019/02/17/RESTful%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="REST标准"><a href="#REST标准" class="headerlink" title="REST标准"></a>REST标准</h3><p>REST是REpresentational State Transfer的缩写, 意味着资源通过表现层进行状态的转移.</p>
<p>符合REST标准的架构, 就可以称为RESTful风格的web服务.</p>
<ol>
<li>资源: 网络上的一个实体, 每种资源对应一个特定的URI.</li>
<li>表现层: 对资源的描述, 可以用json, xml等形式.</li>
<li>状态转移: 对资源当前的状态进行更改, 例如删除, 创建, 更新等.</li>
</ol>
<p>即客户端通过不同的Http method传递json/xml等格式的数据来告知服务端应当如何操作资源.</p>
<hr>
<h3 id="RESTful-设计指南"><a href="#RESTful-设计指南" class="headerlink" title="RESTful 设计指南"></a>RESTful 设计指南</h3><h4 id="协议-protocal"><a href="#协议-protocal" class="headerlink" title="协议(protocal)"></a>协议(protocal)</h4><p>总是使用HTTPS协议</p>
<hr>
<h4 id="域名-domain"><a href="#域名-domain" class="headerlink" title="域名(domain)"></a>域名(domain)</h4><p>尽量部署在专用域名下, 例如<code>api.example.com</code></p>
<hr>
<h4 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h4><p>应该包含版本号, 放在URL或HTTP头中, 例如<code>api.example.com/v1</code></p>
<hr>
<h4 id="路径-endpoint"><a href="#路径-endpoint" class="headerlink" title="路径(endpoint)"></a>路径(endpoint)</h4><p>指向某种资源的具体路径. 注意路径中不包含动词, 因为URI只代表资源本身, 例如:</p>
<ul>
<li><code>/api/v1/products/</code> 所有产品</li>
<li><code>/api/v1/products/123</code> 主键为123的产品</li>
</ul>
<hr>
<h4 id="HTTP动词-verbs"><a href="#HTTP动词-verbs" class="headerlink" title="HTTP动词(verbs)"></a>HTTP动词(verbs)</h4><p>合理使用不同的HTTP METHOD来表示对资源的操作</p>
<ul>
<li><code>GET</code>(retrieve or list): 取回资源, 一个或多个</li>
<li><code>POST</code>(create): 创建资源</li>
<li><code>PUT</code>(update): 更新现有资源, 客户端必须提供完整的资源描述.</li>
<li><code>PATCH</code>(partical update) 部分更新现有资源, 客户端只需提供部分资源描述</li>
<li><code>DELETE</code>(destory): 删除现有资源</li>
</ul>
<p>以及另外两个特殊的METHOD:</p>
<ul>
<li><code>HEAD</code>: 获取响应的元数据</li>
<li><code>OPTION</code>: 获取资源的信息, 包括资源路径, 所支持的操作等等.</li>
</ul>
<hr>
<h4 id="过滤-filtering"><a href="#过滤-filtering" class="headerlink" title="过滤(filtering)"></a>过滤(filtering)</h4><p>客户端可以通过指定过滤条件让服务器返回自己所需的部分资源, 例如:</p>
<ul>
<li><code>?limit=10</code> 限制返回资源的数量</li>
<li><code>?offset=10</code> 从第10项开始返回资源</li>
<li><code>?page=2&amp;page_size=100</code> 指定每页包含的数据量以及目标页</li>
<li><code>?ordering=name</code> 指定资源排序依据</li>
<li><code>?type=ball</code> 指定资源类别</li>
</ul>
<hr>
<h4 id="状态码-status"><a href="#状态码-status" class="headerlink" title="状态码(status)"></a>状态码(status)</h4><p>使用准确的状态码来表示服务端动作, 具体根据http标准.</p>
<hr>
<h4 id="错误处理-error-handling"><a href="#错误处理-error-handling" class="headerlink" title="错误处理(error handling)"></a>错误处理(error handling)</h4><p>当请求出错, 服务端应当包含足够的信息指出错误之处及出错原因.</p>
<hr>
<h4 id="超链接-hyperlink"><a href="#超链接-hyperlink" class="headerlink" title="超链接(hyperlink)"></a>超链接(hyperlink)</h4><p>最好在响应中包含相关资源的超链接而非标识符, 使客户端能够直接请求相关资源的endpoint.</p>
<hr>
<h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>最好使用JSON, 避免使用XML.</p>
<hr>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>授权应当使用<code>OAuth2.0</code>框架.</p>
<hr>
<h3 id="REST级别"><a href="#REST级别" class="headerlink" title="REST级别"></a>REST级别</h3><p>0级: <code>Swamp of POX</code>  传统的RPC, 基于SOAP的WS调用的服务名, 参数放在HTTP协议的body里面, 同时必须以POST方式提交, 问题在于你必须清楚的知道所有服务, 子服务, 及其参数的信息, 并且需要知道各种服务的不同点. </p>
<p>1级: <code>Resources</code> 利用resource概念, 把所有服务都抽取成resource概念, 从body中提取到header里, 这样做的好处就是如果你知道一个服务地址, 你可能无需知道具体服务是什么, 依照资源的惯例就访问到服务, 比如/books/1. </p>
<p>2级: <code>HTTP verbs</code> 利用HTTP动词, HTTP定义了4种动词, GET获取服务器资源, POST在服务器上创建新资源, PUT更改服务器上资源, DELETE删除服务器上资源, 任何操作都可以看成增删改查, 所以利用标准的http verb加上resource（/book/1）就能准确地操作资源, 当你不知道服务具体是什么的时候也可以轻易按照惯例访问到服务, 然而服务供应商更改服务也需要遵循惯例, 不会像RPC那样轻易更改服务接口. </p>
<p>3级: <code>Hypermedia controls</code> 最高级别, 超媒体即应用状态引擎. 这个意思是说, 对于任何服务都存在很多子服务, 你只需要知道第一个服务的入口, 便可以依据服务返回结构的自描述性得到下一个服务的入口, 这样在服务供应商修改服务的时候, 不会影响到客户端的调用. </p>
<hr>
<p>参考: </p>
<p><a href="http://restcookbook.com/Miscellaneous/richardsonmaturitymodel/" target="_blank" rel="noopener">What is the Richardson Maturity Model?</a><br><a href="https://www.iteye.com/blog/elf8848-379125" target="_blank" rel="noopener">REST和REST的四个级别</a><br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构-阮一峰</a><br><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">WIKI 表现层状态转换</a></p>
]]></content>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>127.0.0.1和0.0.0.0</title>
    <url>/2019/02/01/127.0.0.1%E5%92%8C0.0.0.0/</url>
    <content><![CDATA[<p><code>127.0.0.1</code> 是环回地址, 通常分配给<code>loopback</code>处理, 对<code>127.0.0.1</code>的访问都会指向本机, 所以通常用于<strong>本机</strong>应用之间的交互, </p>
<p>对<code>127.0.0.1</code>的请求不会出入网卡, 网络设备也不会对其路由.</p>
<p>操作系统初始化本机的<code>TCP/IP</code>协议栈时, 设置协议栈本身的IP地址为<code>127.0.0.1</code>, 并注入路由表, 当IP层接到目的地址为该地址的的数据包时, 直接转发到本机的IP层进行处理.</p>
<p>即, 对<code>127.0.0.1</code>的请求所使用的最底层协议栈为<code>TCP/IP</code>层,  直接在网络层和传输层之间环回, <strong>不会</strong>通过链路层和物理层.</p>
<p>能ping通<code>127.0.0.1</code>意味着<code>TCP/IP</code>协议栈运行正常.</p>
<p>localhost通常被设置为<code>127.0.0.1</code>的域名, 在支持<code>ipv6</code>的设备中, 同时还指向<code>[::1]</code></p>
<p>使用localhost与127.0.0.1没有任何区别.</p>
<hr>
<p><code>0.0.0.0</code>指的是任意ip地址<code>IP_ADDR_ANY</code>, 也包括环回地址, 主机监听<code>0.0.0.0</code>时, 会接受目标地址为任意地址的请求.</p>
<p><code>0.0.0.0</code>永远不能ping通.</p>
<hr>
<p>在<code>Docker</code>容器中, <code>127.0.0.1</code>指的是本容器的网络地址, 监听<code>127.0.0.1</code>的容器内服务, 不会接收任何非本容器内的请求, 包括其他容器的请求也不会被接收.</p>
<hr>
<p>参考:</p>
<p><a href="https://www.zhihu.com/question/23940717" target="_blank" rel="noopener">知乎</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Python元编程</title>
    <url>/2019/01/07/python%E5%85%83%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<blockquote>
<p>元编程是一种编写计算机程序的技术, 这些程序可以将自己看做数据, 因此可以在运行时可以对它进行内省, 生成, 修改. </p>
</blockquote>
<p>因此我们可以区分Python元编程的两种主要方法</p>
<ol>
<li>专注于语言对基本元素(函数, 类, 类型)内省的能力和对运行时创建或修改的能力</li>
<li>允许程序直接处理代码本身, 例如原始的纯文本格式, 或是抽象语法树(AST)</li>
</ol>
<a id="more"></a>

<p>在python中与之相关的工具有:</p>
<p>第一类方法:</p>
<ul>
<li>装饰器, 允许向现有函数、方法、类中添加附加功能. </li>
<li>类的特殊方法/属性, 允许修改实例的创建过程, 或是访问和修改类/实例的属性. </li>
<li>元类, 允许完全重新设计python面向对象编程范式的实现</li>
</ul>
<p>第二类方法:</p>
<ul>
<li>动态代码生成相关</li>
</ul>
<hr>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>一个装饰器, 接收一个函数, 并返回一个新的函数. </p>
<p>典型的装饰器定义如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">warpper</span><span class="params">(*args,**kw)</span>:</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">   rerurn warpper</span><br></pre></td></tr></table></figure>

<p>装饰器语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>等同于 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func = decorator(func)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一个装饰器函数至少接收一个函数参数func, 并在内部定义新函数warpper, 在warpper的函数体中调用func函数以完成func原本的功能, 并将func的返回值作为自己的返回值, 然后还可以添加其他代码完成额外功能, 最后将warpper函数返回,并赋值给原函数名</p>
<p>&emsp;&emsp;注意装饰器语法完全等同于<code>func = decorator(func)</code>, 现在func这个变量名已经指向了新函数warpper,即增强版的func, 在完成func原本的功能之余, 还增加了新的特性. 为了保证warpper函数可以接收任何类型和任意数量的参数, 其参数定义为<code>(*args, **kwargs)</code>, 并解构传递至func中. </p>
<p>&emsp;&emsp;我们的目的是让warpper函数完美替代原本的func, 现在func变量指向了warpper函数, 但是warpper的一些元数据未改变, 例如<code>__name__</code>属性仍然为”warpper”而不是”func”, 即<code>func.__name__ = warpper</code>.</p>
<p> 这显然是不合适的. 为了使warpper函数<strong>看起来</strong>完全就是func, <code>functools</code>模块中提供了一个装饰器<code>@functools.warps</code>, 该装饰器接收一个额外的参数, 该参数应当传入一个函数, 该装饰器会将被装饰的函数的所有元属性更改为与额外参数(另一个函数)完全相同. </p>
<p>所以一个典型的装饰器定义可能如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">	@functools.warps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wapper</span><span class="params">(*args,**kws)</span>:</span></span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">return</span> func(*args,**kws)</span><br><span class="line"><span class="keyword">return</span> wapper</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="类的特殊方法"><a href="#类的特殊方法" class="headerlink" title="类的特殊方法"></a>类的特殊方法</h3><h4 id="使用new方法来覆写实例创建过程"><a href="#使用new方法来覆写实例创建过程" class="headerlink" title="使用new方法来覆写实例创建过程"></a>使用<strong>new</strong>方法来覆写实例创建过程</h4><p>在类的实例化过程中, <code>__init__</code>是一个实例方法, 它接收一个实例(<code>self</code>), 并将其初始化</p>
<p>而<strong>创建</strong>该类实例的是另一个方法, <code>__new__</code>方法</p>
<ol>
<li><code>__new__</code>方法是用来创建实例的静态方法, 因为其特殊性, 所以无需使用<code>@staticmethod</code>来声明. </li>
<li><code>__new__</code>方法至少接收一个<code>cls</code>参数, 代表当前类</li>
<li><code>__new__</code>方法必须返回一个实例, 否则实例不会被创建</li>
<li><code>__new__</code>方法一般返回当前类的实例, 但也可以返回其他类的实例</li>
<li><code>__new__</code>方法如果返回的不是当前类的实例, <code>__init__</code>方法不会被调用</li>
</ol>
<p>如果要覆写<code>__new__</code>, 一般使用<code>super().__new__()</code>来获取实际生成的实例, 并在完成自定义逻辑后将其返回. 例如实现单例模式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">	_instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">			cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line">		<span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<p><em>以上单例模式的实现有两个重要缺陷:线程不安全以及子类实例化异常</em><br><em>在python中实现单例模式应该直接使用模块的单例性, 将模块级变量定义为需要单例的类的实例</em></p>
<hr>
<h4 id="其他可以访问类-实例属性的一些方法"><a href="#其他可以访问类-实例属性的一些方法" class="headerlink" title="其他可以访问类/实例属性的一些方法"></a>其他可以访问类/实例属性的一些方法</h4><p>内置函数<code>dir()</code>和<code>vars()</code></p>
<ul>
<li><code>dir(cls)</code> 返回继承自基类的和自己的所有属性的列表</li>
<li><code>dir(obj)</code> 返回实例和从类中继承的所有属性的列表</li>
<li><code>vars(cls)</code> 返回类<strong>自己的</strong>(不包含继承的)所有属性的键和值, 与实际属性相关联, 写有效</li>
<li><code>vars(obj)</code> 返回实例<strong>自己的</strong>所有属性的键和值, 与实际属性相关联, 写有效</li>
</ul>
<p>类和实例的属性</p>
<ul>
<li><code>cls.__dict__</code> 一个字典, 包含类<strong>自己的</strong>所有属性的键和值, 与实际属性相关联, 写有效</li>
<li><code>obj.__dict__</code> 一个字典, 包含实例<strong>自己的</strong>所有属性的键和值, 与实际属性相关联, 写有效</li>
</ul>
<p>实际上, <code>vars</code>调用就是返回<code>__dict__</code>属性的值</p>
<hr>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>元类(<code>metaclass</code>)是一个python特性. </p>
<p>元类是定义其他类的原型. 在python中一切皆对象, 所以定义了实例对象的类本身, 也是对象. 进一步考虑, 如果它也是对象, 那么一定有与之相关联的类, 事实上, 所有类定义的基类都是内置的<code>type</code>类. </p>
<blockquote>
<p>普通类是type的<strong>实例</strong>, 而元类是type的<strong>子类</strong>. </p>
</blockquote>
<p>一个<strong>继承</strong>而不是实例化自<code>type</code>的类, 我们称之为元类(metaclass)</p>
<p>一般语法:</p>
<p><code>type()</code>可以作为<code>class</code>语句的动态等效. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">klass = type(<span class="string">'MyClass'</span>, (object, ), &#123;<span class="string">'method'</span>:method&#125;)</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">klass</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>元类中有四个方法需要关注:</p>
<ol>
<li><code>__prepare__(mcs, name, bases, **kwargs)</code> 返回一个空的命名空间</li>
<li><code>__new__(mcs, name, bases, namespace, **kwargs)</code> 创建一个类</li>
<li><code>__init__(cls, name, bases, namespace, **kwargs)</code> 初始化一个类</li>
<li><code>__call__(cls, *args, **kwargs)</code> 让一个类成为<code>callable</code></li>
</ol>
<p>参数解释:</p>
<ul>
<li><code>mcs</code> 指元类本身, 调用此参数的方法接收的是元类本身</li>
<li><code>cls</code> 指创建的类, 接收此参数的方法时对类的操作方法</li>
<li><code>name</code> 指要创建的类的<strong>name</strong>属性</li>
<li><code>bases</code> 要创建的类的父类, 元组</li>
<li><code>namespace</code> 命名空间, 即attrs</li>
</ul>
<hr>
<h3 id="动态代码生成"><a href="#动态代码生成" class="headerlink" title="动态代码生成"></a>动态代码生成</h3><ol>
<li><code>exec(object, globals, locals)</code>: 用于手动执行代码</li>
<li><code>eval(expression, globals, locals)</code>：用于求表达式值</li>
<li><code>complie(source, filename, mode)</code>：编译任意Python代码</li>
</ol>
<p>Python语法首先被转换为抽象语法树(Abstract Syntax Tree, AST),然后被编译为字节码. 抽象语法树是对源代码抽象语法结构的一种树状表示. 使用内置的ast模块可以得到Python代码的原始AST, 在传递给<code>complie()</code> 调用之前, 可以对AST进行修改, 以便向现有语法中添加新的语义. 也可以使用纯人工方式创建AST, 不需要解析任何源码, 这样就可以为自定义的领域特定语言创建Python字节码. </p>
]]></content>
      <tags>
        <tag>元编程</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH协议</title>
    <url>/2019/01/01/SSH%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>简单说，SSH是一种网络协议, 用于计算机之间的加密登陆, 对于Linux系统, SSH软件是标准配置.</p>
<p>SSH协议有多种具体实现, 目前应用最广的是开源实现<code>OpenSSH</code>.</p>
<a id="more"></a>

<p>SSH协议的默认端口号为<code>22</code>.</p>
<hr>
<p>SSH协议提供两种级别的安全验证:</p>
<ol>
<li>基于口令的安全验证</li>
<li>基于密钥的安全验证</li>
</ol>
<p>使用基于<strong>口令</strong>的安全验证, 只要知道帐号和口令，就可以登录到远程主机, 所有传输的数据都会被加密，但可能受到”中间人攻击”.</p>
<p>使用基于<strong>密钥</strong>的安全验证, 需要先将公钥存储在远程主机上, 登陆时使用密钥加密消息进行验证, 如果通过则直接登陆shell, 无需密码, 不会受到”中间人攻击”.</p>
<p>两者相比, 前者方便快捷, 但安全性略低, 后者在连接过程中不存在密钥的传递, 更加安全.</p>
<hr>
<p>windows下可以通过ssh协议进行远程连接的客户端软件有<code>Putty</code>, <code>Xshell</code>等.</p>
]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux定时任务</title>
    <url>/2018/09/21/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>cron守护进程可以在指定日期和时间执行命令, 可以利用corn执行定时任务.</p>
<a id="more"></a>

<p>使用<code>crontab</code>命令可以创建crontab文件, 包含cron守护进程要执行的命令和说明, cron根据crontab文件执行定时任务. </p>
<p><code>crontab</code>命令可以使用如下参数:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>crontab -a &lt;filename&gt;</code></td>
<td>将指定文件作为crontab文件安装</td>
</tr>
<tr>
<td><code>crontab -e</code></td>
<td>编辑crontab文件.</td>
</tr>
<tr>
<td><code>crontab -l</code></td>
<td>展示crontab文件.</td>
</tr>
<tr>
<td><code>crontab -r</code></td>
<td>删除crontab文件.</td>
</tr>
<tr>
<td><code>crontab -v</code></td>
<td>查看crontab文件最后修改时间.</td>
</tr>
<tr>
<td><code>crontab -u &lt;user&gt;</code></td>
<td>查看指定用户的crontab文件, 仅管理员可用.</td>
</tr>
</tbody></table>
<hr>
<p>执行命令需要为一个简单命令, 所以我们将需要执行的任务写成脚本.</p>
<p>这里, 假设将任务封装进了docker镜像中, 首先测试该脚本能够在命令行执行成功:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm tieba_sign_image</span><br></pre></td></tr></table></figure>

<p>然后写入脚本文件<code>tieba_sign.sh</code>, 放入某个目录中, <code>/tasks/tieba_sign.sh</code></p>
<p>如果有必要, 则更改权限:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 777 tieba_sign.sh</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="添加定时任务"><a href="#添加定时任务" class="headerlink" title="添加定时任务"></a>添加定时任务</h3><p>打开定时任务设置表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>然后键入定时任务设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*/<span class="number">2</span> * * * * /tasks/tieba_sign.sh</span><br></pre></td></tr></table></figure>

<p>然后存储并退出 <code>:wq</code></p>
<p>查看任务表, 是否设置成功:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p>重启生效:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="删除定时任务"><a href="#删除定时任务" class="headerlink" title="删除定时任务"></a>删除定时任务</h3><p>想删除任务，仍然是打开任务设置表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>进入编辑模式之后, 直接将目标任务从列表中删掉, 然后保存退出即可.</p>
<hr>
<h3 id="定时任务格式"><a href="#定时任务格式" class="headerlink" title="定时任务格式"></a>定时任务格式</h3><p><code>分钟</code> <code>小时</code> <code>几号</code> <code>几月</code> <code>周几</code> <code>[bash]</code> <code>指令</code></p>
<p>定时任务示例:</p>
<table>
<thead>
<tr>
<th>定时任务</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td><code>* * * * *  /scripts/script.sh</code></td>
<td>每分钟执行一次</td>
</tr>
<tr>
<td><code>*/10 * * * * /scripts/monitor.sh</code></td>
<td>每十分钟执行一次</td>
</tr>
<tr>
<td><code>0 2 * * * /bin/sh backup.sh</code></td>
<td>每天凌晨2点0分执行</td>
</tr>
<tr>
<td><code>0 5,17 * * * /scripts/script.sh</code></td>
<td>每天上午5点和下午5点执行</td>
</tr>
<tr>
<td><code>0 */4 * * * /scripts/script.sh</code></td>
<td>每4小时执行一次</td>
</tr>
<tr>
<td><code>0 17 * * sun  /scripts/script.sh</code></td>
<td>每周日下午5点执行</td>
</tr>
<tr>
<td><code>0 4,17 * * sun,mon /scripts/script.sh</code></td>
<td>每周日、周一的凌晨4点和下午5点执行</td>
</tr>
<tr>
<td><code>* * * jan,may,aug *  /script/script.sh</code></td>
<td>每年的二月、五月、八月执行</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th>特殊写法</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td><code>* * * * * /scripts/script.sh; /scripts/script2.sh</code></td>
<td>每分钟执行两个任务</td>
</tr>
<tr>
<td><code>@daily /scripts/script.sh</code></td>
<td>每天执行一次，类似的还有<code>@hourly</code> <code>@weekly</code> <code>@monthly</code> <code>@yearly</code></td>
</tr>
<tr>
<td><code>@reboot /scripts/script.sh</code></td>
<td>重启系统时执行</td>
</tr>
</tbody></table>
<hr>
<p>执行的最小间隔单位是分钟, 如果需要秒级触发, 可以使用多个任务达成.</p>
<p>例如, 以下任务每30秒执行一次:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* * * * * /scripts/script.sh</span><br><span class="line">* * * * *  sleep <span class="number">30</span>; /scripts/script.sh</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础命令</title>
    <url>/2018/05/21/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li>重命名文件?</li>
</ol>
<p>没有重命名的命令, 直接使用<code>mv filename &lt;newname&gt;</code>即可.</p>
<ol start="2">
<li>如何删除文件和文件夹?</li>
</ol>
<p><code>rm -fr &lt;dirname&gt;</code> 免确认递归删除文件夹<br><code>rm -f &lt;filename&gt;</code> 免确认删除文件</p>
<ol start="3">
<li>更改文件权限</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>神吧人员清单(技术无关)</title>
    <url>/2011/07/31/%E7%A5%9E%E5%A5%88%E5%B7%9D%E5%86%B2%E6%B5%AA%E9%87%8C%E5%90%A7%E4%BA%BA%E5%91%98%E6%B8%85%E5%8D%95(2019.08.24)/</url>
    <content><![CDATA[<p>别看你▧▧▧▧▧, 小心啊▧▧▧▧▧!</p>
<a id="more"></a>

<p>创建时间: 2019.08.24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------以下为10级或以上吧友---------------------</span><br><span class="line">@古徳莉莉安 @Syndra吖 @艹帽123456 @小小雅痞° @五龙学徒 </span><br><span class="line">@是高雄 @但携书剑路茫茫 @你吹箫样子好美 @筝师 @alonerequesty </span><br><span class="line">@woyo永生 @请你叫我小八 @shox1e</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">----------------------------以下为9级吧友---------------------</span><br><span class="line">@我是坏蛋子 @网络检查1站 @崽种 @狮崽狗 @性感77777 </span><br><span class="line">@我欲成爹 @釆炭人 @同学你的肥皂0 @yan_gt @伤吻伤口 </span><br><span class="line">@我是大师33 @稚风吹 @昧世郎 @栗子阿一 @falloutche </span><br><span class="line">@woshisa6095413 @抽象杨过 @我是真低调啊 @_________Power @奇拉比shine </span><br><span class="line">@Mr韩大 @有情有义陈家洛 @李xx是神 @nice何足道 @佐罗张克 </span><br><span class="line">@卖jj的黄瓜 @榫欓福馃惗 @绅士变成熊 @heart蝴蝶君 @懂鲁帝 </span><br><span class="line">@6324核心粉丝 @抽象驾驶员 @wowo种 @健康帅宝宝 @曹_秋_阳_ </span><br><span class="line">@苏白浪人 @灬碧血蓝勋丶 @赵云小枪 @qq945937899 @闪现放d还是f </span><br><span class="line">@几把不怎么硬了 @薄热衬衫 @辉指导 @精淌 @759181206 </span><br><span class="line">@央金卓玛骑士团 @老艺术家叶圣 @可不敢乱说了 @你说4948 @980421zhu </span><br><span class="line">@please_白闹 @无敌煞啊z @灏忚姳鐢燄煇 @东南公园 @给了她的心 </span><br><span class="line">@老衲指天求虐 @youki悠 @夜晚出生 @VEnicehiLL @bi1ei0 </span><br><span class="line">@丶张德帅怪我咯 @鼠鼠——球球 @电竞阿姆 @封号牧之细菌 @草色陆连清 </span><br><span class="line">@马路杀手姨 @紫罗兰832 @IlllIIllIllIl @天道通 @睾丨大丨阴丨俊 </span><br><span class="line">@孙笑川愿识你 @阿尔托利雅丿 @撒比西馁 @放开那个毅丝 @郑射你们无罪 </span><br><span class="line">@尊师释明空 @哥简称叫做神 @添加剂zoom @悠闲孤影 @Infin1te4馃敟 </span><br><span class="line">@鸡蛋向我砸来吧 @望眼欲穿穿不过 @肀耋义888 @他不爱我zc @RainyBlueBe11 </span><br><span class="line">@打扫墓地 @loushichen983 @冲浪的鼠 @小姨妈是班花 @Widow2000 </span><br><span class="line">@人言咳畏 @Iadykiller @1006604837 @没有牌面弟中弟 @峙申 </span><br><span class="line">@最腻害的控卫 @吾乃长3造纸农 @Beyond丶Rose @烽火连天无休止 @Deathless_Mo </span><br><span class="line">@閲嶐煈婂嚭馃悢 @炮殇炮殇 @驭名欢_ @想做个好人家 @国服第一釋2笔 </span><br><span class="line">@撑着风飞翔 @妙龄赌徒 @丶工地少年与砖 @带带游骑兵 @自诩灵猫 </span><br><span class="line">@源红倾雪 @953422622 @臆想幻世 @6666哈哈白羊 @下水道老鼠转世 </span><br><span class="line">@0616superMan @亚丝娜cool @李闵浩i @青梅竹马过往昔 @RINIMAPA </span><br><span class="line">@乳此丿给力 @死神说爱7 @年幼的博尔赫斯 @ql897921333 @地球速度快 </span><br><span class="line">@995o1io @丶李先达 @一双烂鞋子丶 @冷月无暇xzy @LZ小学生丶 </span><br><span class="line">@裤裆上的蘑菇头 @aocjn @小麻阔是也 @ontoj0l @麓鐞存皬 </span><br><span class="line">@面瘫不哭 @猛丶男 @sunsong61 @sLunaria @Fire_火藍 </span><br><span class="line">@我捣乱这吧 @宭欣 @小小香鸡 @训母gou00 @LIN6194 </span><br><span class="line">@水帝Man @liuliucfans @房产快迅太管家 @td用户名注册中 @老阿晔 </span><br><span class="line">@赵R天 @坤爷GK @不卑不亢不窝囊 @我叫小姜而已 @复杂的男人啊丶 </span><br><span class="line">@雪之下Y雪乃 @落木萧萧year @牛X的寂寞 @带笑脸回首寒暄 @无风无雨见彩虹 </span><br><span class="line">@落泪情绪零碎__ @清風二式 @陈希哥 @千古罪人白月初 @wbz4577442 </span><br><span class="line">@滕珂1234 @_Sherme1on @冲浪高手377 @閃刄 @猥_琐_男_在_此 </span><br><span class="line">@纳兰小渡 @坊屋春道二号 @snssah @啊叼ll @谁明浪子oo </span><br><span class="line">@巴渝酒徒 @lzx396193954 @不老皮尔洛 @然而这真有卵用 @泽贝格尔LOTUS </span><br><span class="line">@Landengreen @真的只是七个字 @缘分天空lgz @无话不出我嘴 @粒粒粒哩哩哩 </span><br><span class="line">@百虐灬终成神 @浙江男同俱乐部 @装男人廖文才 @准备去买锅盔吃 @长夜將至 </span><br><span class="line">@命啊华丽丽 @他是陈小小号 @拜誦 @我有两把屠龙刀 @背影触痛灵魂 </span><br><span class="line">@光太郎的饭团 @冰冷灬嘲笑 @这是寂寞艾 @嬴旪 @撩心圣手 </span><br><span class="line">@我三美如画1 @Uranus丶落幕 @竹读的年月 @自宫前的城管 @生命漫长短暂 </span><br><span class="line">@微风吹呀吹万里 @抽象带中带 @阿胶9527 @当你看向深渊 @小猪乐子哥 </span><br><span class="line">@不会驱夜断愁 @河蟹入侵社会 @野爹胡 @槎撱柡 @瓦尼奥的敬爱哦 </span><br><span class="line">@予丶独暧丨 @龙骑No狂少 @阿绿二叔kiyomi @危害人民的坏银</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------以下为8级吧友---------------------</span><br><span class="line">@SUP影子会说话 @臣子遵 @Fan哥ge @曼赞提亚 @伊藤橙c </span><br><span class="line">@窝都想笑了 @我有了咋么办 @花影ccc @你所谓的春与秋 @紫星cf </span><br><span class="line">@风居住過旳街道 @仆街 @乱世十常侍 @__胡猫咪 @妗愪汉鉁 </span><br><span class="line">@煋红 @神山研介 @浪子迅 @Sigismond @森灬旅j </span><br><span class="line">@通灵小猴吼吼吼 @锯齿短匕 @血荒激光 @天马流星坑 @新参者321 </span><br><span class="line">@过期的凤梨罐頭 @跳舞小文 @欢迎整死我 @云降水物理学 @妮酱是我的 </span><br><span class="line">@super久仰2 @零上三六 @黑夜中黑色 @xyn13576184364 @来世做友人A </span><br><span class="line">@CrisSensio @Iighters @夜跑男孩丶 @最爱顺拐 @执笔写蛋疼丶 </span><br><span class="line">@BC诸神黄昏 @a丿残梦 @套麻袋XXOO @泊松的亮点 @41068855 </span><br><span class="line">@余人丨 @怎么离开我了 @leezoyekking @路1991路0602 @麦德3世 </span><br><span class="line">@带古变成汤 @网友小刘丶 @青春不够丶High @__怪你太过美丽 @vinetary </span><br><span class="line">@中出是种发型哦 @个人至高成就 @嗣亿森 @qaqaaaqqqq @为什么设置这个 </span><br><span class="line">@蒙水电风扇 @天圣1001 @我爱阿森纳3097 @Noel丶忘 @一只钢枪握手中 </span><br><span class="line">@小诺操人 @名字有条毛用 @是灰色的你 @感情漏电 @syp7298 </span><br><span class="line">@Cena狗兄 @咏雨霖铃 @目瞪狗呆2333 @文藝小靑哖 @免贪1 </span><br><span class="line">@文祥路吴彦祖 @陈一发99 @抗吧炸亲妈 @亜麻色长髪乙女 @多啦灬B梦 </span><br><span class="line">@夢中冥影 @丢嗨孝子 @立刻给老子闭嘴 @正儿八经不花心 @只想与你过一夜 </span><br><span class="line">@鐙搞摌 @食神贝爷3 @那的确不是爱情 @knnys6 @i死一样痛过 </span><br><span class="line">@飞翔的笨蛋 @sttgddhbc @保卫东北马占山 @15209194052 @名字不重要ar </span><br><span class="line">@蕾灬姆 @XQCbaby @七彩肉松饼 @而月不见我 @被遗忘的鬼道 </span><br><span class="line">@嵗穀 @一枚路人丁 @往昔1996 @水瓶座的饼干 @喷我都是孤儿 </span><br><span class="line">@kdhgey @江日比 @侬本多情759 @那就不要liu @椎名真白的炮友 </span><br><span class="line">@放我我吧叼鸣人 @咩诱 @奶精剩袋 @SweetdaveXD @Refract1on </span><br><span class="line">@欣欣真的可爱 @代码整洁之道 @zsc66688888888 @__sky__小举 @好爱笑c </span><br><span class="line">@黑哥哥呀XH @梵峗 @酸奶139 @毅个大坏仁 @死神之殇 </span><br><span class="line">@尼玛安静一点啊 @帅ku了 @如风不再吹z @fuc名字真难起 @爱国的法证 </span><br><span class="line">@抽象李宇春 @嘂叙旧人 @逐世乐 @完颜伏虎 @homuliliy </span><br><span class="line">@新年中门老被穿 @桃魇z @qq675562034 @进击的方块龙 @兜里有太阳 </span><br><span class="line">@cmccmccmmc @丁叔来啦 @蓝尽人语 @破晓的尖叫 @所谓爱人丶c </span><br><span class="line">@芸生c @Larouchaodan @NMsl孙哭川 @柠檬汽水的味道 @佩恩专属神 </span><br><span class="line">@悲酒l @联盟AKM @Menhera酱 @lzklzklzk123 @BT丶汤米哥 </span><br><span class="line">@baby柒宗罪 @七童寺 @范冰冰的干爷爷 @周玄i @丁婉凉 </span><br><span class="line">@微笑Faithful @ashenNemo @球球的联盟 @呆苯者 @天蝎永远的羁绊 </span><br><span class="line">@蝴蝶涙闯天涯 @zsc23832629 @kaister3 @情话冗长 @q2311271792 </span><br><span class="line">@ちたんだえる @故事落幕之时 @csj01234 @高坂职人 @失足少女丶 </span><br><span class="line">@叫我和谐弟 @magnet_xt_urn_ @enjoyluyu20 @初一夜 @赖宁丶 </span><br><span class="line">@隐心人X @_当樱花灿烂时 @VdoG的观乐 @盲僧的臭嗨一脚 @let1tb </span><br><span class="line">@bicycle枯荣 @褪色丶丶记忆 @墨小萌i @宥嘉哟丶 @椎名烁子 </span><br><span class="line">@欲想放纵蛊小瞳 @Silver丶柳 @老吕96 @对你_从没敷衍_ @真的一无所求吗 </span><br><span class="line">@我本小胖 @1個焦點丶 @你们手里 @哇唔zz @卡三坑 </span><br><span class="line">@必须冷酷 @Nbnutn @教练我想练泰拳 @尼洛是尼斯特洛 @威卡比博 </span><br><span class="line">@无情丶vu @你知道太多了70 @有梦想的流浪 @拾年缘浅 @俺是王校长 </span><br><span class="line">@十四爸爸 @今天喜欢我 @心疼自己几把大 @飛雁伴花眠 @航之汤汤 </span><br><span class="line">@小学生我0 @社会小伙精神在 @不水又不会怀孕 @还跑 @冲擊 </span><br><span class="line">@歌唱红色青春 @敌与刃Naruto @小跟班cqy @浑身都是秤砣 @编辑中我靠 </span><br><span class="line">@jiuwok1 @你很嗨森嗎 @四宫辉夜ii @卡你麻痹玛 @明月何曾知过 </span><br><span class="line">@谁执拗 @一n带m废s一l路 @二珂偷儿子 @阳阳and乐乐 @驍Jonns </span><br><span class="line">@叻痕 @或许这就是6324 @小虎不服 @脱裤_ @丶烟花忆冷 </span><br><span class="line">@新西兰福音战士 @Shine丿Dark @不会西班牙语 @芹菜粥927 @cidita </span><br><span class="line">@艹我谁啊 @asd1148551202 @可不敢再乱说了 @b池塘中的鸟b @閳烘収猸 </span><br><span class="line">@夜半飞机男 @哆黄 @丿三国ren马超 @cx酒吞童子 @wqnmdjbc </span><br><span class="line">@御姐爱萝莉love @逍遥侠士闯天涯 @Immose初秋 @口味有点重◎ @花了伊人妆nice </span><br><span class="line">@带带小师弟home @_陈小美 @带带带秀 @1219_F小滕 @___颓废ing___ </span><br><span class="line">@电竞型男吴彦祖 @不吃榴莲蛋糕 @IceFrost丨Gx @佛陀百相 @hj556768v </span><br><span class="line">@霸氣L @我可棒了 @骑狗撞你蛋 @大手子贼6 @开心的小小板栗 </span><br><span class="line">@Creep_6324 @风好大回电话1 @圣诞戒快乐 @lmlmlmh07 @WWE丶misaya </span><br><span class="line">@小怪兽lwr @爱了就要一辈子 @我又不是XN @伸缩自如的少年 @孙笑川的儿子 </span><br><span class="line">@289378385 @千玄丶敏 @山脉仙人 @weekeUeD @zyl7978 </span><br><span class="line">@冷雨夜人来人往 @软软的呆唯 @姓谢的我爱你 @rockyoyo520 @小轩必胜ovo </span><br><span class="line">@李共赣 @瞭望liao @久阵 @轻婉 @东方求败Tc </span><br><span class="line">@没有观众会爱你 @小翔谔谔 @手握天下 @酱油撸过BOY @whl199981 </span><br><span class="line">@混吃等死贵物ss @加油冲出下水道 @我的小太阳xy @D酒神意志 @小魔love柯南 </span><br><span class="line">@泡泡式幻想 @pmx999999999 @请叫我痴情哥╮ @他哦里垃圾 @孙笑赣 </span><br><span class="line">@小轩必胜111 @霸气珊宝 @杨哲木jj @心无眷恋 @名字叫做欲望 </span><br><span class="line">@瘟疫之源润之 @桃牛白灿 @棒槌岛王 @一架自行车 @残水厄木 </span><br><span class="line">@13856319802a @houseRadiate @Nyan678 @指尖上的血蔷薇 @惑丿世 </span><br><span class="line">@天道ˋ总司 @哈哈哈哈很快就 @lyy5233862 @白晓研 @依然爱丽丝丶 </span><br><span class="line">@凤城烟雨鱼不鱼 @吾主城市o0小焦 @Leslie丶俊杰 @噻噻啊 @陶喆铁杆 </span><br><span class="line">@垣夫 @仰山杨爱民 @灭世AV @提莫毛经理 @申城赌圣李元霸 </span><br><span class="line">@MrsongjieS @禾几页广发213 @私命_ @gta最强 @樱落烬 </span><br><span class="line">@福禄小金刚哈哈 @自闭了嘛 @暴力小朵 @伤疤_变残痕 @打个大西瓜XXX </span><br><span class="line">@存在891 @包批龙敷敷 @我要法克油 @小添头 @虚度的梦 </span><br><span class="line">@WQNMLGB75 @醉红独爱倾辰衣 @你不懂我的雕 @鈭猫 @老大肘吧别管我 </span><br><span class="line">@不媌 @东莞之花a @后手反控 @王傲掌权 @醉后de放纵 </span><br><span class="line">@旧言虐心jay @S5LPL夺冠 @靑灯古寺 @wsxqaz790 @辣哈哈哈哈 </span><br><span class="line">@watermelon丶j @R你JJMM啊 @Kose6112242 @a1824855315 @疯了的祥 </span><br><span class="line">@妖柒柒同学丶 @哭弱x @青春阳光張日天 @xiayigeziji369 @鲤某人 </span><br><span class="line">@钴核辐射弹 @fancy史莱克 @微笑至始终 @寂寞時候想你 @LeBronStan </span><br><span class="line">@商人猫奴电竞 @Fluent2009 @孔子 @瑶瑶偷偷 @合久必婚92 </span><br><span class="line">@藍色深水炸彈 @御坂美琴_wzh5 @艺米二 @_Eoson @明亮爽快 </span><br><span class="line">@大大怪丶灬 @wangdaoyuan00 @没有昵称呀mm @弱智龙鸣滚出克 @120230072 </span><br><span class="line">@他们叫我浪翻云 @Kar98k彡 @Real过路人 @伊月俊lduki @我可以反杀你 </span><br><span class="line">@预言之子追寻吧 @苟胩 @yjl小妞 @十六十六OWO @丶Vincc </span><br><span class="line">@91带老冯 @丶丶丶孙笑川 @好卵扯 @FearTheHarden @戴草帽D海贼 </span><br><span class="line">@对我打了烊 @OB王者Z @森屿小道 @何弃疗就是我 @血月苍凉 </span><br><span class="line">@cNEvr丶 @文苏晨 @余文土本人 @生恰母狗 @Z格子I </span><br><span class="line">@诺诺之士 @Ai学习的 @积木雷诺_ @盗贼哇哈哈 @全程一股草莓味 </span><br><span class="line">@年华深处草吹风 @全爷万岁万岁 @侽R3n @越胡城 @斯坦森海灵顿 </span><br><span class="line">@政致 @君拔剑 @不近美色陈冠希 @挺自闭 @室友在看黄呢 </span><br><span class="line">@李姜鱼 @老比夂 @ArmourZone丶 @骤雨释凝冰 @YoushootmeDown </span><br><span class="line">@梦回鄂东南 @非神豪小学生 @纸片人sirt @你妈逼的 @onlylovejisoo </span><br><span class="line">@小sao货婕婕 @鹰王之王2003 @帝皇620 @巴黎左岸_允児 @西安小周44 </span><br><span class="line">@我不会起明字 @抠脚大汉撸蛋哥 @八岁开始帅 @奶水弟 @宿命im </span><br><span class="line">@黑魔像 @独脚兽没有脚 @笑靥如瓜 @谢氏菌业 @国服第一的盲僧 </span><br><span class="line">@罗大麻子i @农夫山泉甜个批 @灵堂歌唱家 @可爱的小胖鱼3 @橘子我女神94 </span><br><span class="line">@风中捉刀l @可爱你就吃我呀 @沢田纲吉的后代 @Lt19970304 @ZOMBIE一FK </span><br><span class="line">@请叫我野区坑比 @啦啦啦啊8856 @绘雪月 @茜咪go @括而马疵 </span><br><span class="line">@可乐香蕉糖 @廋受 @奚辰福 @那一场雨的天空 @儀唯 </span><br><span class="line">@皇马媒体总监 @v博母狗多 @抱倦 @我如此寂寞_ @南飌 </span><br><span class="line">@兔子爱angel @gls你的d好大 @爱在午夜徘徊 @网友Kiven @YEANYEUNG </span><br><span class="line">@広未凉子 @大爱fatezero @有丶小帅8 @gdjdjfs @北京男同私聊8 </span><br><span class="line">@热成打来来 @A_sexy_devil @抗吧压务团队3 @斩魂刺 @他眼睛他心脏 </span><br><span class="line">@肖国际破迟封 @宅宅男小贼 @南越国军别动军 @爆了boom @Rende2vours9 </span><br><span class="line">@一个有爱的骚年 @痛失我渊 @用了十分钟想ID @szy在别处 @Dark丿冷月 </span><br><span class="line">@骑蜗牛去森林丶 @zlongtempsy @重剑无锋 @生子当生孙笑川 @修坦高手 </span><br><span class="line">@豪无人xing @hhhcko @卩丨葬恋灬 @丶自我解嘲_ @为了蛋蛋的蛋 </span><br><span class="line">@slh961867820 @喝喝猫 @隔壁捧场王 @标准老鼠人 @河南大手子 </span><br><span class="line">@すばる卫 @岭上霜红透眼眸 @张亮66 @锑硫硼 @专门T问的 </span><br><span class="line">@法国的亨利大帝 @三天之内去重开 @星期天王子 @晨曦醉露 @wudichaojida </span><br><span class="line">@超厉害的小雨 @扎心了8 @软饭嗯吃李老八 @18世纪de忧伤 @就叫Sc7 </span><br><span class="line">@小流氓 @我叫洛饭团 @本龙鸣无所畏惧 @没钱成狗 @一个five小童鞋 </span><br><span class="line">@王艾滋2 @鹤玍 @睡觉的笨蛋丶 @不要吧TAT @咸鱼干干丶 </span><br><span class="line">@善良的霸气汉子 @秋水暮光染丶 @夜里走了很多路 @SIHonK @莫非Thanatos </span><br><span class="line">@一只库里 @Q宠大箩兜 @超级用户J @半颗赛艇 @莫踩拖孩后跟 </span><br><span class="line">@i艺声 @科比只穿丁字裤 @1913303871b @黑潮黛安娜 @ws11xztmf </span><br><span class="line">@小短裤过夏天 @一阶废物 @专门研究豁批犯 @流氓兔爱萌妹子 @YOULGQ </span><br><span class="line">@右府军 @seallye @帝国主义时代hh @fiveveve @ShoeniceYB </span><br><span class="line">@a7913qpz @红艳lee @Badtemper_Cool @oooooobili @十二重刘德华 </span><br><span class="line">@汤圆真好吃啊 @带带郭成龙 @蔷薇青柠 @滚犊子JH @笑看春歌报菊花 </span><br><span class="line">@dyoue802 @010917202560 @蔡徐坤c位出殡 @假的水叉叉 @上路抗压吧 </span><br><span class="line">@mman哦 @盗版faker @呆呆丶賊 @实名制冲浪 @玻璃花的梦 </span><br><span class="line">@是我羡慕卜来 @000uuhs @罗江船 @真让人脑阔大 @1171362320 </span><br><span class="line">@今天打篮球吗 @麻苍忧四世 @尊师孙笑 @初丶Tr @影迷踪丶 </span><br><span class="line">@kensou123456 @b8590260 @小伙好学啊 @保级狂魔大维冈 @我是ALBERTLANC </span><br><span class="line">@Gosu丽纯 @断桥依旧下着雪 @南湖子弟 @_婷哒 @asfasf579 </span><br><span class="line">@带善人i @长长长长醉 @summerxiaren @表示躺着都中枪 @还还还可以咋样 </span><br><span class="line">@一条淹死叻鱼 @盖世基王 @套牌司机 @我不会载图 @嫖就到新东方 </span><br><span class="line">@阿银哟嘿 @只愿长安某 @吻so多伤蘅 @18岁和人生love @ljiljji </span><br><span class="line">@SZ15095883991 @蒼の聖典ワジ @灵车少年花与烛 @Love2797 @海贼王我很爱你 </span><br><span class="line">@連詩雅ShigaLin @EDG闪击波兰 @__天莫邪 @ZUTtER1126 @C缃楌煇傪煃 </span><br><span class="line">@长镜归故里 @起个名字难啊11 @我都想睡了 @约翰灬尼德普 @Alfredo_Diego </span><br><span class="line">@day寻找小糖人 @顺义小胖是冠军 @梦若晨曦丶 @你滴网友 @夸图爱 </span><br><span class="line">@1169628726 @豆儿汁儿901220 @作死儿童欢乐多 @善良的霖某 @Fiono半分醉 </span><br><span class="line">@决不对人心失望 @lifewxx520 @kmld是俺 @埃克斯kiu阿 @和谐你大姨妈__ </span><br><span class="line">@Mr_10min @日漫痴tv @崽崽开下门 @拿糖糖骗我吧 @郁闷90后 </span><br><span class="line">@石窟足球 @这次更难耐 @左右互搏于汉超 @微软联合创始人 @小氧气罐c </span><br><span class="line">@愛慕拆膩子 @你爹临死前Aok @丶机智的浪日天 @奈何桥边轰飞机 @aa1030745520 </span><br><span class="line">@ˇ某_某ˉ @究级皮皮鼠 @萨那夫刚 @一只只鹿 @3800023 </span><br><span class="line">@火力全开丶HZ @抗压吧林彪 @啊这谁顶得住啊 @內斂z @带秀TV孙笑川 </span><br><span class="line">@以纯sunny @qazwsx4688 @青筋暴现 @czxvxzzxxxxz @mylhmteyjm </span><br><span class="line">@蓝翔的校草 @我是你亲爹a123 @azsksjjs @x战警smile @国服第三建好 </span><br><span class="line">@夏哥呐 @浪人平克顿 @不要加香菇 @傳鰠 @晓_Hao </span><br><span class="line">@517619863 @8023罡外如缦 @从此辣条是路人 @南贞北戰 @Falcon16onward </span><br><span class="line">@HeyFrankLiu @赵兄托你求我 @GP02d @themoonrise @血韵雪 </span><br><span class="line">@a742649669 @shine管 @盒子里的癫狂 @追风少年iiii @1052418146 </span><br><span class="line">@飒飒飒死亡如风 @感觉你打不过我 @zhoubukun @asheweien @cctv5难民 </span><br><span class="line">@人品人品啊 @久木丶一郎 @拉斯塔哈带王 @梦游洋 @363319841 </span><br><span class="line">@鱼撒ma @卖火柴的小裤衩 @asversion @二手梦想家99 @深酗 </span><br><span class="line">@匿咛 @5s456s46 @扛吧的鱼 @你马哥很棒 @glove668 </span><br><span class="line">@山间野狗乱吠 @哈赛gaygay @jhxzzh @a5946432 @嗯冲呵呵 </span><br><span class="line">@强行有来有回 @大雪的爱犬 @最爱小号 @熊猫吃鼠 @蝎諵i </span><br><span class="line">@吴尼玛先森 @叙几段 @我怕遇得到你哦 @杀马特团长嗷 @重庆尽力局局长 </span><br><span class="line">@紫夜秋瞳 @郑嘎尼玛 @wulanq7 @爱慕节盆妮子 @漫喈 </span><br><span class="line">@丝亲高雅 @游泳的大象a @719720413 @迪神万岁sunny @吧务是条小母狗 </span><br><span class="line">@zzzsdfgh @青钱学士 @Ss丶嘉文 @theme丶ll @长安只因你而乱 </span><br><span class="line">@安琦尔冷冷 @清炒土豆丝7 @Ic丶疯疯疯疯语 @带带水剑龟 @先到哪儿 </span><br><span class="line">@心疼你这么废物 @10032丶 @ikdgd @贫僧睾大阴俊丶 @yanzhengmaqusi </span><br><span class="line">@chenxiaoyi笑笑 @nxasnnaxak @深秋暮雨叶落 @前女友是吧务 @不服智慧 </span><br><span class="line">@sky好学森 @904648702 @我为我雯上王者 @大型空想特摄 @陈维进盗版 </span><br><span class="line">@冬天守夜 @30毁我一生 @涳肀 @我是蝌蚪123 @问三鱼 </span><br><span class="line">@我就冲浪 @兔兔章节 @duan57651962 @他们都叫我局长 @CCM_dota </span><br><span class="line">@谈大师day @Vocitus @扭扭捏哦哦 @全国扫黄工作组 @21数码宝贝12 </span><br><span class="line">@全国人民模范 @灵狐非妖丶 @曹年宝赐我雷神 @3hahahime @诡歆 </span><br><span class="line">@不抓我就炸啦 @我一直丶在流浪 @他们都笑我丶 @如果容易789 @she7vchenko </span><br><span class="line">@就手冲吧 @坎普诺之奇迹 @俗世无味 @windyqaz10086 @疼痒集团保安 </span><br><span class="line">@路人假Gh @向上的太阳i @安排你就完事了 @Nocti666 @六痣箴言 </span><br><span class="line">@畵鳶 @稻草人L @自承其重 @矗囧官邸 @我爱吃楼主大便 </span><br><span class="line">@jgglove99 @延期承诺 @__evernest @那个彪闯天涯12 @wuligagai </span><br><span class="line">@边缘上的预言家 @Toby清茶 @lonely灬忏悔 @鹿边妖a @浪人e刘某 </span><br><span class="line">@操弱智 @Carry光芒 @Meroux @啪啪啪8885 @白羊小莫123 </span><br><span class="line">@lamlau刘 @我亲爱的偏執狂 @514458986 @Rickkk丶 @q6246379479 </span><br><span class="line">@百ァ年 @sbcannotseeme @蟆物语 @铪骨銘心 @膝盖中了一箭阿 </span><br><span class="line">@送钱狗庄 @处女座永远的痛 @麻友桑饭 @游戏狂丶歌 @追照玉子 </span><br><span class="line">@手沖三旬 @米了个脧了个欲 @片片记忆活下去 @老衰鬼 @红石头的蓝天 </span><br><span class="line">@__我们都寂寞 @磨牙嗯的么呢 @静苍生 @炏崇 @一炮泯仇恩 </span><br><span class="line">@JAY喔喔 @_石头开花 @爱笑的hhhh565 @vok @8要丨欺负俄 </span><br><span class="line">@水狗前来受死 @小风骚abc @free不要太多 @哆啦A梦会复活 @你很美丽丶 </span><br><span class="line">@tfblade @嘉陵江胎神 @ww201106 @乐观的晨曦微露 @5安君白起 </span><br><span class="line">@快乐的年 @续部尚书 @极度愤怒year @无敌王刚 @丨saber丶8 </span><br><span class="line">@誓言丹儿 @Herscor528 @张德德k @金光瑶0 @杜海涛没JJ </span><br><span class="line">@凉宫槿 @simawogan @Ayyt3t @_Mc丶葬爱 @maoyuhao7 </span><br><span class="line">@旧言虐心wtr @烤牛鸡鸡257 @豆奶__没有渣 @AG丶xun @江鲫c </span><br><span class="line">@小妖叫我来巡山 @阿难重生版 @酒债常有人古稀 @o区呕 @DesireJwindy </span><br><span class="line">@假假条 @梵蒂冈黑手大厅 @行我不要名字了 @温柔予我y @怪咖188 </span><br><span class="line">@GraculaGZ @你别回头Bay @昙柴 @倒车请注意01 @棋手天下 </span><br><span class="line">@好心的旅行家 @狂草雪之下雪乃 @▲_Promise丶 @信得看见了 @小五酱 </span><br><span class="line">@uu送一血pdd @Anime元羽 @1393056031 @宓软的蓝 @西子泛舟范蠡老 </span><br><span class="line">@简单xuan律 @白霜人 @我却在这 @儒雅的二狗 @魔物娘BANZAI </span><br><span class="line">@阿扁很强 @讣来 @JndttL @奶神最爱陆七七 @赤红之捅 </span><br><span class="line">@斥忱 @流年光华heart @明日花祺罗 @金木大人丶 @瑛噬 </span><br><span class="line">@迷失久久 @Robert莱万 @层主帅杯 @此生信仰全宝蓝 @远咫尺 </span><br><span class="line">@黑桃Kwy @GroZa丶 @养猪王0 @新司机朱剑豪 @落日狂想Z </span><br><span class="line">@duocean2005 @海丶变成陆地 @阿布扎格 @永不妥协_罗夏 @子轩上学吃醋 </span><br><span class="line">@唯一极致 @HE4THEN @___Exia @散装护舒宝 @Sanji啊 </span><br><span class="line">@我叫鸟叽 @二狗蛋 @想带你去踏雪 @员兆阳 @乱丶踏歌 </span><br><span class="line">@紫宫初雪q @和陈医生说起3 @爱稀饭喝稀饭 @嘎哈009 @飞翔的醒工砖 </span><br><span class="line">@凝结cccccccccc @3794664close掳 @疯狂的猫贼栋 @nam31 @丁磊似条狗 </span><br><span class="line">@火焰哥哥孙笑川 @无言夏雨凉透心 @tennis2i @爲了以后 @朱佳文的牛肉面 </span><br><span class="line">@小花小粗森 @燃_并暖 @金刚神仙是我 @幼儿园第一风男 @九州创造古卷 </span><br><span class="line">@你个小瓜皮 @机智的卫平</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------------------------以下为7级吧友---------------------</span><br><span class="line">@飞逝的光芒 @__卟言秋 @放纵的圊春 @双鱼光头强 @安师爷的破刀 </span><br><span class="line">@季度里事過境迁 @可靠的正太在此 @宁静内无敌外 @雾都看雪丶 @带带卢本伟 </span><br><span class="line">@rollinros @你不可能那么水 @我还是看不透批 @ydj665716 @念星瞳cz </span><br><span class="line">@可不敢乱说话 @锦綿 @流水年华总是情 @淚丝Win @虾米超淫 </span><br><span class="line">@沉默★灰Q @矢泽妮可的诱惑 @丸治莉香 @小黄狗乐园 @SE7EN王尚飞 </span><br><span class="line">@九死の一生 @鉴不鉴哪 @JoyoungXi @Juess0 @水打苏哈 </span><br><span class="line">@重生之我是兴平 @键盘教父 @宝贝车震吧 @王尼玛201413 @Pai_Go </span><br><span class="line">@祝伈 @刀尖上的萝莉 @冲浪的小明 @nice雨中的猫 @mpjs </span><br><span class="line">@飓风1998 @luobogan923 @Brokeboi @二伯母骂我帅 @找日夭 </span><br><span class="line">@孤独到不知所措 @青铜记忆l @周哥119 @花开请更美 @被强煎的蛋咯 </span><br><span class="line">@张驹2002 @阿莎嘉光咏 @高雅名导冯小刚 @_周_勇_康 @安全冲浪 </span><br><span class="line">@我们是NBA @求进水瓶 @智商上压制 @有一种歌叫 @向孤独告白 </span><br><span class="line">@隐世家族 @侧耳倾听lla @雨下一整晚o @青烟戈 @鐙椸箲鈥 </span><br><span class="line">@满腹理想 @妄鮦 @这伙货不是校长 @南林教务网 @不要噴香水 </span><br><span class="line">@下等废物 @ZZZZMKIU @吮纸圆胃基 @我有一个长ID @紫火连天 </span><br><span class="line">@zhaomin131491 @亚索操劫 @954274231 @我是羊羊羊欧巴 @Melissaley </span><br><span class="line">@苦涩ant @今井結菜 @厄摩 @您萌死 @我就是烦烦的 </span><br><span class="line">@下忍鸣人熊 @陪你去看流行语 @悲酥清风886 @曾经的梦想_ @纯白旧光阴丶 </span><br><span class="line">@河南大侠gfx @非生物joker @草莓桑巴 @妈个巴子_ @长甥 </span><br><span class="line">@草包同学 @igtheshy123 @潮流教父豫玄 @对街告白气球丶 @abcdwxz550033 </span><br><span class="line">@无yin良品mak @小翼歌歌 @mister丶绝唱 @zaytiancai @听见昨日 </span><br><span class="line">@推到那个妹子 @DK丶驯鹿 @受够厌笑 @种 @网瘾少年zzq </span><br><span class="line">@青厄i @陈信宏MikuSama @2blzy @我csol达人 @gueeg33730 </span><br><span class="line">@风雨守候在原地 @咪驼 @安可昂locker @5824xpf @兮浅3 </span><br><span class="line">@wine酒久 @老子可能会飞 @时间是深海哥 @盖伦与草丛1 @mikeirs </span><br><span class="line">@二维图free @Sociolotron @轻微德疼痛 @家田G @是非抱紧我 </span><br><span class="line">@未軮 @浅夏流年Lv @Starsonderr @春秋只記載要事 @slowlyweunfurl </span><br><span class="line">@逗比ZZR @进击的叫兽10 @樋上寛義 @我这个多好 @一个绝望的时代 </span><br><span class="line">@q2244335 @一双酸软的腿 @丰欺 @06061Keepreal @珡某人 </span><br><span class="line">@影縫英 @要和银时一样 @榮谜 @二字太君 @午后嫖客 </span><br><span class="line">@nwx314 @Noone小学生 @24K阿森纳 @裤子都穿了 @抽象画画家 </span><br><span class="line">@命中的过客啊 @带带大胸弟 @没钱的狗粉丝 @倚风凝睇雪肌肤 @萌幻丿 </span><br><span class="line">@一闪半管那么多 @神奇求上进 @闵行炙 @短桥窄马 @文脏的外遇 </span><br><span class="line">@鲸囖 @撸拉拉德玛西亚 @cnlingzhi @batman1z @PARANOIDXH </span><br><span class="line">@抽象鸣人 @倩儿猪宝宝 @kwahhi @Judas丨Priest @DMCZGW </span><br><span class="line">@zzzzzzzzzz75 @取尼玛的 @带带小莱莱 @打tomato @悍刀寻 </span><br><span class="line">@稚儿尼玛 @likening120 @不死吉普赛 @迷奇幻夜人 @day阿松桑 </span><br><span class="line">@晓祎子 @e一本悠然 @那一斩 @只是来求种83 @可可可可的1 </span><br><span class="line">@丿战神丶吕布 @小姐能借个吻么 @自住房 @你女马没辣 @卡尔约翰逊2012 </span><br><span class="line">@伊鸟系璃 @我笑LZ看不穿 @黑礁98 @小老梦_ @1258012905 </span><br><span class="line">@dsy_aini @Single_潜龙 @杀生罪孽 @太平老绅士 @啊啊疼嗯嗯嗯 </span><br><span class="line">@风吹散你的香气 @a787602141 @伸向萝莉的手丶 @小松菜奈丨 @问问砖头 </span><br><span class="line">@Cheparello @简小诺爱隐蝠 @_依然安靜 @年少方多情 @老司机_23333 </span><br><span class="line">@法外狂徒丁吉吉 @一名三星狗 @河南上仙刘斩仙 @z260952274 @閻魔愛します </span><br><span class="line">@月存五千吴玉峰 @AphroditeCrow @Elive小灰 @北大跪求哥去 @三瘾 </span><br><span class="line">@自闭冲浪手 @林迈可OH @狼爱民 @diuierhome @我叫蜻蜓队长哦 </span><br><span class="line">@一起在冬天恋爱 @囻服第一兰博 @飘渺如神 @射手fio @魄殇风 </span><br><span class="line">@应该是西瓜不大 @MR953 @你还真是不乖啊 @Lockiiii @黄牛全家爆炸 </span><br><span class="line">@今晚你亲妈暴毙 @w1z5y2 @超肥小肥猫 @g365823249 @追风少年吴亦几 </span><br><span class="line">@抽象鼻祖 @我体内有焚寂呐 @充钱就会赢 @你看你吗呢丶 @伪装的我℡ </span><br><span class="line">@温柔的小狼狗子 @荞麦菁菁7 @有梦想的ADC @月落无声5 @william阎阳天 </span><br><span class="line">@葛继康康 @难满辞 @狮子aachen @yjf875661398 @这波不怕我有大 </span><br><span class="line">@只有煮酒 @Static274 @陶日天就是我 @a136780395 @费马四色哥德巴 </span><br><span class="line">@Noctis911 @star禀 @帆王 @放弃仅有的丶 @腿毛张 </span><br><span class="line">@cgbvdrjnccfjjj @吃7吃就只能 @7853413s @生为野鲤 @陆加盐 </span><br><span class="line">@史叔快揍拉姆斯 @二次元之泪AND @卖海鲜的叶良辰 @工号13812 @LZ陌筱柒 </span><br><span class="line">@may_joyfree @SX我爱双马尾 @你的男孩_笑川 @龟宗瑞 @我最爱的右手 </span><br><span class="line">@nsmnsjdhdbxms @丶小L酱 @秋名山黑车司机 @三生三世桃花谢 @莫甘娜透姜虐虐 </span><br><span class="line">@nshdfg @美团大便 @僻萨 @14444444444m @酷酷滴小仙女o </span><br><span class="line">@个人太鼓达人 @REDHYSW @啥子麵麵藥都吃 @联想a660 @YOGAWANGZE </span><br><span class="line">@阿里布达年代计 @1条红领巾 @荣粉敌 @何文婷巨蟹 @皮皮打他奶奶了 </span><br><span class="line">@业_界良心 @exova @我服辣love @领军王者 @pindsyang </span><br><span class="line">@丶青峰_未命名 @流浪客灬小菜 @the_bz @丶我来拿一血 @我是孙烦了 </span><br><span class="line">@魔怔研狗 @诶～ @劳资木有青春 @鹿死不择隐 @渲爱丶 </span><br><span class="line">@Pantk77 @j970613343 @令人失望丶怪我 @冲浪者归来 @时空的旅行者s </span><br><span class="line">@惜_小晨 @huiyi456 @青椒凤爪sky @无夜日14 @chentuliuhe24 </span><br><span class="line">@你丶我的劫 @叫在之 @丶尕旭哥 @三个女人日老汉 @乔戈里峰l </span><br><span class="line">@無敌小笨 @本大佐 @硪嘞个那个去 @oaidaiyue @酸葡萄杜 </span><br><span class="line">@謀攻 @曾经也会流露着 @饶家有骡 @colordrive @尘埃中的传说 </span><br><span class="line">@hello的瑞宝 @1213二狗子 @谢老巴 @曙光重临伯纳乌 @樱飞夕阳阿 </span><br><span class="line">@整挺好整挺好 @神秘的x种子 @ilpretrosso @穷汉b @姊楌煈火煉 </span><br><span class="line">@吾辈乃不良少年 @开始交往吧 @kendalljennerG @你好啊哈哈地 @当我追赶回忆 </span><br><span class="line">@让我来搞事 @你们畏惧我吗 @超级无敌额额 @容lll @匿椧 </span><br><span class="line">@費屼 @house偷懒的心 @快留卡号去修车 @不朽啊耶 @你不让用符号 </span><br><span class="line">@祈祷着合起双手 @鐏甸瓊馃敧绁 @毕竟我刚啊 @蓝白夏色 @网城 </span><br><span class="line">@J丶qq @mbjmhb @不酸的琉璃柠檬 @剑持大小姐 @剁手宅的救赎 </span><br><span class="line">@_嗨丶High @蚩梦萌 @别说我是凹凸 @郁郁于帅 @Amoy_1996 </span><br><span class="line">@别打这么多灰机 @小伙手别抖 @隔壁的二傻子 @偏爱至满益 @该吃药了ok </span><br><span class="line">@Delphi梦魇go @homexj001 @梁夕丶 @HeimdallrU @皇狙肛马 </span><br><span class="line">@约德尔小铁匠go @传说中的斜神 @无畏须臾丶 @一种沉沦丶 @巴柔学徒 </span><br><span class="line">@许嵩张杰i @苍井空的猫 @rap教父SunDog @虎狼寺小师弟 @鼠疫晚期 </span><br><span class="line">@可爱的小来哥5 @花祭哦i @34码的反击 @053188881234 @花大吊 </span><br><span class="line">@你让我红了脸 @优乐美奶罩 @djdjdjdjdiockc @糖分home @清泉透心啊 </span><br><span class="line">@24岁是学生 @lrl0088 @骚人番茄 @大海里的浮瓶6 @浪人艳红 </span><br><span class="line">@戒痴嗔 @毕家试试乐 @米斯南迪尔 @YeJinhand @Vanity_Mary_ </span><br><span class="line">@深蓝少年忆梦 @黑衣丧失猫 @毅盐不发 @终极猪蹄 @inHervillage </span><br><span class="line">@就要爱生活啊 @崽崽种 @圈圈00121 @小松菜奈丶 @裤裤中缝有杀气 </span><br><span class="line">@白玉台铃 @帅什么3 @穗枳 @丨丶聆听丶 @杀手阿虫 </span><br><span class="line">@lakertwo @250不是罪 @毛利小五翔 @纸箱里的纸2 @狂扁小豆豆 </span><br><span class="line">@深藍v @睹物思离人丶 @无耳蓝皮猫 @TuzkiJut @54998060_ </span><br><span class="line">@月亮照样升降 @泡泡么 @寂寞的贪吃蛇丶 @zdfhsggjk @韶华白首仍枉然 </span><br><span class="line">@kcndjak @1136453289 @狸伈 @懒鱼ok @不想败给现实 </span><br><span class="line">@KiLleR泽 @miss恋宣 @正人君子_945 @冲浪的老鼠 @法兰西海军上将 </span><br><span class="line">@aa旧梦已逝aa @shinecwh @半夜流点水 @冇烊 @国服第一守卫 </span><br><span class="line">@今年一定打 @老子劈 @拉莱耶的旧约 @经营鬼才焕某人 @Jay哎喲 </span><br><span class="line">@year君临天下辰 @那个什么丶fly @ui8sl2 @★鑫灬鑫☆ @整挺好铁铁 </span><br><span class="line">@帥帥帥锅 @314303470 @银铯之月 @1382884407 @张宇翔2013baby </span><br><span class="line">@全球第三聪明 @1171979281 @蓝色淡漠回忆 @开始看12 @几何褪色 </span><br><span class="line">@jinyang的老巢 @Prince起灵 @大牛子zzz @li38386aa @挂机的123 </span><br><span class="line">@Asapss111 @源之瘋 @摩羯荆州吴彦祖 @辣条仔丶 @中国首席阉割师 </span><br><span class="line">@q87791678 @y23542185 @向浩鹏同志学习 @Xxnds @趣味的风 </span><br><span class="line">@抗压暖心吧务 @刘又嘉必感冒 @我不是在鬼扯 @___meteorfree @社会我韩金 </span><br><span class="line">@挽秋Wanqiu @薛_之谦 @耻辱RY @玄逸师傅 @用行动证明诺言 </span><br><span class="line">@无尽型小熊 @呕哥灬 @一大盒清风 @邢平窃guo @请拥我入怀 </span><br><span class="line">@yannun @不笑的奥特曼 @王尼玛fly @丿夏灬忆尘 @别忌惮 </span><br><span class="line">@带恶人 @孜麗 @虐心旳点点滴滴 @liaoxiaoping4 @中国·成都 </span><br><span class="line">@每天都在变帅阿 @火焰鼠他爹 @小愛少年 @GaoSAMAi @惘然不惘然 </span><br><span class="line">@时空枢纽孙一峰 @贤嫌闲 @CheriSHh3 @鲨鱼哔哔丿 @Husky1丶 </span><br><span class="line">@炎關 @长成生活的模样 @孤僻怪兽 @影漫游 @rapperoney </span><br><span class="line">@lcnla @浊酒断愁 @菲常帅的兔子 @day北辰烟雨 @周瑜打盖茨 </span><br><span class="line">@珍玛西蒙斯 @带带带杀杀杀 @给我喜德来 @大众萌妹小姐姐 @Dabaojian丶 </span><br><span class="line">@张琦zq0322 @lxhq2009 @l我不是你的狗 @wangda322 @埖开了一整夏 </span><br><span class="line">@jks1118 @苏坡man∽ @lncy448 @韩国father @824812467kos </span><br><span class="line">@Roaryiyiui @带带李老八 @秤子willy @枫羁 @Saleon2016 </span><br><span class="line">@壬券逗士lyh @重始05 @hihiniger @coco的好爸爸 @多情的畜牲 </span><br><span class="line">@打算去买锅盔吃 @濟縷倒攘笨防vy @終究遈敷衍丶 @我是农民工649 @老湿FUXK </span><br><span class="line">@木子遇川 @Git_ave @BT凹凸曼 @一身正气mata沈 @maninnupt </span><br><span class="line">@ta57552 @河面少年 @a956074128 @帅的批爆阿 @龙鸣zz </span><br><span class="line">@你的女神夸我帅 @Say再见_坤 @主之梦 @aue157 @醉武侠丶 </span><br><span class="line">@likaiwei62 @爺梻樂 @倚天剑斩云冠 @loowkkshhb @稳如推土机 </span><br><span class="line">@颓废得愛 @狂雨骤 @节操是拿来吃的 @白羊零基础 @惹人欢心 </span><br><span class="line">@huangxuaccp @Sunshine燃 @yuanlufa12345 @北七小苏泽 @新版电脑管家 </span><br><span class="line">@蓦然心凉 @卡西莫多的反击 @TFgays2 @ShizukuKagari @ivcyztdk </span><br><span class="line">@ClearlovingD @snow丨东湖 @骑士的忠贞 @1234xr5 @19990人 </span><br><span class="line">@辉酱大魔王QAQ @鲍伯丶 @电竞郭达 @狂暴炫酷拽 @282828好 </span><br><span class="line">@追风少年pdd @华古 @文档先生岁月 @小吱吱I号 @五毛钱丿 </span><br><span class="line">@未来的王思聪爸 @go注册名字真难 @甜啊甜l @武陵人爱捕鱼 @昌黎小朋友 </span><br><span class="line">@丿So丶邪雨 @艾玛咔吧好痒 @托尔娘 @781081944 @夕子浄瓶 </span><br><span class="line">@笑的很有节奏性 @乌尔奇奥拉706 @adffs23r4 @丶睡过头了 @幽栀花 </span><br><span class="line">@神秘的黄老湿 @麻花不疼丶 @山河故人Re @咯是裤子好了 @77sgbbw </span><br><span class="line">@劳资让你火 @Desr丶庸人自扰 @勿忘心安大黄蜂 @看门狗_军团 @Maybelol </span><br><span class="line">@我最爱芒果了 @多年以后lovage @烛镹阴 @我睡不饱 @望眼欲穿是萨科 </span><br><span class="line">@宁为痴狂 @伪瘾君 @昵称注册用户 @真666666丶 @春埿 </span><br><span class="line">@你就摇了我吧嗷 @布诺乀 @98212495 @丈夫01 @SuchAPity1989 </span><br><span class="line">@nice在路上3399 @onepersonsky @困炯 @珈蓝_FLY @等李子丶干 </span><br><span class="line">@重庆男天使 @奅牖 @lsrlt030 @一只小破杯 @芷源牛肉 </span><br><span class="line">@岛国女性 @人生无处不抗压 @王里清 @a867406734 @捞比dade </span><br><span class="line">@Madas_1 @克鲁泽大队长 @苏二二萌 @冷漠六道 @杨瑞696 </span><br><span class="line">@第三只 @花神残月 @DavelMe @梦尘猫 @repickme </span><br><span class="line">@沐宥丶 @非攻非受de @Namei半苑香 @叶皓珉 @Angle是螺丝啊 </span><br><span class="line">@不止爱你2 @碧枫雪 @wdttu @nicerobin770 @越来越没底线 </span><br><span class="line">@hajmisery @允爱今生aa @如夏天般热烈 @Msser丶绅士 @1956路过蜻蜓 </span><br><span class="line">@终许再见 @西门彦祖 @应该可以打职业 @火苗与一块红布 @允鹿tionm </span><br><span class="line">@我开心管不着我 @我名字真有创意 @抗压TV丶羁霄 @有批的我 @lz看飞碟 </span><br><span class="line">@葬爱娜美 @抢劫 @微笑了无声丶 @倾彡塌 @国服第一奶祖宗 </span><br><span class="line">@一刀你卵都没有 @Amito7 @毛毛蛋8 @东百户口 @鈥璦lign </span><br><span class="line">@Xinpingsima @呆呆呆梦雨 @GM_紸角 @不见幻影少年 @nwjqn58355 </span><br><span class="line">@夏酱茶 @Worthless9 @DEAD涵 @笑看絢爛霓虹 @雷鲎 </span><br><span class="line">@孙传奇1 @茕火1 @汪汪汪汪汪汪87 @和蔼的duyuxi @JT录音机 </span><br><span class="line">@田长春的 @恶俗猫 @秋名山苍天 @带热诚打奶奶 @大师级耐奥祖 </span><br><span class="line">@微光漫小城wjs @77032707 @唔撚锺意 @EsWeht @訡唱 </span><br><span class="line">@Dreams_丶 @Dyrus3 @Flyfishmoe @再见座上宾 @血祭恋丶 </span><br><span class="line">@丶我不浅薄 @后河張学友丶 @阳光可爱的男神 @夂枳 @复活169 </span><br><span class="line">@路漫漫愿你安好 @句话大侠 @最爱白痴生活丶 @IOPO白羊 @1103的zzk </span><br><span class="line">@抗吧务压队团5 @此吧都是我小弟 @啾咪老铁 @声入人心男团 @kangta_七炫 </span><br><span class="line">@你的男孩TizzyT @到达伊瓜苏 @ca给力的烧饼 @一日一年a @偏爱马提尼 </span><br><span class="line">@安猪辣北鼻 @阿尔卑斯的少年 @a98278090555 @血与酒的沉醉 @jjjjjggggjj </span><br><span class="line">@昏天黑地3 @envoyzzZ @Taurus @带带水明星 @信任与瞒 </span><br><span class="line">@555555PDD @圣魔的云梯 @全身一只大雕剑 @皮_德_狠 @带带大师兄90 </span><br><span class="line">@亦沉亦乱 @fiy岁月 @一剑零落锁清秋 @CLhahahaha1 @悟飯超3 </span><br><span class="line">@玉佛苑丿 @清明上巨蟹 @么哥不是妖哥 @dnf6年玩 @爺灬萬人景仰 </span><br><span class="line">@赖赖赖小璇 @1983ztl @aa441834626 @wangfengkui147 @zwk97812 </span><br><span class="line">@zhangxingzz @儿阿丶我是你爹 @猫口i @愿节操不离我身 @十年君归o </span><br><span class="line">@求TD500的ROM @紫翼凌少 @我不是小混球 @497595753 @Zh1老骚 </span><br><span class="line">@蓝黑干掉黄狗 @请叫我洋仔88 @新一代机智哥 @Adobe静攻 @年少的梦水瓶 </span><br><span class="line">@你非韭菜 @时间不多了01 @代号01024 @自闭症Cz @陌生的罗马风 </span><br><span class="line">@zy54dp @灬FromJuly @爱吃回锅肉_ @流浪流浪流浪丶 @_请叫我杰g </span><br><span class="line">@奶熊布偶 @冷莫得小菜鸭 @爱炉石也爱LOL @百闻啊 @汤圆太君 </span><br><span class="line">@冯婉清帅帅帅 @760197867 @陈翔伦9 @我要打遍全世界 @与你高歌 </span><br><span class="line">@l354912275 @七月忧伤丶 @张獻忠 @r谁对不起谁丶 @xiaomingthe </span><br><span class="line">@发病颤抖中 @敢不敢勇敢点 @无聊到爆炸额 @我愿X天长地久 @樱花筱涩狼 </span><br><span class="line">@Udemon @kyojoe7 @人生导师大力哥 @k3_丰 @脾气比胸还大 </span><br><span class="line">@ErycTr1ceps @拖着闪亮的尾巴 @菊花谢了么 @鵬聰 @dfgrsc </span><br><span class="line">@一脚踢傻小胖子 @杨超越头号粉丝 @senxinxu @Broken鈥唖un @嗯哼QnQ </span><br><span class="line">@abcczyg @马勒戈痞得 @树丿先生 @lIIIllIlIlll @只吃趣多多 </span><br><span class="line">@没有过往和明天 @skyohye @乔沃德_达基叭 @烟草zZ @杨氏家族兄弟 </span><br><span class="line">@爱国诗人林则徐 @饶不出你的心 @求你摇了我吧 @wenqwe123456 @shine高高挂 </span><br><span class="line">@请叫我阳哥爸比 @Devotion丶Jy @难得旧梦 @我回来_了m @金牛番茄味西瓜 </span><br><span class="line">@Qjsikfjfjkz @剑持爷爷 @四季碎月 @立花··奏 @b516859219 </span><br><span class="line">@劉一鳥 @揭老底_ @knowIsituation @坑爹雅蠛蝶2 @差点猝死 </span><br><span class="line">@倾听你的寂静丶 @水果馅的包子 @七5491161 @实名制狗就少了 @劃鵀 </span><br><span class="line">@虚言NEUROSE @装B @梵音Flyenjoy @就叫我辉少吧 @牧蛏 </span><br><span class="line">@浅爱那么深Alex @快播伴我10于载 @神威卡卡西牛批 @Chr1stophernm @心若止水么么哒 </span><br><span class="line">@神奈川冲浪鲤 @Zero黑石 @Annian安年 @丨槑人丨 @我与影子孤独 </span><br><span class="line">@竞技至高成就 @kyle__xy @淡朢妳的美 @井盖马车夫 @宇文巨佛 </span><br><span class="line">@希格福赖德 @_C_BEYOND @mylnb岁月 @尘土破译 @营养不良zjj </span><br><span class="line">@疯狂的道术师 @love小琴女 @李老八离婚 @卖馒头大妈 @小赤佬iiiiii </span><br><span class="line">@梦日流年 @ASD大婶 @相识散别 @柴1999 @一枝独秀是吗 </span><br><span class="line">@小小小小小XP @自宫的龙虾 @只因exo太恶心 @江西省吴奇隆 @司马pdd </span><br><span class="line">@chenjianweisky @刘海丶01 @我叫阿余啊 @冠希教你用相机 @单挑咯 </span><br><span class="line">@我错了呜呜 @冰刀270 @看啊双鱼 @读书人好baby @疣蚊图斯 </span><br><span class="line">@内涵名 @q117138379 @贝尔法斯特空军 @鈾氫付鍗婂害 @紅色髙棉 </span><br><span class="line">@灵性选手0 @断桥丶落残雪 @鸦雀陸君 @微笑一瞬间啊 @DirtyBit丶 </span><br><span class="line">@物御 @咕德奶特 @cdf10001 @J2梆硬的老实人 @Kaoru1998 </span><br><span class="line">@莪来温暖你的心 @qq953094920 @不想出 @我吉良吉影只想 @一斥染_ </span><br><span class="line">@之颔 @传说中的Mr明 @破胎 @佩服许仙噉日蛇 @SKTmlxg7 </span><br><span class="line">@陪伴与你i @看见你我呵呵了 @无德清汤 @边缘成员 @禹礼啊 </span><br><span class="line">@末中有纪smile @仙剑游仙1 @xdchdui212345 @誥令 @橙天蛋疼 </span><br><span class="line">@我信I卡勒特 @bilipilibiliok @用户名BTB @曾狗蛋蛋 @雾近青山 </span><br><span class="line">@易尘子c @贼nice @yuehong753 @吾王名曰银桑 @BLACKPINK噻 </span><br><span class="line">@分身吉普赛 @dhdhdfhdhh @北川片口MC @梦境和水墨 @zhongweihao201 </span><br><span class="line">@gupanyuhao @imrukaM @怕大叔擦我 @lialong0 @汽修男丶 </span><br><span class="line">@长泽女士 @杜君oy @我才我1我 @丶医者人心 @好想透你 </span><br><span class="line">@淳风师兄 @三井龟虽寿 @超级黑夜的眼睛 @hugefatbiaor @lijwaun1104 </span><br><span class="line">@断风贤SKY @容忍我爱乀 @￡在吼毛々 @恰柠檬 @幾语 </span><br><span class="line">@mm沧海一锅粥 @293542654cc @小莫贱 @璦霜 @毅然出手 </span><br><span class="line">@阿娃也是人 @465957420 @人类的恐惧 @Jiangwei3166 @冲浪文化 </span><br><span class="line">@神的_天敌 @安阒 @牛人丶锅 @313054319 @王不留行过江东 </span><br><span class="line">@Perfunctor岁月 @164714386 @别惹小吧 @龙鸣给我爬 @干就完事了昂 </span><br><span class="line">@SUNOFBITECH @你来春天也到 @子明1997 @世界不和平啊2 @我爱美屡啦 </span><br><span class="line">@愤怒的地板 @Mr_范特稀 @你这是闹求肾来 @永远都是3比0 @灵魂的自由丶 </span><br><span class="line">@尼玛grent @布鲁斯蝙蝠侠 @我是学长ii @中毒不深灬 @抽象维维尼 </span><br><span class="line">@孤独的根号435 @陆叄贰肆 @CN_天梯_Hope @意识形态很正 @我不例外 </span><br><span class="line">@笑川11 @没有滚啊 @网名都是浮雲 @风吹蛋蛋飘飘然 @囚王西西 </span><br><span class="line">@丶丶情不知所起 @朕还能送一波 @木糖木醇 @娘子军1234568 @高丶冷love </span><br><span class="line">@how龙魂2 @左左木木木 @寡人授天予命 @zhaomin13142 @梨妍訇似蜷佳 </span><br><span class="line">@抱这你爱的吉他 @丶第六大魔王 @拥月之工藤新一 @Rap__God @英俊少年1747 </span><br><span class="line">@我一定被演了 @lhw44552739 @蒲夫纤 @afcgfc @dasasfaf22 </span><br><span class="line">@妳的轻浮放纵了 @Giant丶巨人 @Anry盖饭 @a章彡 @星羽亮 </span><br><span class="line">@涉谷__ @阳光的asfa @席梦殊 @蝅天 @davis的人 </span><br><span class="line">@歪歪shanren @1065647656 @大森林墙纸 @a3418228 @耻尬 </span><br><span class="line">@順逆無二門 @Furyuan6 @做一半爱怕什么 @Carzy灬陌陌 @不知道何为路 </span><br><span class="line">@986509424 @nessss藟 @八百澧 @2556A555 @一脚踹翻饮水机 </span><br><span class="line">@秽翼鲁路修 @noplannogay @逍仕 @灬旧言虐心i @地煞时代 </span><br><span class="line">@popllla @我是新时代青年 @鲨鱼非 @正义的果子狸 @水晶焰_ </span><br><span class="line">@帅哈9 @百撕不得骑姐r2 @激进用户 @Cleverlov @小小顾time </span><br><span class="line">@乱射一腔 @复仇焰熊 @骆华忠干爷爷 @陈意喏 @野生丶奥利奥 </span><br><span class="line">@失望而已丶 @505638523 @Batmansuck @我在都昌偷鼠标 @极冰VX </span><br><span class="line">@日日求剁 @刈麦刀 @SA啊杰 @习惯性_C @卡卡回粉1 </span><br><span class="line">@好一朵金菊花 @1574870879 @独自飞行的舒克 @珠官郡 @zaza1993113 </span><br><span class="line">@夙愿么么 @我看见喂 @磨墨唧唧 @OG_Vanbb @遂州商场厂长 </span><br><span class="line">@久了久了就旧楽 @玛尼哥哥 @文青粪子 @Jing溢求进 @低调可耻但有用 </span><br><span class="line">@好命JB让狗起了 @SQ灬小瀚 @独自去透批 @Aemember @一念亦沉 </span><br><span class="line">@匡威叁仟捌 @迪多i @形象气质佳丶 @萝莉赫斯提亚酱 @当火星来到地球 </span><br><span class="line">@hgdthvb @天天天皇 @爽歪歪歪666 @黄瓜的黄花 @岛梨 </span><br><span class="line">@溅人丁 @阙子陵 @为了祖国繁荣富 @youmotherdie @渡己i </span><br><span class="line">@WHATDO3 @泼粪工2 @170的老帕 @爱狂三爱生活 @唐叶重 </span><br><span class="line">@黑熊ccccccc @beginner2c @Sleepthief @子豪粉丝_ZERO @地铁带篮子 </span><br><span class="line">@魔登骚年 @劲友F9TN @奇迹逆天 @辸卡威 @守塔 </span><br><span class="line">@IndianRubber_ @AKash1Se @慕城Provence @热情的2加2 @太君母狗必死 </span><br><span class="line">@c位出殡 @糖分控55 @Zzzcccyo @今夜打老虎46 @DarKXXxXY </span><br><span class="line">@想起二死定 @还有点小激动豪 @OMGganganing @晒达 @无解的起名 </span><br><span class="line">@14982679 @鱼斯坦丁 @你很羞愧吧 @艾森牛奶 @b1ank丶式 </span><br><span class="line">@godxin66 @VampireWind @w独行者wang @蘭思若雨 @秋雨凉人a </span><br><span class="line">@AmorHicky @miao04521 @和罓谐罓者 @夏川真涼_ @你沒聽過 </span><br><span class="line">@初言墨年i @债我 @乘风破浪481 @跳梁_小丑i @lurenysjsnss </span><br><span class="line">@小汁汁4号 @社会你龘哥 @Ohgoodhunter @文明冲浪的小蒋 @眞钞换你贞操 </span><br><span class="line">@往后再不提从前 @范德萌不萌 @南阳精神灬领袖 @青衫戏子本无情 @吾辈乃馒头 </span><br><span class="line">@SiusCheung @光bobo丶 @儿子快给碟咬 @亡鱼是海的魂嚒 @一生一个滢 </span><br><span class="line">@Dolldu @Poptholothy @Elpsycongr0o @偷鸟狂魔罗伊斯 @又让你们贱笑了 </span><br><span class="line">@蓝色的死胖子 @A923778510 @_蛋蛋的悠伤_ @半仙和半疯 @大炮穿墙 </span><br><span class="line">@尛尛灬尐殇 @第七号节操铺 @maliksubi @19959251234 @搞事咖 </span><br><span class="line">@拿大刀砍2B @zzcd岁月 @尼玛德什嫂比 @Mrl小鸥 @85803418z </span><br><span class="line">@Leshphon0 @進繫的厶宅 @你的野爹09 @今晚买龙票 @meft345 </span><br><span class="line">@蛋疼治疗诊所 @比利布伦特 @彩电5 @周流六虚9 @槽逆 </span><br><span class="line">@说到底只是梦 @抽象带恶人 @是故意嘛 @不在服务区256 @山根万理奈7 </span><br><span class="line">@ghf45660 @你死或我活 @缺角的琴 @电竞李伯清five @米斯特多格尔 </span><br><span class="line">@527流言 @Mr丶solitude @Shall丶dream灬 @千百虑 @baby_____丶L </span><br><span class="line">@S5LGD夺冠 @VampireBloodyX @普天之下熊为大 @An_xiaoqiu @you597818033 </span><br><span class="line">@L阳阳阳阳丶 @难道我是基 @久吉绝味8023 @雨夜一叶静 @訪文 </span><br><span class="line">@神我该如何抉择 @眉宇柔光 @Light丶boy @专业奇葩防围观 @lol无聊他哥 </span><br><span class="line">@蚝蛯 @clear乯love @大一校园扛把子 @偏执的风子 @鍙跺嵖榛橉煒 </span><br><span class="line">@Soaraor @爱吃包仔 @飞天带草 @抜剑起长歌丶 @阿瞒字萌德 </span><br><span class="line">@和蔼的fzw1230 @葫芦爷爷丶丶 @jxj神888 @风里雨里吧等你 @TFBOY参加WWE </span><br><span class="line">@彩虹啊美 @唐老大566 @你咋回事啊贴纸 @DOVE刘薪 @风中追砜 </span><br><span class="line">@白塔中的小学生 @浅蓝色的天空丶 @wsljegg @人工置顶17号 @不是北鼻 </span><br><span class="line">@王闯458 @带丨带小面码 @夜太美lemon @究极葫芦娃 @似曾相识的手表 </span><br><span class="line">@Rumuki @衤申角虫 @却叹清风不结语 @泥巴爱你媽 @sky白羊钦 </span><br><span class="line">@梅川内酷滴人 @suxiaojun333 @头号死妈嗨粉 @永爱丶抱抱 @帅朱超 </span><br><span class="line">@皮狗队队长1 @叫弘扬 @宠物懵 @物语七七七 @jklhhyy </span><br><span class="line">@哟莎莎是是 @hornetsking @时间似深海zzz @邪哥帅过吴彦祖 @wertysnow </span><br><span class="line">@将他们冲散 @nice乳酸君 @天真WU邪丶 @420号航班 @韡哥123 </span><br><span class="line">@那个沉沦的骚年 @远位反 @白洁钰慧 @THE代代 @半莳 </span><br><span class="line">@zzzyd59 @不渝瑜心 @小龍鳴貳號 @mama2223 @桐原亮司的剪刀 </span><br><span class="line">@starsonder @农村首席Dj @万元神机玩扫雷 @寂寞第三秒 @racegrey </span><br><span class="line">@初夏浅意流逝 @名字被狗日 @阿星阿星哦 @东百快乐 @我真是个废物吖 </span><br><span class="line">@竹下野1 @9878ek @我永远爱冯雪娟 @Lio老扁 @丶寸心笑傲 </span><br><span class="line">@这么刁呀 @华丽曦穆 @冬瓜不是瓜是人 @用嘲 @a511011523 </span><br><span class="line">@萌面侠day @双鱼座丶gg @澤水困 @弱智絔度 @奥巴囧 </span><br><span class="line">@楼主竟然喜当爹 @处py4 @伴夜k樺落 @学前班的小生 @妹控也要开敢达 </span><br><span class="line">@BhopLong丶明非 @yl冰冷深渊 @科比野爹 @Newbee丶Dade @不敢和他作对 </span><br><span class="line">@再战女人心i @找准了合作之道 @花花啊456 @虚神降临 @散人龙哥 </span><br><span class="line">@做梦都想胖10斤 @像风一样lqq @kmmk5446 @感情如此颓废 @uptownpunk </span><br><span class="line">@明天做的是笨蛋 @只要跳出来 @BhopLong丶Naek @仙茶一不死 @饮泣的你冻吗z </span><br><span class="line">@搞基智慧生物 @0520wc @ok彩色鸟 @诸葛问天free @茨于 </span><br><span class="line">@ww19981119 @ys不浪漫罪名 @Mauue @幻影之騎士 @l老子是癞蛤蟆 </span><br><span class="line">@撸则亡 @熱啜 @鏉庢竻楂樷槝锔 @一个假账号 @G_stewie </span><br><span class="line">@jrdhfubshc @MasterACM @jiaoxy2 @继承火之意者 @qalllp </span><br><span class="line">@羽落飞逝灬 @停机rtjt @天河雪琼丶 @爱笑的yhblsqt @225k天枰 </span><br><span class="line">@Gao971030 @964040138 @wret20 @清心寺方丈 @不再宇宙无敌 </span><br><span class="line">@狠斗撸字一闪念 @温醜 @数学维 @HT_Frostmourne @道初卸 </span><br><span class="line">@qqq18232484682 @z1092402758 @从心刚刚好 @csu一叶知秋 @ztd19960630 </span><br><span class="line">@boom风暴者 @狗间失格 @纯情di哥哥 @影子99熊 @Immortal__lee </span><br><span class="line">@餍物语 @哀远道 @杀死蔡徐坤 @鼻孔里的大猩猩 @ezhm2ucks836 </span><br><span class="line">@玩玩还得起名字 @怒龙咆哮丶 @roger8860 @国服第一电冰箱 @能说法克吗 </span><br><span class="line">@HX丶阿睿 @鹿小枫c @killerddt @霸气熏天啊 @正在读取下一页 </span><br><span class="line">@喜旧之人阿 @叹服雪花谣 @蛤皮一蛤 @手冲术士 @你说往事随风l </span><br><span class="line">@内涵绅士33 @作死卍 @荒极有红鱼 @甜味糖女巫 @中国搜狗集团 </span><br><span class="line">@都是戏er已 @带带大咸鱼 @陈不二你好吗 @热情的zy @以两步半笑六步 </span><br><span class="line">@风笑美凌格 @穿裆真巨头波什 @ComerZZZ @小小酒鬼year @韬字没有猥 </span><br><span class="line">@LZ丶不羁 @俩单眼皮很犀利 @Amor_Ylin @银河落玖天 @紫and白 </span><br><span class="line">@天坑狗叫 @留不住的夜 @哼哈一百 @中单鸣人 @少年毛豆的漂流 </span><br><span class="line">@可能会不在意 @回头…一巴掌 @孙吧二千先生 @clan来吃 @Sher1ock96 </span><br><span class="line">@奥·新巫妖王 @郁謑 @玩米 @桃之夭夭Trust @你看我的头很铁 </span><br><span class="line">@天河昭昭 @贵族颩挌 @滴滴滴穴深卡 @阿帅上 @伊万的Ak </span><br><span class="line">@著墨染yu136 @__一抹丶微笑__ @最冷一天wuwu @反人1 @虚空大佐 </span><br><span class="line">@x斗逗w @xiaobalu2010 @口爆楼主i @假笑_苦笑_冷笑 @zrtsxx </span><br><span class="line">@TNT馃惔 @一只打野小提莫 @喜闻乐见_X @927丶96 @重开了 </span><br><span class="line">@监管独狼 @嘿嘿天气不错 @哥曾低调过 @七铭七 @内置葛炮 </span><br><span class="line">@夜店持枪灭婊 @叫我西瓜大狼丶 @梦回丶丿 @djfhjggv @假扮梁朝伟 </span><br><span class="line">@Seemingly冫 @不雨潇潇丶 @屴先森 @萌萌哒得的放肆 @訸纥 </span><br><span class="line">@逐焚 @额丶额40 @故事听完就走吧 @名很认真的 @言小骨 </span><br><span class="line">@幼年金成武 @我这个v脚本 @Chan丶阿怪 @今日离婚 @狂三dsk </span><br><span class="line">@杨之洲123 @却念你好深灬 @zjsm18 @有点知觉 @持枪灭婊1945 </span><br><span class="line">@窑子常客 @614373549 @习惯禁止评论00 @疯一样的度娘 @1262833145 </span><br><span class="line">@一头小神受 @Elom与DoDo @捧花献予你 @他们叫我凯撒 @a531567235 </span><br><span class="line">@道上人叫我曰天 @a1912159994 @永福体验 @悦己无痕 @人本劣 </span><br><span class="line">@求强效增肥药 @bestialthing @Winny馃惢 @名字怎么取77 @great我是46 </span><br><span class="line">@Deadlypoison丶 @晴色过青山 @愉快的睡眠 @老哥稳如一条狗 @空城旧梦Mshine </span><br><span class="line">@西不毒 @Huo在当下丶 @我是小淘气鬼 @吃太阳的小地球 @提你尊臀来见我 </span><br><span class="line">@抽象周树人 @sungoudedie @加内射 @呵呵好吧deS @中出姜虐虐 </span><br><span class="line">@萌哒娘 @该狂就狂不隐藏 @取网名不容易额 @黄1150 @雨天爆菊花</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>技术无关</tag>
      </tags>
  </entry>
</search>
