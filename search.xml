<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2019/10/12/%E4%BD%BF%E7%94%A8Hexo+Github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><a href="https://hexo.io/index.html" target="_blank" rel="noopener">Hexo</a>是一个快速、简洁且高效的博客框架, 基于Node.js</p>
<p><a href="https://github.com" target="_blank" rel="noopener">Github</a>可以为每一个repository提供一个Github Pages, 但默认是不开启的.</p>
<p>我们通过Hexo生成静态页面, 然后将其同步至远程仓库, 作为某个repository的Github Page, 这样就可以直接在Github上访问了.</p>
<a id="more"></a>

<p>搭建过程分为三步:</p>
<ol>
<li>在github上建立一个repository并开启Github Page.</li>
<li>用Hexo在本地创建博客.</li>
<li>安装git, 并将Hexo部署到远程仓库.</li>
</ol>
<p>之后, 就可以访问搭建在Github的博客页面了.</p>
<hr>
<h3 id="创建repository并开启Github-Page"><a href="#创建repository并开启Github-Page" class="headerlink" title="创建repository并开启Github Page"></a>创建repository并开启Github Page</h3><ol>
<li>创建一个repository, repository name 设置为<strong><span style="color: deeppink;">username</span>.github.io</strong>(推荐, 这样生成的访问地址最为简短)</li>
<li>进入repository的setting页面, 找到GitHub Pages一节, 点击<code>choose a theme</code></li>
<li>选中一个主题, 然后select theme, 再之后会自动创建一个<code>index.md</code>文件, 无需修改, 直接commit changes</li>
<li>之后再进入repository的setting界面, 找到Github Pages一节, 已经出现提示:<strong>Your site is published at <span style="color: deeppink;">URL<span></span></span></strong></li>
<li>直接在浏览器中访问该URL, 至此Github Page开启成功.</li>
</ol>
<hr>
<h3 id="使用Hexo创建个人博客"><a href="#使用Hexo创建个人博客" class="headerlink" title="使用Hexo创建个人博客"></a>使用Hexo创建个人博客</h3><ol>
<li>安装node.js </li>
<li>阅读Hexo文档, 安装Hexo, 并使用Hexo创建一个博客项目, 搭建个人博客.</li>
</ol>
<hr>
<h3 id="使用git部署博客"><a href="#使用git部署博客" class="headerlink" title="使用git部署博客"></a>使用git部署博客</h3><ol>
<li><p>安装git, 完成后在命令行输入<code>git version</code>确认安装成功</p>
</li>
<li><p>打开repostory页面, 点击<code>Clone or download</code>, 弹出来的小框里选择右上角<code>Use HTTPS</code>, 之后复制出现的URL</p>
</li>
<li><p>在上一步中, repository的URL为<code>https</code>开头, 意味着会使用https协议进行远程仓库的连接</p>
</li>
<li><p>打开Hexo创建的项目的根目录下<code>_config.yml</code>文件, 该文件是一个<strong>YAML</strong> <em>[/ˈjæməl/]</em>语法的配置文件</p>
</li>
<li><p>找到deploy一节, 更改为如下形式, URL指的是第2步获得的URL.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: URL</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换至本地hexo项目根目录, 安装相关库, <code>npm install hexo-deployer-git —save</code></p>
</li>
<li><p>之后使用hexo部署命令: <code>hexo d</code>, 进行远程部署</p>
</li>
<li><p>在部署过程中, 会弹出github的账号密码输入框, 正确输入并确认, 之后会进行部署</p>
</li>
</ol>
<p>到此, 部署成功, 访问该repostory的Github Page的URL, 显示效果与本地一致.</p>
<p>之后每次写博客之后, 使用<code>hexo d</code>命令部署即可. </p>
<p>如果更新博客之后, 部署命令显示无新内容, 使用<code>hexo clean</code>清除缓存, 然后再次尝试部署.</p>
<p>因为缓存的原因, 每次同步之后可能要稍等几分钟才能在Github Page中生效.</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>26. 设置 Settings</title>
    <url>/2019/10/03/26.%20%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>命名空间是一个很好的主意, 发扬光大吧!   – python之禅</p>
</blockquote>
<p>REST-framework的设置的命名空间被包含在单个Django设置项中, 即<code>REST_FRAMEWORK</code>.</p>
<p>例如, 在Django项目的<code>settings.py</code>文件中, 可能包含如下内容:</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="访问设置项"><a href="#访问设置项" class="headerlink" title="访问设置项"></a>访问设置项</h3><p>如果需要在项目中访问REST-framework的设置项的值, 需要使用<code>api_settings</code>对象, 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.settings <span class="keyword">import</span> api_settings</span><br><span class="line"></span><br><span class="line">print(api_settings.DEFAULT_AUTHENTICATION_CLASSES)</span><br></pre></td></tr></table></figure>

<p><code>api_settings</code>对象会检查所有用户定义的设置项, 以及未设置项的默认值. </p>
<p>任何使用字符串表示其导出路径的类会自动返回该类<strong>本身</strong>, 而非字符串. </p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="API策略设置"><a href="#API策略设置" class="headerlink" title="API策略设置"></a>API策略设置</h3><hr>
<h4 id="默认渲染器类"><a href="#默认渲染器类" class="headerlink" title="默认渲染器类"></a>默认渲染器类</h4><p><strong>DEFAULT_RENDERER_CLASSES</strong> </p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">    <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="默认解析器类"><a href="#默认解析器类" class="headerlink" title="默认解析器类"></a>默认解析器类</h4><p><strong>DEFAULT_PARSER_CLASSES</strong></p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">    <span class="string">'rest_framework.authentication.BasicAuthentication'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="默认权限类"><a href="#默认权限类" class="headerlink" title="默认权限类"></a>默认权限类</h4><p><strong>DEFAULT_PERMISSION_CLASSES</strong></p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">'rest_framework.permissions.AllowAny'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="默认限流类"><a href="#默认限流类" class="headerlink" title="默认限流类"></a>默认限流类</h4><p><strong>DEFAULT_THROTTLE_CLASSES</strong></p>
<p>数据格式: 字符串列表/元组</p>
<p>默认值: <code>[]</code></p>
<hr>
<h4 id="默认请求协商类"><a href="#默认请求协商类" class="headerlink" title="默认请求协商类"></a>默认请求协商类</h4><p><strong>DEFAULT_CONTENT_NEGOTIATION_CLASS</strong></p>
<p>数据格式: 字符串</p>
<p>默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'rest_framework.negotiation.DefaultContentNegotiation'</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="默认概要类"><a href="#默认概要类" class="headerlink" title="默认概要类"></a>默认概要类</h3><p><strong>DEFAULT_SCHEMA_CLASS</strong></p>
<p>数据格式: 字符串</p>
<p>默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'rest_framework.schemas.AutoSchema'</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通用视图设置"><a href="#通用视图设置" class="headerlink" title="通用视图设置"></a>通用视图设置</h2><p>以下设置项控制通用CBV的行为.</p>
<hr>
<h3 id="默认过滤后端"><a href="#默认过滤后端" class="headerlink" title="默认过滤后端"></a>默认过滤后端</h3><p><strong>DEFAULT_FILTER_BACKENDS</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[]</code></p>
<hr>
<h3 id="默认分页类"><a href="#默认分页类" class="headerlink" title="默认分页类"></a>默认分页类</h3><p><strong>DEFAULT_PAGINATION_CLASS</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="分页大小"><a href="#分页大小" class="headerlink" title="分页大小"></a>分页大小</h3><p><strong>PAGE_SIZE</strong></p>
<p>数据类型: 整型</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="搜索参数名"><a href="#搜索参数名" class="headerlink" title="搜索参数名"></a>搜索参数名</h3><p><strong>SEARCH_PARAM</strong></p>
<p>用以调用查询后端的查询参数名</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>search</code></p>
<hr>
<h3 id="排序参数名"><a href="#排序参数名" class="headerlink" title="排序参数名"></a>排序参数名</h3><p><strong>ORDERING_PARAM</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>ordering</code></p>
<hr>
<h2 id="版本设置"><a href="#版本设置" class="headerlink" title="版本设置"></a>版本设置</h2><hr>
<h3 id="默认版本"><a href="#默认版本" class="headerlink" title="默认版本"></a>默认版本</h3><p><strong>DEFAULT_VERSION</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="允许的版本"><a href="#允许的版本" class="headerlink" title="允许的版本"></a>允许的版本</h3><p><strong>ALLOWED_VERSION</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>None</code></p>
<hr>
<h3 id="版本参数名"><a href="#版本参数名" class="headerlink" title="版本参数名"></a>版本参数名</h3><p><strong>VERSION_PARAM</strong></p>
<p>用以指示版本的查询参数名或url变量名或其他指示版本的相关参数名</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>version</code></p>
<hr>
<h2 id="认证设置"><a href="#认证设置" class="headerlink" title="认证设置"></a>认证设置</h2><h3 id="默认未认证用户"><a href="#默认未认证用户" class="headerlink" title="默认未认证用户"></a>默认未认证用户</h3><p><strong>UNAUTHENTICATED_USER</strong></p>
<p>未经认证的请求中的<code>request.user</code>属性中应当填充的类, 如果完全取消认证时, 该项应当被设为<code>None</code></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>django.contrib.auth.models.AnonymousUser</code></p>
<hr>
<h3 id="默认未认证凭证"><a href="#默认未认证凭证" class="headerlink" title="默认未认证凭证"></a>默认未认证凭证</h3><p><strong>UNAUTHENTICATED_TOKEN</strong></p>
<p>同上, 需要为未认证请求的<code>.auth</code>属性填充的类.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>None</code></p>
<hr>
<h2 id="测试设置"><a href="#测试设置" class="headerlink" title="测试设置"></a>测试设置</h2><p>以下各项控制<code>APIRequestFactory</code>和<code>APIClient</code>的行为.</p>
<hr>
<h3 id="默认测试请求的数据格式"><a href="#默认测试请求的数据格式" class="headerlink" title="默认测试请求的数据格式"></a>默认测试请求的数据格式</h3><p><strong>TEST_REQUEST_DEFAULT_FORMAT</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>multipart</code></p>
<hr>
<h3 id="测试请求渲染类"><a href="#测试请求渲染类" class="headerlink" title="测试请求渲染类"></a>测试请求渲染类</h3><p><strong>TEST_REQUEST_RENDERER_CLASSES</strong> </p>
<p>数据类型: 字符串列表</p>
<p>默认值: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &apos;rest_framework.renderers.MultiPartRenderer&apos;,</span><br><span class="line">    &apos;rest_framework.renderers.JSONRenderer&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API概要生成控制"><a href="#API概要生成控制" class="headerlink" title="API概要生成控制"></a>API概要生成控制</h2><h3 id="概要强制路径主键"><a href="#概要强制路径主键" class="headerlink" title="概要强制路径主键"></a>概要强制路径主键</h3><p><strong>SCHEMA_COERCE_PATH_PK</strong></p>
<p>是否在生成url时将路径中的<code>PK</code>标识符映射至实际字段名, 通常为<code>id</code>. 这会给出更清晰的概念, 因为主键是一个实现细节, 而标识符则是一个通用概念. </p>
<p>数据类型: 布尔型</p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="概要强制方法名"><a href="#概要强制方法名" class="headerlink" title="概要强制方法名"></a>概要强制方法名</h3><p><strong>SCHEMA_COERCE_METHOD_NAMES</strong></p>
<p>定义一个映射关系, 用以将视图集的方法名映射为表义更清晰的外部操作名.</p>
<p>数据类型: Dict</p>
<p>默认值: <code>{&#39;retrieve&#39;: &#39;read&#39;, &#39;destroy&#39;: &#39;delete&#39;}</code></p>
<hr>
<h2 id="内容类型控制"><a href="#内容类型控制" class="headerlink" title="内容类型控制"></a>内容类型控制</h2><hr>
<h3 id="URL格式重写"><a href="#URL格式重写" class="headerlink" title="URL格式重写"></a>URL格式重写</h3><p><strong>URL_FORMAT_OVERRIDE</strong></p>
<p>用以表示重写默认内容协商<code>Accept</code>结果的URL参数名, 设为<code>None</code>时禁用.</p>
<p>示例: <code>http://example.com/organizations/?format=csv</code></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>format</code></p>
<hr>
<h3 id="格式后缀关键字"><a href="#格式后缀关键字" class="headerlink" title="格式后缀关键字"></a>格式后缀关键字</h3><p><strong>FORMAT_SUFFIX_KWARG</strong></p>
<p><strong>可能</strong>用以给URL提供格式后缀的关键字参数名, 在使用<code>format_suffix_patterns</code>时会使用该项设置.</p>
<p>示例: <code>http://example.com/organizations.csv/</code>, <code>.csv</code>会匹配至<code>format</code>变量名</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>format</code></p>
<hr>
<h2 id="日期时间格式"><a href="#日期时间格式" class="headerlink" title="日期时间格式"></a>日期时间格式</h2><p>以下设置项控制日期和时间类型被如何解析和渲染.</p>
<hr>
<h3 id="DateTime的渲染格式"><a href="#DateTime的渲染格式" class="headerlink" title="DateTime的渲染格式"></a>DateTime的渲染格式</h3><p><strong>DATETIME_FORMAT</strong></p>
<p>在渲染序列化器<code>DateTimeField</code>字段时为其使用的格式字符串, 如果设为<code>None</code>, 返回的是python中<code>datetime</code>对象, 编码则取决于渲染器.</p>
<p>可以为 <code>None</code>, <code>iso-8601</code>或python中srtftime format可用的字符串.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>iso-8601</code></p>
<hr>
<h3 id="DateTime的输入解析格式"><a href="#DateTime的输入解析格式" class="headerlink" title="DateTime的输入解析格式"></a>DateTime的输入解析格式</h3><p><strong>DATETIME_INPUT_FORMATS</strong></p>
<p>可以用以解析原始数据以传入序列化器<code>DateTimeField</code>的格式字符串的列表.</p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[&#39;iso-8601&#39;]</code></p>
<hr>
<h3 id="Date渲染格式"><a href="#Date渲染格式" class="headerlink" title="Date渲染格式"></a>Date渲染格式</h3><p><strong>DATE_FORMAT</strong></p>
<p>与<code>DATETIME_FORMAT</code>类似, 但作用于<code>DateField</code></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>iso-8601</code></p>
<hr>
<h3 id="Date输入解析格式"><a href="#Date输入解析格式" class="headerlink" title="Date输入解析格式"></a>Date输入解析格式</h3><p><strong>DATE_INPUT_FORMATS</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[&#39;iso-8601&#39;]</code></p>
<hr>
<h3 id="TIME渲染格式"><a href="#TIME渲染格式" class="headerlink" title="TIME渲染格式"></a>TIME渲染格式</h3><p><strong>TIME_FORMAT</strong></p>
<p>数据类型: 字符串</p>
<p>默认值: <code>iso-8601</code></p>
<hr>
<h3 id="Time输入解析格式"><a href="#Time输入解析格式" class="headerlink" title="Time输入解析格式"></a>Time输入解析格式</h3><p><strong>TIME_INPUT_FORMATS</strong></p>
<p>数据类型: 字符串列表</p>
<p>默认值: <code>[&#39;iso-8601&#39;]</code></p>
<hr>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="UNICODE-JSON-允许unicode字符的JSON响应"><a href="#UNICODE-JSON-允许unicode字符的JSON响应" class="headerlink" title="UNICODE_JSON 允许unicode字符的JSON响应"></a>UNICODE_JSON 允许unicode字符的JSON响应</h3><p>设为True时, json响应将允许unicode字符.</p>
<p>例如: <code>{&quot;unicode black star&quot;:&quot;★&quot;}</code></p>
<p>当设置为False, json响应将对非ASCII字符进行转义</p>
<p>例如: <code>{&quot;unicode black star&quot;:&quot;\u2605&quot;}</code></p>
<p>数据类型: 布尔型</p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="COMPACT-JSON-紧缩格式的JSON响应"><a href="#COMPACT-JSON-紧缩格式的JSON响应" class="headerlink" title="COMPACT_JSON 紧缩格式的JSON响应"></a>COMPACT_JSON 紧缩格式的JSON响应</h3><p>设为True时, json响应的<code>,</code>和<code>:</code>之后不会有空格, 例如: </p>
<p><code>{&quot;is_admin&quot;:false,&quot;email&quot;:&quot;jane@example&quot;}</code></p>
<p>设为False则为略带冗余的格式, 例如: </p>
<p><code>{&quot;is_admin&quot;: false, &quot;email&quot;: &quot;jane@example&quot;}</code></p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="STRICT-JSON-严格JSON"><a href="#STRICT-JSON-严格JSON" class="headerlink" title="STRICT_JSON 严格JSON"></a>STRICT_JSON 严格JSON</h3><p>当设为<code>True</code>时, json渲染时会验证检查json语法的正确性, 并确保不会使用不被广泛接受的值.</p>
<p>默认值: <code>True</code></p>
<hr>
<h3 id="COERCE-DECIMAL-TO-STRING-强制将十进制转为字符串"><a href="#COERCE-DECIMAL-TO-STRING-强制将十进制转为字符串" class="headerlink" title="COERCE_DECIMAL_TO_STRING 强制将十进制转为字符串"></a>COERCE_DECIMAL_TO_STRING 强制将十进制转为字符串</h3><p>在不支持本机十进制类型的API表示形式中返回十进制对象时, 通常最好将该值作为字符串返回以避免了二进制浮点实现所带来的精度损失.</p>
<p>设为True时, 序列化器字段<code>DecimalField</code>会返回字符串而非十进制对象.</p>
<p>默认值:<code>True</code></p>
<hr>
<h2 id="视图命名和描述"><a href="#视图命名和描述" class="headerlink" title="视图命名和描述"></a>视图命名和描述</h2><p>以下选项控制如何生成收到<code>option</code>请求时返回的视图名和描述.</p>
<hr>
<h3 id="VIEW-NAME-FUNCTION-生成视图名的函数"><a href="#VIEW-NAME-FUNCTION-生成视图名的函数" class="headerlink" title="VIEW_NAME_FUNCTION 生成视图名的函数"></a>VIEW_NAME_FUNCTION 生成视图名的函数</h3><p>一个用以生成视图名的函数的路径的字符串. </p>
<p>该函数的签名需为: <code>view_name(self)</code></p>
<p>self: 该view实例. 通常命名函数会检查<strong>类名</strong>, 通过访问<code>self.__class__.__name__</code>.</p>
<p>如果视图继承自<code>ViewSet</code>, 可能会在初始化时包含一些可选参数:</p>
<ol>
<li>name 明确指定的视图名</li>
<li>suffix 区分视图集中各个视图时使用的文本, 与<code>name</code>参数互斥</li>
<li>detail 是否是<code>detail</code>操作视图</li>
</ol>
<p>(视图集中每个视图都需要不同的视图名)</p>
<p>数据类型: 字符串(路径)</p>
<p>默认值: <code>rest_framework.views.get_view_name</code></p>
<hr>
<h3 id="VIEW-DESCRIPTION-FUNCTION-生成视图描述的函数"><a href="#VIEW-DESCRIPTION-FUNCTION-生成视图描述的函数" class="headerlink" title="VIEW_DESCRIPTION_FUNCTION 生成视图描述的函数"></a>VIEW_DESCRIPTION_FUNCTION 生成视图描述的函数</h3><p>一个表示函数路径的字符串, 该函数用以生成视图描述</p>
<p>该函数签名需为: <code>view_description(self, html=False)</code></p>
<p>self: 该view实例. 通常应当检查该view的描述性属性, 通过访问<code>self.__class__.__doc__</code><br>html: 是否需要在html输入中包含, 设为True会在browseable API中显示, 设为False会仅在产生<code>OPTION</code>响应时使用.</p>
<p>如果该视图继承自<code>ViewSet</code>, 可能会在初始化时包含一些可选参数:</p>
<ol>
<li>description: 明确指定的描述性文本属性.</li>
</ol>
<p>数据类型: 字符串(路径)</p>
<p>默认值: <code>rest_framework.views.get_view_description</code></p>
<hr>
<h2 id="HTML页面选项截断"><a href="#HTML页面选项截断" class="headerlink" title="HTML页面选项截断"></a>HTML页面选项截断</h2><p>在某个关系字段被渲染至browseable API页面时, 对于关系字段会给出可用选项, 需要指定最多展示多少个选项以及截断时的文本.</p>
<hr>
<h3 id="HTML-SELECT-CUTOFF-HTML选项截断"><a href="#HTML-SELECT-CUTOFF-HTML选项截断" class="headerlink" title="HTML_SELECT_CUTOFF HTML选项截断"></a>HTML_SELECT_CUTOFF HTML选项截断</h3><p>html页面中, 关系字段最多显示多少个选项. <code>html_cutoff</code>属性的全局设置.</p>
<p>数据类型: 整型</p>
<p>默认值: <code>1000</code></p>
<hr>
<h3 id="HTML-SELECT-CUTOFF-TEXT-HTML选项截断文本"><a href="#HTML-SELECT-CUTOFF-TEXT-HTML选项截断文本" class="headerlink" title="HTML_SELECT_CUTOFF_TEXT HTML选项截断文本"></a>HTML_SELECT_CUTOFF_TEXT HTML选项截断文本</h3><p>html页面中, 在选项截断处显示的文本. <code>html_cutoff_text</code>属性的全局设置.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>More than {count} items...</code></p>
<hr>
<h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><h3 id="默认异常处理器"><a href="#默认异常处理器" class="headerlink" title="默认异常处理器"></a>默认异常处理器</h3><p><strong>EXCEPTION_HANDLER</strong></p>
<p>该函数需有签名 <code>exception_handler(exc, context)</code></p>
<p>数据类型: 字符串(路径)</p>
<p>默认值: <code>rest_framework.views.exception_handler</code></p>
<hr>
<h3 id="字段无关的错误关键字"><a href="#字段无关的错误关键字" class="headerlink" title="字段无关的错误关键字"></a>字段无关的错误关键字</h3><p><strong>NON_FIELD_ERRORS_KEY</strong></p>
<p>出现在errors中的与任何字段无关的出错信息的关键字.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>non_field_errors</code></p>
<hr>
<h3 id="URL字段名"><a href="#URL字段名" class="headerlink" title="URL字段名"></a>URL字段名</h3><p><strong>URL_FIELD_NAME</strong></p>
<p>在使用<code>HyperlinkedModelSerializer</code>时, 应用于超链接的字段名.</p>
<p>数据类型: 字符串</p>
<p>默认值: <code>url</code></p>
<hr>
<h3 id="代理数量"><a href="#代理数量" class="headerlink" title="代理数量"></a>代理数量</h3><p><strong>NUM_PROXIES</strong></p>
<p>0或更大的整型, 指明API运行在几层代理之后, 允许<strong>限流</strong>功能更准确的判断客户端ip地址. </p>
<p>如果设置为None, 限流类将会使用不严格匹配来进行限流. </p>
<p>数据类型: 整型, <code>None</code></p>
<p>默认值: <code>None</code></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>25. 测试 Testing</title>
    <url>/2019/10/03/25.%20%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>无测试的代码就是设计好的失败.   — Jacob Kaplan-Moss</p>
</blockquote>
<p>REST-framework 包含了一些辅助类用以拓展Django现存的测试框架, 并增强了对发起API请求的支持.</p>
<a id="more"></a>

<hr>
<h2 id="APIRequestFactory"><a href="#APIRequestFactory" class="headerlink" title="APIRequestFactory"></a>APIRequestFactory</h2><p>拓展了Django的<a href="https://docs.djangoproject.com/en/stable/topics/testing/advanced/#django.test.client.RequestFactory" target="_blank" rel="noopener">RequestFactory</a></p>
<hr>
<h3 id="创建测试请求"><a href="#创建测试请求" class="headerlink" title="创建测试请求"></a>创建测试请求</h3><p><code>APIRequestFactory</code>支持与Django的<code>RequestFactory</code>相同的接口, 包括<code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.patch()</code>, <code>.delete()</code>, <code>.head()</code>和<code>.options()</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APIRequestFactory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the standard RequestFactory API to create a form POST request</span></span><br><span class="line">factory = APIRequestFactory()</span><br><span class="line">request = factory.post(<span class="string">'/notes/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="使用format参数"><a href="#使用format参数" class="headerlink" title="使用format参数"></a>使用<code>format</code>参数</h4><p>附加请求体的方法例如<code>post</code>, <code>put</code>和<code>patch</code>, 会包括一个<code>format</code>参数, 用以简单地生成非multipart form data地内容类型的请求, 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a JSON POST request</span></span><br><span class="line">factory = APIRequestFactory()</span><br><span class="line">request = factory.post(<span class="string">'/notes/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;, format=<span class="string">'json'</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下, 可用的格式为<code>multipart</code>和<code>json</code>, 为了兼容Django现存的<code>RequestFactory</code>的默认格式<code>multiparty</code>.</p>
<p>要支持更多的请求格式, 或更改默认的格式, 查看本节<code>设置</code>部分. </p>
<hr>
<h4 id="指定请求体的编码"><a href="#指定请求体的编码" class="headerlink" title="指定请求体的编码"></a>指定请求体的编码</h4><p>如果要明确指明请求体部分的编码, 需要设置<code>content_type</code>标识. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request = factory.post(<span class="string">'/notes/'</span>, json.dumps(&#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;), content_type=<span class="string">'application/json'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="使用form-data进行PUT和PATCH"><a href="#使用form-data进行PUT和PATCH" class="headerlink" title="使用form data进行PUT和PATCH"></a>使用form data进行PUT和PATCH</h3><p>在使用<code>APIRequestFactory</code>时, 除<code>post</code>方法之外的请求会自动编码为multipart form data.</p>
<p>例如使用<code>APIRequestFactory</code>发起PUT请求:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factory = APIRequestFactory()</span><br><span class="line">request = factory.put(<span class="string">'/notes/547/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'remember to email dave'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="强制身份认证"><a href="#强制身份认证" class="headerlink" title="强制身份认证"></a>强制身份认证</h3><p>当使用请求工厂测试视图时, 通常能够很方便地对直接请求进行身份验证, 而不必构造正确的身份验证凭据.</p>
<p>要强制认证一个请求, 使用<code>force_authenticate()</code>方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> force_authenticate</span><br><span class="line"></span><br><span class="line">factory = APIRequestFactory()</span><br><span class="line">user = User.objects.get(username=<span class="string">'olivia'</span>)</span><br><span class="line">view = AccountDetail.as_view()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make an authenticated request to the view...</span></span><br><span class="line">request = factory.get(<span class="string">'/accounts/django-superstars/'</span>)</span><br><span class="line">force_authenticate(request, user=user)</span><br><span class="line">response = view(request)</span><br></pre></td></tr></table></figure>

<p>签名: <code>force_authenticate(request, user=None, token=None)</code></p>
<p>当调用该方法时, 至少设置user或token其中一项.</p>
<p>如果要使用token进行认证, 可能需要如下进行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.get(username=<span class="string">'olivia'</span>)</span><br><span class="line">request = factory.get(<span class="string">'/accounts/django-superstars/'</span>)</span><br><span class="line">force_authenticate(request, user=user, token=user.auth_token)</span><br></pre></td></tr></table></figure>

<p>注意, <code>force_authenticate</code>方法会直接使用内存中的<code>user</code>实例来设置<code>request.user</code>, 如果需要对同一个<code>user</code>进行多个可能会影响到user状态的测试, 应该在各个测试间调用<code>refresh_from_db()</code>.</p>
<p>注意, 当使用<code>APIRequestFactory</code>时, 返回的是django标准的<code>HttpRequest</code>, 而非Rest framework的<code>Request</code>对象, 该对象仅会在API视图被调用的时候生成一次.</p>
<p>这意味着, 直接设置请求对象的属性可能不会如预期一样生效, 例如, 直接设置<code>.token</code>属性无效, 直接设置<code>.user</code>仅在使用session认证时生效.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Request will only authenticate if `SessionAuthentication` is in use.</span></span><br><span class="line">request = factory.get(<span class="string">'/accounts/django-superstars/'</span>)</span><br><span class="line">request.user = user</span><br><span class="line">response = view(request)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="强制CSRF验证"><a href="#强制CSRF验证" class="headerlink" title="强制CSRF验证"></a>强制CSRF验证</h3><p>默认情况下, 由<code>APIRequestFactory</code>生成的请求不会带有合法的csrf, 如果要强制使请求的csrf认证合法, 需要在初始化<code>APIRequestFactory</code>时设置<code>enforce_csrf_checks</code>标识.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factory = APIRequestFactory(enforce_csrf_checks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>注意, django的标准<code>RequestFactory</code>不用包含此选项, 因为常规Django的csrf验证发生在中间件中, 该中间件在测试视图时不会运行. 而REST framework的csrf验证发生在视图内部, 所以请求工厂需要将试图级别的csrf验证检查禁用.</p>
<hr>
<h2 id="APIClient"><a href="#APIClient" class="headerlink" title="APIClient"></a>APIClient</h2><p>拓展了Django现存的<a href="https://docs.djangoproject.com/en/2.2/topics/testing/tools/#the-test-client" target="_blank" rel="noopener"><code>Client</code></a>类.</p>
<h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p><code>APIClient</code>类支持与Django标准的<code>Client</code>类相同的接口, 意味着标准的<code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.patch()</code>, <code>.delete()</code>, <code>.head()</code>和<code>.options()</code>方法都可以使用. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APIClient</span><br><span class="line"></span><br><span class="line">client = APIClient()</span><br><span class="line">client.post(<span class="string">'/notes/'</span>, &#123;<span class="string">'title'</span>: <span class="string">'new idea'</span>&#125;, format=<span class="string">'json'</span>)</span><br></pre></td></tr></table></figure>

<p>要支持更多请求格式, 或更改默认格式, 查看本节<code>设置</code>部分.</p>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><hr>
<h4 id="login-kwargs"><a href="#login-kwargs" class="headerlink" title=".login(**kwargs)"></a><code>.login(**kwargs)</code></h4><p>login方法与其在Django<code>Client</code>中的表现相同, 允许对所有支持<code>SessionAuthentication</code>的视图进行请求认证.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Make all requests in the context of a logged in session.</span></span><br><span class="line">client = APIClient()</span><br><span class="line">client.login(username=<span class="string">'lauren'</span>, password=<span class="string">'secret'</span>)</span><br></pre></td></tr></table></figure>

<p>要注销登陆, 调用<code>logout</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Log out</span></span><br><span class="line">client.logout()</span><br></pre></td></tr></table></figure>

<p>login方法对于测试支持会话认证的API非常合适, 例如包含了AJAX交互的网站.</p>
<hr>
<h4 id="credentials-kwargs"><a href="#credentials-kwargs" class="headerlink" title=".credentials(**kwargs)"></a><code>.credentials(**kwargs)</code></h4><p><code>credentials</code>方法可以设置被之后所有测试客户端产生的请求共同使用的请求头.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authtoken.models <span class="keyword">import</span> Token</span><br><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APIClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># Include an appropriate `Authorization:` header on all requests.</span></span><br><span class="line">token = Token.objects.get(user__username=<span class="string">'lauren'</span>)</span><br><span class="line">client = APIClient()</span><br><span class="line">client.credentials(HTTP_AUTHORIZATION=<span class="string">'Token '</span> + token.key)</span><br></pre></td></tr></table></figure>

<p>注意, 再次调用<code>credentials</code>方法会重写任何现有的credentials, 可以通过不带参数地调用该方法来清空现有地credentials.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Stop including any credentials</span></span><br><span class="line">client.credentials()</span><br></pre></td></tr></table></figure>

<p>该方法适合测试那些需要包含认证头的API, 例如基本认证, OAuth1a和OAuth2认证, 以及简单的token认证方案.</p>
<hr>
<p><strong><code>.force_authenticate(user=None, token=None)</code></strong></p>
<p>有时需要绕过认证, 并让所有请求被自动视为已通过认证.</p>
<p>如果在测试时不想构造合法的认证凭证, 使用该快捷方式可能相当有用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.get(username=<span class="string">'lauren'</span>)</span><br><span class="line">client = APIClient()</span><br><span class="line">client.force_authenticate(user=user)</span><br></pre></td></tr></table></figure>

<p>如果要取消认证, 再次调用该方法将user和/或token设为None即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client.force_authenticate(user=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CSRF验证"><a href="#CSRF验证" class="headerlink" title="CSRF验证"></a>CSRF验证</h3><p>默认当使用<code>APIClient</code>时CSRF验证未开启, 如果需要启用CSRF验证, 需要在初始化客户端的时候设置<code>enforce_csrf_checks</code>标识.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = APIClient(enforce_csrf_checks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>与正常情况一样, CSRF仅会对使用会话认证的视图生效, 这意味着CSRF验证仅会发生在使用<code>.login()</code>登陆之后.</p>
<hr>
<h2 id="RequestClient"><a href="#RequestClient" class="headerlink" title="RequestClient"></a>RequestClient</h2><p>REST framework提供了一个使用python库<code>request</code>与应用进行交互的客户端, 在以下情况下可能很有用:</p>
<ol>
<li>期望主要通过另一个python服务与API进行交互, 并想要测试与客户端同级别的结果.</li>
<li>期望实时测试.(参见本节<strong>实时测试</strong>部分)</li>
</ol>
<p>它暴露了与直接使用请求会话完全相同的接口.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> RequestsClient</span><br><span class="line"></span><br><span class="line">client = RequestsClient()</span><br><span class="line">response = client.get(<span class="string">'http://testserver/users/'</span>)</span><br><span class="line"><span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>注意<code>RequestClient</code>需要传递绝对URL.</p>
<hr>
<h3 id="与数据库的交互"><a href="#与数据库的交互" class="headerlink" title="与数据库的交互"></a>与数据库的交互</h3><p>当仅要测试服务接口的<strong>交互</strong>时, <code>ReqeustClient</code>是非常有效的, 比使用标准的Django测试客户端稍加严格, 因此意味着所有的交互都通过API.</p>
<p>如果使用<code>RequestClient</code>时, 需要确保所有的设置和断言是通过常规API调用进行的, 而非直接与数据库模型进行交互, 例如应该直接列出所有Costumer的实例确保其确实包含三条记录而非直接检查<code>Customer.objects.count() == 3</code>.</p>
<h3 id="请求头和认证"><a href="#请求头和认证" class="headerlink" title="请求头和认证"></a>请求头和认证</h3><p>需要与使用标准的<code>request.Session</code>实例时相同的方式自定义请求头和认证凭证.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">client.auth = HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">client.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>如果使用基于会话的身份认证, 需要在任何<code>POST</code>, <code>PUT</code>, <code>PATCH</code>或<code>DELETE</code>请求中包含csrf凭证.</p>
<p>你可以使用基于js的客户端同样的方式, 先发起<code>GET</code>请求获取CSRF凭证, 然后将其包含在请求头中发送:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = RequestsClient()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Obtain a CSRF token.</span></span><br><span class="line">response = client.get(<span class="string">'http://testserver/homepage/'</span>)</span><br><span class="line"><span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">csrftoken = response.cookies[<span class="string">'csrftoken'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interact with the API.</span></span><br><span class="line">response = client.post(<span class="string">'http://testserver/organisations/'</span>, json=&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'MegaCorp'</span>,</span><br><span class="line">    <span class="string">'status'</span>: <span class="string">'active'</span></span><br><span class="line">&#125;, headers=&#123;<span class="string">'X-CSRFToken'</span>: csrftoken&#125;)</span><br><span class="line"><span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="实时测试"><a href="#实时测试" class="headerlink" title="实时测试"></a>实时测试</h3><p><code>RequestClient</code>和<code>CoreAPIClient</code>都可以编写可以在开发或生产环境直接运行的测试用例.</p>
<p>使用这种方式创建对少量核心函数的测试, 对于运行中的服务相当有效. 这样做需要谨慎地开始和终止, 以确保测试不会以影响客户数据的方式进行.</p>
<hr>
<h2 id="CoreAPIClient"><a href="#CoreAPIClient" class="headerlink" title="CoreAPIClient"></a>CoreAPIClient</h2><p><code>CoreClient</code>可以使用python的<code>coreapi</code>客户端库与API进行交互.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fetch the API schema</span></span><br><span class="line">client = CoreAPIClient()</span><br><span class="line">schema = client.get(<span class="string">'http://testserver/schema/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new organisation</span></span><br><span class="line">params = &#123;<span class="string">'name'</span>: <span class="string">'MegaCorp'</span>, <span class="string">'status'</span>: <span class="string">'active'</span>&#125;</span><br><span class="line">client.action(schema, [<span class="string">'organisations'</span>, <span class="string">'create'</span>], params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure that the organisation exists in the listing</span></span><br><span class="line">data = client.action(schema, [<span class="string">'organisations'</span>, <span class="string">'list'</span>])</span><br><span class="line"><span class="keyword">assert</span>(len(data) == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span>(data == [&#123;<span class="string">'name'</span>: <span class="string">'MegaCorp'</span>, <span class="string">'status'</span>: <span class="string">'active'</span>&#125;])</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="请求头-amp-认证"><a href="#请求头-amp-认证" class="headerlink" title="请求头&amp;认证"></a>请求头&amp;认证</h3><p>使用于<code>RequestClient</code>相似的方式来自定义请求头和认证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">client = CoreAPIClient()</span><br><span class="line">client.session.auth = HTTPBasicAuth(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">client.session.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API测试用例"><a href="#API测试用例" class="headerlink" title="API测试用例"></a>API测试用例</h2><p>REST framework包含了以下的测试用例类, 与Django的测试用例类相同, 但使用的是<code>APIClient</code>.而非<code>Client</code>.</p>
<ul>
<li>APISimpleTestCase</li>
<li>APITransactionTestCase</li>
<li>APITestCase</li>
<li>APILiveServerTestCase</li>
</ul>
<p>示例:</p>
<p>可以像使用常规Django测试用例类一样使用任何REST framework测试用例类. <code>self.client</code>会是一个<code>APIClient</code>实例.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountTests</span><span class="params">(APITestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_create_account</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Ensure we can create a new account object.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = reverse(<span class="string">'account-list'</span>)</span><br><span class="line">        data = &#123;<span class="string">'name'</span>: <span class="string">'DabApps'</span>&#125;</span><br><span class="line">        response = self.client.post(url, data, format=<span class="string">'json'</span>)</span><br><span class="line">        self.assertEqual(response.status_code, status.HTTP_201_CREATED)</span><br><span class="line">        self.assertEqual(Account.objects.count(), <span class="number">1</span>)</span><br><span class="line">        self.assertEqual(Account.objects.get().name, <span class="string">'DabApps'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="URLPatternsTestCase"><a href="#URLPatternsTestCase" class="headerlink" title="URLPatternsTestCase"></a>URLPatternsTestCase</h3><p>REST-framework还提供了一个测试用例类用以按类隔离url pattern, 继承自Django的SimpleTestCase, 很可能与其他测试用例类混合使用.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path, reverse</span><br><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APITestCase, URLPatternsTestCase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountTests</span><span class="params">(APITestCase, URLPatternsTestCase)</span>:</span></span><br><span class="line">    urlpatterns = [</span><br><span class="line">        path(<span class="string">'api/'</span>, include(<span class="string">'api.urls'</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_create_account</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Ensure we can create a new account object.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = reverse(<span class="string">'account-list'</span>)</span><br><span class="line">        response = self.client.get(url, format=<span class="string">'json'</span>)</span><br><span class="line">        self.assertEqual(response.status_code, status.HTTP_200_OK)</span><br><span class="line">        self.assertEqual(len(response.data), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="测试响应"><a href="#测试响应" class="headerlink" title="测试响应"></a>测试响应</h2><hr>
<h3 id="检查响应数据"><a href="#检查响应数据" class="headerlink" title="检查响应数据"></a>检查响应数据</h3><p>在检查响应的合法性时通常直接检查其包含数据的合法性, 相较于检查完全渲染后的响应更为方便. </p>
<p>例如, 检查<code>response.data</code>更为方便:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = self.client.get(<span class="string">'/users/4/'</span>)</span><br><span class="line">self.assertEqual(response.data, &#123;<span class="string">'id'</span>: <span class="number">4</span>, <span class="string">'username'</span>: <span class="string">'lauren'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>而非检查<code>response.content</code>的解析结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = self.client.get(<span class="string">'/users/4/'</span>)</span><br><span class="line">self.assertEqual(json.loads(response.content), &#123;<span class="string">'id'</span>: <span class="number">4</span>, <span class="string">'username'</span>: <span class="string">'lauren'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="渲染响应"><a href="#渲染响应" class="headerlink" title="渲染响应"></a>渲染响应</h3><p>如果直接使用<code>APIRequestFactory</code>测试视图, 返回的响应未经渲染, 因为模板响应的呈现是由Django的内部请求-响应周期执行的(TemplateResponse是在中间件中被渲染的), 为了访问response.content, 首先手动进行渲染. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">view = UserDetail.as_view()</span><br><span class="line">request = factory.get(<span class="string">'/users/4'</span>)</span><br><span class="line">response = view(request, pk=<span class="string">'4'</span>)</span><br><span class="line">response.render()  <span class="comment"># Cannot access `response.content` without this.</span></span><br><span class="line">self.assertEqual(response.content, <span class="string">'&#123;"username": "lauren", "id": 4&#125;'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><hr>
<h3 id="设置默认格式"><a href="#设置默认格式" class="headerlink" title="设置默认格式"></a>设置默认格式</h3><p>使用<code>TEST_REQUEST_DEFAULT_FORMAT</code>设置项来设置测试请求的默认格式, 例如, 使用json格式来替换默认的multipartform格式, 如下设置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'TEST_REQUEST_DEFAULT_FORMAT'</span>: <span class="string">'json'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置可用的格式"><a href="#设置可用的格式" class="headerlink" title="设置可用的格式"></a>设置可用的格式</h3><p>如果要使用json或multipart之外的格式, 可以使用<code>TEST_REQUEST_RENDERER_CLASSES</code>设置项进行设置.</p>
<p>例如, 为了支持<code>format=&#39;html&#39;</code>的请求, 需要在设置文件中如下设置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'TEST_REQUEST_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.MultiPartRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.TemplateHTMLRenderer'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 状态码 Status</title>
    <url>/2019/10/03/24.%20%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p>在响应中使用纯粹的状态码并不推荐, rest-framework提供了一系列<strong>命名常量</strong>, 使用这些常量会让代码更加清晰可读.</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_view</span><span class="params">(self)</span>:</span></span><br><span class="line">    content = &#123;<span class="string">'please move along'</span>: <span class="string">'nothing to see here'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> Response(content, status=status.HTTP_404_NOT_FOUND)</span><br></pre></td></tr></table></figure>

<p>包含在<code>status</code>模块中的所有状态码会在下面列出.</p>
<p>该模块同样包含了一个辅助函数用以测试一个状态码是否在某一个区间内.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APITestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleTestCase</span><span class="params">(APITestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_url_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = reverse(<span class="string">'index'</span>)</span><br><span class="line">        response = self.client.get(url)</span><br><span class="line">        self.assertTrue(status.is_success(response.status_code))</span><br></pre></td></tr></table></figure>

<p>HTTP状态码的合适使用方式请参考<a href>RFC 2616</a> 和<a href>RFC 6585</a>.</p>
<hr>
<h3 id="信息提示-1xx"><a href="#信息提示-1xx" class="headerlink" title="信息提示 - 1xx"></a>信息提示 - 1xx</h3><p>这类响应码代表了临时响应. rest-framework默认未使用该类状态码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_100_CONTINUE</span><br><span class="line">HTTP_101_SWITCHING_PROTOCOLS</span><br></pre></td></tr></table></figure>

<h3 id="成功-2xx"><a href="#成功-2xx" class="headerlink" title="成功 - 2xx"></a>成功 - 2xx</h3><p>这类响应码代表着客户端请求被成功收到, 理解并接收.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_200_OK</span><br><span class="line">HTTP_201_CREATED</span><br><span class="line">HTTP_202_ACCEPTED</span><br><span class="line">HTTP_203_NON_AUTHORITATIVE_INFORMATION</span><br><span class="line">HTTP_204_NO_CONTENT</span><br><span class="line">HTTP_205_RESET_CONTENT</span><br><span class="line">HTTP_206_PARTIAL_CONTENT</span><br><span class="line">HTTP_207_MULTI_STATUS</span><br><span class="line">HTTP_208_ALREADY_REPORTED</span><br><span class="line">HTTP_226_IM_USED</span><br></pre></td></tr></table></figure>

<h3 id="重定向-3xx"><a href="#重定向-3xx" class="headerlink" title="重定向 - 3xx"></a>重定向 - 3xx</h3><p>这类响应码代表着用户代理必须采取进一步的行动才能满足请求.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_300_MULTIPLE_CHOICES</span><br><span class="line">HTTP_301_MOVED_PERMANENTLY</span><br><span class="line">HTTP_302_FOUND</span><br><span class="line">HTTP_303_SEE_OTHER</span><br><span class="line">HTTP_304_NOT_MODIFIED</span><br><span class="line">HTTP_305_USE_PROXY</span><br><span class="line">HTTP_306_RESERVED</span><br><span class="line">HTTP_307_TEMPORARY_REDIRECT</span><br><span class="line">HTTP_308_PERMANENT_REDIRECT</span><br></pre></td></tr></table></figure>

<h3 id="客户端错误-4xx"><a href="#客户端错误-4xx" class="headerlink" title="客户端错误 - 4xx"></a>客户端错误 - 4xx</h3><p>这类状态码代表着(可能是)客户端错误. 在使用该类状态码的时候响应<strong>应当</strong>包含一个实体用以说明该错误状况的解释, 以及该错误是暂时的还是永久的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_400_BAD_REQUEST</span><br><span class="line">HTTP_401_UNAUTHORIZED</span><br><span class="line">HTTP_402_PAYMENT_REQUIRED</span><br><span class="line">HTTP_403_FORBIDDEN</span><br><span class="line">HTTP_404_NOT_FOUND</span><br><span class="line">HTTP_405_METHOD_NOT_ALLOWED</span><br><span class="line">HTTP_406_NOT_ACCEPTABLE</span><br><span class="line">HTTP_407_PROXY_AUTHENTICATION_REQUIRED</span><br><span class="line">HTTP_408_REQUEST_TIMEOUT</span><br><span class="line">HTTP_409_CONFLICT</span><br><span class="line">HTTP_410_GONE</span><br><span class="line">HTTP_411_LENGTH_REQUIRED</span><br><span class="line">HTTP_412_PRECONDITION_FAILED</span><br><span class="line">HTTP_413_REQUEST_ENTITY_TOO_LARGE</span><br><span class="line">HTTP_414_REQUEST_URI_TOO_LONG</span><br><span class="line">HTTP_415_UNSUPPORTED_MEDIA_TYPE</span><br><span class="line">HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE</span><br><span class="line">HTTP_417_EXPECTATION_FAILED</span><br><span class="line">HTTP_422_UNPROCESSABLE_ENTITY</span><br><span class="line">HTTP_423_LOCKED</span><br><span class="line">HTTP_424_FAILED_DEPENDENCY</span><br><span class="line">HTTP_426_UPGRADE_REQUIRED</span><br><span class="line">HTTP_428_PRECONDITION_REQUIRED</span><br><span class="line">HTTP_429_TOO_MANY_REQUESTS</span><br><span class="line">HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE</span><br><span class="line">HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS</span><br></pre></td></tr></table></figure>

<h3 id="服务器错误-5xx"><a href="#服务器错误-5xx" class="headerlink" title="服务器错误 - 5xx"></a>服务器错误 - 5xx</h3><p>这类响应码代表着服务端出错或无法执行该请求. 响应应当包含一个实体, 该实体中<strong>应当</strong>有对错误情况的说明, 以及该情况是暂时的或永久的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP_500_INTERNAL_SERVER_ERROR</span><br><span class="line">HTTP_501_NOT_IMPLEMENTED</span><br><span class="line">HTTP_502_BAD_GATEWAY</span><br><span class="line">HTTP_503_SERVICE_UNAVAILABLE</span><br><span class="line">HTTP_504_GATEWAY_TIMEOUT</span><br><span class="line">HTTP_505_HTTP_VERSION_NOT_SUPPORTED</span><br><span class="line">HTTP_506_VARIANT_ALSO_NEGOTIATES</span><br><span class="line">HTTP_507_INSUFFICIENT_STORAGE</span><br><span class="line">HTTP_508_LOOP_DETECTED</span><br><span class="line">HTTP_509_BANDWIDTH_LIMIT_EXCEEDED</span><br><span class="line">HTTP_510_NOT_EXTENDED</span><br><span class="line">HTTP_511_NETWORK_AUTHENTICATION_REQUIRED</span><br></pre></td></tr></table></figure>

<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>以下辅助函数用以判断响应码属于哪一类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">is_informational()  <span class="comment"># 1xx</span></span><br><span class="line">is_success()        <span class="comment"># 2xx</span></span><br><span class="line">is_redirect()       <span class="comment"># 3xx</span></span><br><span class="line">is_client_error()   <span class="comment"># 4xx</span></span><br><span class="line">is_server_error()   <span class="comment"># 5xx</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 异常处理 Exception</title>
    <url>/2019/10/03/23.%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>当视图函数的执行过程中抛出异常, 即转入错误处理阶段. REST framework的视图能够处理各种异常, 并为其返回合适错误响应.</p>
<p>可以被处理的异常包括:</p>
<ol>
<li><code>APIException</code>的子类异常</li>
<li><code>django</code>的<code>Http404</code>异常</li>
<li><code>django</code>的<code>PermissionDenied</code>异常</li>
</ol>
<a id="more"></a>

<p>在各种情况下, rest_framework会返回合适的状态码和<code>content-type</code>头, 响应体部分会包含有关错误特征的更进一步的详细信息.</p>
<p>大多数错误响应在响应体会包含<code>detail</code>项.</p>
<p>例如如下请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE http://api.example.com/foo/bar HTTP/1.1</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>

<p>如果对该资源的<code>DELETE</code>操作被禁止, 收到的错误响应可能如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">405</span> Method Not Allowed</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: <span class="number">42</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"detail"</span>: <span class="string">"Method 'DELETE' not allowed."</span>&#125;</span><br></pre></td></tr></table></figure>

<p>验证器错误的处理可能稍有不同, 在响应中会包含字段名作为关键字. 如果验证错误并不明确指向某个字段, 会使用<code>non_field_errors</code>关键字, 或者在<code>NON_FIELD_ERRORS_KEY</code>设置的值.</p>
<p>验证错误响应可能如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: <span class="number">94</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"amount"</span>: [<span class="string">"A valid integer is required."</span>], </span><br><span class="line">	<span class="string">"description"</span>: [<span class="string">"This field may not be blank."</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h2><p>自定义错误处理函数应该包含两个参数<code>exc</code>和<code>context</code>, <code>exc</code>为API视图抛出的异常, 而<code>context</code>则是包含了任何额外上下文的字典, 例如当前正在被调用的视图等.</p>
<p>异常处理函数应该返回<code>Response</code>对象或者在无法处理该异常时返回<code>None</code>, 如果异常处理函数返回了<code>None</code>, 客户端最终接收到的就是一个<code>HTTP 500 server error</code>响应.</p>
<p>例如, 要在错误响应的body部分始终包含http状态码, 如下所示:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 405 Method Not Allowed</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">&#123;"status_code": 405, "detail": "Method 'DELETE' not allowed."&#125;</span><br></pre></td></tr></table></figure>

<p>则为了更改响应的风格, 可以这样自定义异常处理函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="comment"># Call REST framework's default exception handler first, </span></span><br><span class="line">    <span class="comment"># to get the standard error response.</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now add the HTTP status code to the response.</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response.data[<span class="string">'status_code'</span>] = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p><code>context</code>参数不会被默认的异常处理函数所使用, 不过如果想要获得额外信息例如当前使用的视图函数, 则可以用<code>context[&#39;view&#39;]</code>使用</p>
<p>异常处理函数必须被<code>EXCEPTION_HANDLER</code>设置项指定, 然后才会被应用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'my_project.my_app.utils.custom_exception_handler'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不指定, 则默认使用rest_framework的默认异常处理器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'rest_framework.views.exception_handler'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意该异常处理函数仅会在抛出异常时调用, 它不会用于视图直接返回的任何响应.</p>
<p>例如, 当序列化程序验证失败时, 通用视图返回的HTTP_400_BAD_REQUEST响应, 不会引起异常处理函数的调用.</p>
<hr>
<h2 id="api-参考"><a href="#api-参考" class="headerlink" title="api 参考"></a>api 参考</h2><h3 id="APIException-异常类"><a href="#APIException-异常类" class="headerlink" title="APIException 异常类"></a>APIException 异常类</h3><p>签名<code>APIException()</code></p>
<p>所有在APIView类或者使用了<code>@api_view</code>装饰器函数中抛出的异常的基类.</p>
<p>要提供一个自定义异常, 将<code>APIException</code>子类化并设置 <code>status_code</code>, <code>default_detail</code> 和 <code>default_code</code> 属性</p>
<p>例如, 如果你的API依赖于某个不稳定的第三方服务, 可能需要为<code>503 Service Unavailable</code>响应码实现一个异常类, 如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> APIException</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceUnavailable</span><span class="params">(APIException)</span>:</span></span><br><span class="line">    status_code = <span class="number">503</span></span><br><span class="line">    default_detail = <span class="string">'Service temporarily unavailable, try again later.'</span></span><br><span class="line">    default_code = <span class="string">'service_unavailable'</span></span><br></pre></td></tr></table></figure>

<p>可重写的方法/属性</p>
<ol>
<li><code>.detail</code> 该错误的文字描述</li>
<li><code>.get_codes()</code> 返回该异常的错误代码标识符</li>
<li><code>.get_full_details()</code> 返回文字描述和代码标识符</li>
</ol>
<p>在大多数情况下, 错误的detail项会是一个简单元素.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.detail)</span><br><span class="line">You do <span class="keyword">not</span> have permission to perform this action.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_codes())</span><br><span class="line">permission_denied</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_full_details())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">'message'</span>:<span class="string">'You do not have permission to perform this action.'</span>, </span><br><span class="line">	<span class="string">'code'</span>:<span class="string">'permission_denied'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在验证器错误时, detail会是由字段名和错误提示组成的字典或列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.detail)</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"This field is required."</span>, <span class="string">"age"</span>:<span class="string">"A valid integer is required."</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_codes())</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"required"</span>, <span class="string">"age"</span>:<span class="string">"invalid"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(exc.get_full_details())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"name"</span>:&#123;<span class="string">"message"</span>:<span class="string">"This field is required."</span>, <span class="string">"code"</span>:<span class="string">"required"</span>&#125;, </span><br><span class="line">	<span class="string">"age"</span>:&#123;</span><br><span class="line">		<span class="string">"message"</span>:<span class="string">"A valid integer is required."</span>, </span><br><span class="line">		<span class="string">"code"</span>:<span class="string">"invalid"</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ParseError-解析器错误"><a href="#ParseError-解析器错误" class="headerlink" title="ParseError(解析器错误)"></a>ParseError(解析器错误)</h3><p>签名:<code>ParseError(detail=None, code=None)</code></p>
<p>当访问<code>request.data</code>属性出错时抛出该异常, 默认的处理结果为一个 <code>400 Bad Request</code>响应</p>
<hr>
<h3 id="AuthenticationFailed-身份认证失败"><a href="#AuthenticationFailed-身份认证失败" class="headerlink" title="AuthenticationFailed(身份认证失败)"></a>AuthenticationFailed(身份认证失败)</h3><p>签名：<code>AuthenticationFailed(detail=None, code=None</code></p>
<p>接收到认证身份失败的请求时抛出的错误, 默认为<code>401 Unauthenticated</code>或者<code>403 Forbidden</code>响应, 具体请参看身份验证一节.</p>
<hr>
<h3 id="NotAuthenticated-未认证"><a href="#NotAuthenticated-未认证" class="headerlink" title="NotAuthenticated(未认证)"></a>NotAuthenticated(未认证)</h3><p>签名: <code>NotAuthenticated(detail=None, code=None)</code></p>
<p>接收到认证身份失败的请求时抛出的错误, 默认为<code>401 Unauthenticated</code>或者<code>403 Forbidden</code>响应, 具体请参看身份验证一节.</p>
<hr>
<h3 id="PermissionDenied-权限禁止"><a href="#PermissionDenied-权限禁止" class="headerlink" title="PermissionDenied(权限禁止)"></a>PermissionDenied(权限禁止)</h3><p>签名:<code>PermissionDenied(detail=None, code=None)</code></p>
<p>默认返回结果为<code>403 Forbidden</code></p>
<hr>
<h3 id="NotFound-未找到"><a href="#NotFound-未找到" class="headerlink" title="NotFound(未找到)"></a>NotFound(未找到)</h3><p>签名:<code>NotFound(detail=None, code=None)</code></p>
<p>默认响应状态码为<code>404 Not Found</code>.</p>
<hr>
<h3 id="MethodNotAllowed-不被允许的方法"><a href="#MethodNotAllowed-不被允许的方法" class="headerlink" title="MethodNotAllowed(不被允许的方法)"></a>MethodNotAllowed(不被允许的方法)</h3><p>签名:<code>MethodNotAllowed(method, detail=None, code=None)</code></p>
<p>默认响应状态码为<code>405 Method Not Allowed</code></p>
<hr>
<h3 id="NotAcceptable-客户端无法接收响应"><a href="#NotAcceptable-客户端无法接收响应" class="headerlink" title="NotAcceptable(客户端无法接收响应)"></a>NotAcceptable(客户端无法接收响应)</h3><p>签名:<code>UnsupportedMediaType(media_type, detail=None, code=None)</code></p>
<p>当渲染器列表中的任何渲染器都无法满足客户端请求的Accept头时抛出. </p>
<p>默认响应状态码为<code>406 Not Acceptable</code></p>
<hr>
<h3 id="UnsupportedMediaType-不支持的媒体类型"><a href="#UnsupportedMediaType-不支持的媒体类型" class="headerlink" title="UnsupportedMediaType(不支持的媒体类型)"></a>UnsupportedMediaType(不支持的媒体类型)</h3><p>签名:<code>UnsupportedMediaType(media_type, detail=None, code=None)</code></p>
<p>当访问<code>request.data</code>时, 没有任何可用的解析器可以处理请求中所携带的数据, 则抛出该异常.</p>
<p>默认响应状态码为<code>415 Unsupported Media Type</code></p>
<hr>
<h3 id="Throttled-被限流"><a href="#Throttled-被限流" class="headerlink" title="Throttled(被限流)"></a>Throttled(被限流)</h3><p>签名:<code>Throttled(wait=None, detail=None, code=None)</code></p>
<p>该请求未通过限流检测时抛出该异常</p>
<p>默认响应状态码为<code>429 Too Many Requests</code></p>
<hr>
<h3 id="ValidationError-验证错误"><a href="#ValidationError-验证错误" class="headerlink" title="ValidationError(验证错误)"></a>ValidationError(验证错误)</h3><p>签名:<code>ValidationError(detail, code=None)</code></p>
<p>与<code>APIException</code>的不同之处</p>
<ol>
<li><code>detail</code>参数不是可选的, 而是强制的</li>
<li><code>detail</code>参数可能是一个列表或者错误信息的字典, 或者是一个嵌套的数据结构</li>
<li>按照惯例, 你应当使用完全限定的<code>ValidationError</code>以区别Djano内置的验证错误</li>
</ol>
<p>例如<code>raise serializers.ValidationError(&#39;This field must be an integer value.&#39;)</code></p>
<p><code>ValidationError</code>应当用被验证器使用在序列化器和字段验证上. 或者当调用<code>raise_execption</code>参数为<code>True</code>的<code>serializer.is_valid()</code>方法时抛出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>通用视图使用了<code>raise_execption</code>=<code>True</code>, 所以你可以在全局重写API的验证错误响应的风格, 使用上面所述的自定义异常处理器和描述. </p>
<p>该异常的默认处理结果是 “400 Bad Request”</p>
<hr>
<h2 id="通用错误视图"><a href="#通用错误视图" class="headerlink" title="通用错误视图"></a>通用错误视图</h2><p>鉴于Django的默认错误视图提供HTML响应, 这可能不适用于纯API应用, 因此DRF提供了两个错误视图, 提供通用的JSON形式的5xx和4xx响应.</p>
<p><code>rest_framework.exceptions.server_error</code></p>
<p>返回状态码为<code>500</code>和内容类型为<code>application/json</code>的响应</p>
<p>设置为<code>handler500</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler500 = <span class="string">'rest_framework.exceptions.server_error'</span></span><br></pre></td></tr></table></figure>

<p><code>rest_framework.exceptions.bad_request</code></p>
<p>返回状态码为<code>400</code>和内容类型为<code>application/json</code>的响应.</p>
<p>设置为<code>handler400</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler400 = <span class="string">'rest_framework.exceptions.bad_request'</span></span><br></pre></td></tr></table></figure>

<p>查看Django的<a href="https://docs.djangoproject.com/en/stable/topics/http/views/#customizing-error-views" target="_blank" rel="noopener">自定义错误视图</a>部分.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>22. 返回URL Return URL</title>
    <url>/2019/10/03/22.%20%E8%BF%94%E5%9B%9EURL/</url>
    <content><![CDATA[<blockquote>
<p>REST架构跟与其他架构的核心区别就是强调接口之间的统一性    — Roy Fielding</p>
</blockquote>
<p>通常, 返回url的时候最好是返回绝对url, 而不是返回相对url.</p>
<p>这样做的优势在于：</p>
<ol>
<li>更明确</li>
<li>减轻客户端的负担</li>
<li>当在诸如JSON之类的结果中找不到原始URL时, 也不会产生歧义</li>
<li>很容易地使用带有超链接的html样式</li>
</ol>
<a id="more"></a>

<p>rest_framework提供两个工具函数来更简单地使API返回绝对url, 如果有需要, 使用它们能使自描述API能够自动生成超链接, 使浏览api变得更加容易.</p>
<p>这两个函数是 <code>reverse</code>和 <code>reverse_lazy</code></p>
<hr>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><code>reverse</code></h3><p>签名: <code>reverse(viewname, *args, **kwargs)</code></p>
<p>与django.urls.reverse的行为相同, 唯一的不同是返回的是<strong>绝对URL</strong>.</p>
<p>在这个过程中需要使用<code>request</code>来确定主机和端口, 因此在使用reverse()函数的时候, 需要为其传入request关键字参数.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.reverse <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> django.utils.timezone <span class="keyword">import</span> now</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIRootView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        year = now().year</span><br><span class="line">        data = &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">'year-summary-url'</span>: reverse(<span class="string">'year-summary'</span>, args=[year], request=request)</span><br><span class="line">            <span class="comment">#此处需要传入request</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="reverse-lazy"><a href="#reverse-lazy" class="headerlink" title="reverse_lazy"></a><code>reverse_lazy</code></h3><p>签名: <code>reverse_lazy(viewname, *args, **kwargs)</code></p>
<p>与<code>django.urls.reverse_lazy</code>相同, 唯一区别是返回<strong>绝对URL</strong>, 使用<code>request</code>来确定主机和端口.</p>
<p>与reverse一样, 在使用时为其包含request关键字参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">api_root = reverse_lazy(<span class="string">'api-root'</span>, request=request)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 格式后缀 Format suffixes</title>
    <url>/2019/10/03/21.%20%E6%A0%BC%E5%BC%8F%E5%90%8E%E7%BC%80/</url>
    <content><![CDATA[<p>Web API的常见方式是在URL上使用文件拓展名用以指定所期望获得响应的媒体类型, 例如<code>http://example.com/api/users.json</code>用于请求<code>JSON</code>格式的数据.</p>
<p>如果要在API的URLconf中为每个单独的条目添加格式后缀容易出错且违背DRY原则, 因此REST框架提供了将这些模式添加到URLConf的快捷方式.</p>
<a id="more"></a>

<hr>
<h2 id="format-suffix-patterns"><a href="#format-suffix-patterns" class="headerlink" title="format_suffix_patterns"></a><code>format_suffix_patterns</code></h2><p>签名: <code>format_suffix_patterns(urlpatterns, suffix_required=False, allowed=None)</code></p>
<p>该函数接收一个urlpatterns参数, 并为其中每个urlpattern都提供了后缀的新的urlpatterns作为返回结果</p>
<p><code>urlpatterns</code>: 必要参数, 一个URL pattern 列表<br><code>suffix_required</code>: 可选参数, 布尔型, 用来指定请求url是否<strong>必须</strong>包含后缀. 默认为<code>False</code><br><code>allowed</code>：可选参数, 合法的后缀列表或元组, 如果不提供, 则会使用通配符格式后缀</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.urlpatterns <span class="keyword">import</span> format_suffix_patterns</span><br><span class="line"><span class="keyword">from</span> blog <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^/$'</span>, views.apt_root), </span><br><span class="line">    url(<span class="string">r'^comments/$'</span>, views.comment_list), </span><br><span class="line">    url(<span class="string">r'^comments/(?P&lt;pk&gt;[0-9]+)/$'</span>, views.comment_detail)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = format_suffix_patterns(urlpatterns, allowed=[<span class="string">'json'</span>, <span class="string">'html'</span>])</span><br></pre></td></tr></table></figure>

<p>当使用<code>format_suffix_patterns</code>的时候, 必须确保在对应的视图中的请求处理函数中接收<code>format</code>关键字参数(通用视图中的处理方法默认已包含<code>format</code>参数).</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(('GET', 'POST'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment_list</span><span class="params">(request, format=None)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>这个参数名(<code>&#39;farmat&#39;</code>)可以使用<code>FORMAT_SUFFIX_KWARG</code>设置项来改变</p>
<p>同时需要注意, <code>format_suffix_patterns</code> 不支持在其patterns中使用<code>include</code>来包含下级<code>urlpattern</code>, 所以该函数的使用位置为底层的urlconf</p>
<hr>
<h3 id="同时使用-i18n-patterns"><a href="#同时使用-i18n-patterns" class="headerlink" title="同时使用 i18n_patterns"></a>同时使用 <code>i18n_patterns</code></h3><p>如果使用django提供的<code>i18n_patterns</code>函数, 确保其在最外层调用, 即返回的urlpattern需要为最终的urlpattern</p>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    …</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = i18n_patterns(</span><br><span class="line">    format_suffix_patterns(urlpatterns, allowed=[<span class="string">'json'</span>, <span class="string">'html'</span>])</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通过查询参数来指定格式"><a href="#通过查询参数来指定格式" class="headerlink" title="通过查询参数来指定格式"></a>通过查询参数来指定格式</h2><p>另一个指定格式的方法是使用查询参数来指定格式, rest_framework默认提供这个特性.</p>
<p>使用的查询参数名默认为<code>format</code>, 例如: <code>http://example.com/organizations/?format=csv</code>.</p>
<p>查询参数的名字(<code>format</code>), 可以通过 <code>URL_FORMAT_OVERRIDE</code> 进行设置, 设置为<code>None</code>则禁止使用查询参数的方式来指定格式.</p>
<hr>
<h2 id="Accept头和格式后缀的比较"><a href="#Accept头和格式后缀的比较" class="headerlink" title="Accept头和格式后缀的比较"></a>Accept头和格式后缀的比较</h2><p>在某些Web社区中似乎有一种观点认为文件扩展名不是RESTful模式, 而且应始终使用HTTP Accept标头. </p>
<p>这实际上是一种误解. 例如, 请参阅Roy Fielding的以下引用, 讨论查询参数媒体类型指标与文件扩展媒体类型指标的相对优点：</p>
<blockquote>
<p>“这就是为什麽我总是喜欢扩展名, 这两种选择都与REST无关. “ -  Roy Fielding, REST讨论邮件列表</p>
</blockquote>
<p>引用中没有提到<code>Accept</code>标头, 但它确实清楚地表明格式后缀应该被认为是可接受的模式. </p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>20. API概览 Schemas</title>
    <url>/2019/10/03/20.%20API%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>能被机器所理解的概要, 描述了通过api可得到的资源, URL, 表示方式以及支持的操作.</p>
<p>API概要在很多使用场景下都是有用的工具, 例如生成参考文档, 或者驱动可以与API交互的动态客户端库.</p>
<p>rest-framework支持自动生成<a href="https://github.com/OAI/OpenAPI-Specification" target="_blank" rel="noopener">OPENAPI</a>文档.</p>
<a id="more"></a>

<hr>
<h2 id="生成API概览"><a href="#生成API概览" class="headerlink" title="生成API概览"></a>生成API概览</h2><h4 id="安装CoreAPI和PyYAML"><a href="#安装CoreAPI和PyYAML" class="headerlink" title="安装CoreAPI和PyYAML"></a>安装CoreAPI和PyYAML</h4><p>安装<code>coreapi</code>包来为REST框架提供概要支持, 同时还可能需要<code>pyyaml</code>包以将概要渲染为通用的YAML格式的开放API格式.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install coreapi pyyaml</span><br></pre></td></tr></table></figure>

<p>两种方法来生成API描述文档:</p>
<ol>
<li>使用<code>generateschema</code>管理命令生成静态的概要文件</li>
<li>使用SchemaView视图来生成动态的概要响应.</li>
</ol>
<hr>
<h3 id="使用generateschema管理命令生成静态的概要文件"><a href="#使用generateschema管理命令生成静态的概要文件" class="headerlink" title="使用generateschema管理命令生成静态的概要文件"></a>使用<code>generateschema</code>管理命令生成静态的概要文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py generateschema &gt; shcema.yml</span><br></pre></td></tr></table></figure>

<p>之后会生成一个包含api概要的YAML语法的文件<code>schema.yml</code>, 之后你可以在其中添加额外信息以补充概要生成器所未能包含的其他信息.</p>
<p>这种方法需要手动登记版本控制信息, 并在每个新版本发布时更新该文档, 或者将其作为静态媒体文件由服务器返回.</p>
<hr>
<h3 id="添加动态生成概要的视图函数"><a href="#添加动态生成概要的视图函数" class="headerlink" title="添加动态生成概要的视图函数"></a>添加动态生成概要的视图函数</h3><p>在某些情况下需要的是一个动态的api概要, 因为外键的可选项可能随着数据库中的值而变动. 使用<code>SchemaView</code>并将其注册至路由中, 这样就可以按需生成概要.</p>
<p>将SchemaView添加至路由, 需要使用<code>get_schema_view()</code>辅助函数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#project/urls.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.schemas <span class="keyword">import</span> get_schema_view</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">'openapi'</span>, get_schema_view(</span><br><span class="line">        title=<span class="string">"Your Project"</span>, </span><br><span class="line">        description=<span class="string">"API for all things …"</span>, </span><br><span class="line">        version=<span class="string">"1.0.0"</span></span><br><span class="line">    ), name=<span class="string">'openapi-schema'</span>), </span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ol>
<li><code>title</code> 用以提供的概要标题</li>
<li><code>description</code> 较长的描述性文本</li>
<li><code>version</code> 标注的api版本, 默认为<code>0.1.0</code></li>
<li><code>url</code> 可用于标注baseURL</li>
<li><code>urlconf</code> 该概要所想要包含的urlconf的所在路径, 默认为django的<code>ROOT_URLCONF</code>设置项</li>
<li><code>gengerator_class</code> 可能用以指定一个要被<code>SchemaView</code>所使用的<code>SchemaGenerator</code>的子类</li>
<li><code>authentication_classes</code> 指定用以进行身份认证的类列表, 默认为django的<code>DEFAULT_AUTHENTICATION_CLASSES</code>设置项</li>
<li><code>permission_classes</code> 指定用以进行权限验证的类列表, 默认为django的<code>DEFAULT_PERMISSION_CLASSES</code>设置项</li>
<li><code>renderer_classes</code> 用以指定生成最终结果的渲染器类</li>
</ol>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">schema_view = get_schema_view(</span><br><span class="line">    title=<span class="string">'Server Monitoring API'</span>, </span><br><span class="line">    url=<span class="string">'https://www.example.org/api/'</span>, </span><br><span class="line">    urlconf=<span class="string">'myproject.urls'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义概要生成"><a href="#自定义概要生成" class="headerlink" title="自定义概要生成"></a>自定义概要生成</h2><p>自定义全部API概要, 或指定视图级的自定义概要.</p>
<h3 id="概要级别的自定义"><a href="#概要级别的自定义" class="headerlink" title="概要级别的自定义"></a>概要级别的自定义</h3><p>如果要自定义最高级的概要, 需要子类化<code>rest_framework.schemas.openapi.SchemaGenerator</code>, 并将其作为参数提供给<code>generateschema</code>命令或者<code>get_schema_view</code>辅助函数.</p>
<p><strong>SchemaGenerator</strong>是一个用来遍历一个urlpattern列表, 并为其中每一个视图生成相关概要的类.</p>
<p>通常需要提供一个<code>title</code>参数将其实例化:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generator = SchemaGenerator(title=<span class="string">'Stock Prices API'</span>)</span><br></pre></td></tr></table></figure>

<p>可用的参数包括</p>
<ol>
<li>title </li>
<li>description</li>
<li>version</li>
<li>url</li>
<li>patterns</li>
<li>urlconf</li>
</ol>
<p>各参数的含义与在<code>get_schema_view()</code>函数中相同, 不再赘述. 其中只有<code>title</code>是必要参数.</p>
<p>需要重写的方法为<code>get_schema(self, request)</code> </p>
<p>该方法返回一个字典, 所包含的数据用于表示API概要.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generator = SchemaGenerator(title=<span class="string">'Stock Prices API'</span>)</span><br><span class="line">schema = generator.get_schema()</span><br></pre></td></tr></table></figure>

<p>request参数是可选的, 如果要对生成的模式生成应用每个用户权限, 则可以使用request参数. </p>
<p>如果要自定义生成的字典(例如添加自定义规范扩展名), 则可以覆盖该方法. </p>
<hr>
<h3 id="视图级别的自定义"><a href="#视图级别的自定义" class="headerlink" title="视图级别的自定义"></a>视图级别的自定义</h3><p>默认情况下, 视图自省可通过APIView上的schema属性访问的AutoSchema实例执行. 这为视图, 请求方法和路径提供了适当的Open API操作对象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">auto_schema = view.schema</span><br><span class="line">operation = auto_schema.get_operation(...)</span><br></pre></td></tr></table></figure>

<p>在编译概要时, SchemaGenerator为每个视图, 允许的方法和路径调用<code>view.schema.get_operation()</code>.</p>
<p>注意：对于基本的APIView子类, 默认自省本质上仅限于URL关键字路径参数, 对于GenericAPIView子类, 其中包括所有提供的基于类的视图, AutoSchema将尝试内省序列化程序, 分页和过滤器字段, 并提供更丰富的路径字段描述(这里的关键钩子是相关的GenericAPIView属性和方法: get_serializer, pagination_class, filter_backends等).</p>
<hr>
<p>为了自定义操作生成, 应该提供一个<code>AutoSchema</code>的子类, 并按需重写<code>get_operation()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.schemas.openapi <span class="keyword">import</span> AutoSchema</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSchema</span><span class="params">(AutoSchema)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_link</span><span class="params">(...)</span>:</span></span><br><span class="line">        <span class="comment"># Implement custom introspection here (or in other sub-methods)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""APIView subclass with custom schema introspection."""</span></span><br><span class="line">    schema = CustomSchema()</span><br></pre></td></tr></table></figure>

<p>这为视图的自省提供了完全控制.</p>
<p>如果想要某个视图不被包含在api概要中, 将其schema属性设为None即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    schema = <span class="literal">None</span>  <span class="comment"># 不会在概要中出现该视图.</span></span><br></pre></td></tr></table></figure>

<p>或是不想让某个ViewSet中自定义路由包含在API概要中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=True, schema=None)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extra_action</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>如果要指定某个<code>AutoSchema</code>的子类应用于全局, 通过<code>DEFAULT_SCHEMA_CLASS</code>设置项进行设置.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 元数据 Metadata</title>
    <url>/2019/10/03/19.%20%E5%85%83%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>OPTIONS方法允许客户端在不要求资源动作或启动资源检索的前提下, 确定资源相关的选项, 需求或服务端的能力, </p>
</blockquote>
<p>REST framework包含一个可配置的机制, 用于确定API应如何响应<code>OPTIONS</code>请求, 返回API构架或其他资源信息。</p>
<p>目前还没有任何广泛采用的约定, 以确切地为<code>HTTP OPTIONS</code>请求返回什么样的响应, 因此我们提供了一种返回一些有用信息的ad-hoc样式。</p>
<a id="more"></a>

<p>这是一个示例响应, 演示默认返回的信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">Allow: GET, POST, HEAD, OPTIONS</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"To Do List"</span>, </span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"List existing 'To Do' items, or create a new item."</span>, </span><br><span class="line">    <span class="string">"renders"</span>: [</span><br><span class="line">        <span class="string">"application/json"</span>, </span><br><span class="line">        <span class="string">"text/html"</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">"parses"</span>: [</span><br><span class="line">        <span class="string">"application/json"</span>, </span><br><span class="line">        <span class="string">"application/x-www-form-urlencoded"</span>, </span><br><span class="line">        <span class="string">"multipart/form-data"</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">"actions"</span>: &#123;</span><br><span class="line">        <span class="string">"POST"</span>: &#123;</span><br><span class="line">            <span class="string">"note"</span>: &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"string"</span>, </span><br><span class="line">                <span class="string">"required"</span>: <span class="literal">false</span>, </span><br><span class="line">                <span class="string">"read_only"</span>: <span class="literal">false</span>, </span><br><span class="line">                <span class="string">"label"</span>: <span class="string">"title"</span>, </span><br><span class="line">                <span class="string">"max_length"</span>: <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置元数据方案"><a href="#设置元数据方案" class="headerlink" title="设置元数据方案"></a>设置元数据方案</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>使用<code>DEFAULT_METADATA_CLASS</code>设置项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_METADATA_CLASS'</span>: <span class="string">'rest_framework.metadata.SimpleMetadata'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图级设置, 使用metadata_class即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIRoot</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    metadata_class = SimpleMetadata</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>drf仅仅提供了一个<code>SimpleMetadata</code>类, 如果想用其他风格都必须自定义元数据类。</p>
<p>###创建概要端点</p>
<p>如果想要创建一个可以使用<code>GET</code>请求方法访问的元数据入口, 你可以通过复用元数据API来实现</p>
<p>例如, 如下额外的路由可以提供一个可链接的概要端点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@action(methods=['GET'], detail=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schema</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    meta = self.metadata_class()</span><br><span class="line">    data = meta.determine_metadata(request, self)</span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<p>使用理由:<code>OPTION</code>响应不可缓存, 而<code>GET</code>可以</p>
<hr>
<p>##自定义元数据类</p>
<p>重写<code>BaseMetadata</code>, 并实现<code>determine_metadata(self, request, view)</code>方法</p>
<p>例如想返回JSON格式的概要信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimalMetadata</span><span class="params">(BaseMetadata)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Don't include field and other information for `OPTIONS` requests.</span></span><br><span class="line"><span class="string">    Just return the name and description.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_metadata</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'name'</span>: view.get_view_name(), </span><br><span class="line">            <span class="string">'description'</span>: view.get_view_description()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_METADATA_CLASS'</span>: <span class="string">'myproject.apps.core.MinimalMetadata'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 内容协商 Content negotiation</title>
    <url>/2019/10/03/18.%20%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86/</url>
    <content><![CDATA[<p>内容协商的结果会在选择解析器和渲染器阶段使用.</p>
<p>REST使用简单的内容协商方式来确定应该返回给客户端什么媒体类型的响应, 并根据可用的渲染器, 各个渲染器的优先级以及客户端的<code>Accpet</code>标头来选择渲染器, 部分由客户端驱动, 部分由服务端驱动. </p>
<p>在进行内容协商时:</p>
<a id="more"></a>

<ol>
<li>更具体的媒体类型优先</li>
<li>可用渲染器列表的顺序优先</li>
</ol>
<p>例如接收到的<code>Accept</code>头如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">application/json; indent=4, application/json, application/yaml, text/html, */*</span><br></pre></td></tr></table></figure>

<p>其优先顺序为</p>
<ol>
<li>application/json; indent=4</li>
<li>application/json, application/yaml and text/html</li>
<li><em>/</em></li>
</ol>
<p>如果视图里定义的渲染器仅有YAML和HTML格式, REST会选择列表中第一个渲染器进行渲染</p>
<p>注意：q值指定优先级的方式, 不会被rest_framework所采用. </p>
<hr>
<h3 id="自定义内容协商"><a href="#自定义内容协商" class="headerlink" title="自定义内容协商"></a>自定义内容协商</h3><p>通常不太可能需要自定义内容协商方案, 不过如果有需要, 可以通过重写<code>BaseContentNegotiation</code>来实现</p>
<p>内容协商同时处理解析器和渲染器的选择, 所以需要同时实现<code>.select_parser(request, parsers)</code>和<code>.select_renderer(request, renderers, format_suffix)</code>方法</p>
<ol>
<li><code>select_parser()</code>方法返回一个在可用解析器列表中的解析器, 如果找不到合适的解析器则返回None. </li>
<li><code>select_renderer()</code>方法返回一个二元组<code>(renderer instance, media type)</code>, 或者抛出一个<code>NotAcceptable</code>异常.</li>
</ol>
<p>示例: 以下自定义内容协商类, 会在内容协商阶段忽略客户端的请求, 而直接选择最靠前的解析器和渲染器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.negotiation <span class="keyword">import</span> BaseContentNegotiation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IgnoreClientContentNegotiation</span><span class="params">(BaseContentNegotiation)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_parser</span><span class="params">(self, request, parsers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Select the first parser in the `.parser_classes` list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> parsers[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select_renderer</span><span class="params">(self, request, renderers, format_suffix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Select the first renderer in the `.renderer_classes` list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (renderers[<span class="number">0</span>], renderers[<span class="number">0</span>].media_type)</span><br></pre></td></tr></table></figure>

<p>将其设置为全局默认的内容协商类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_CONTENT_NEGOTIATION_CLASS'</span>: <span class="string">'myapp.negotiation.IgnoreClientContentNegotiation'</span>, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者指定为某视图使用的内容协商类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myapp.negotiation <span class="keyword">import</span> IgnoreClientContentNegotiation</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoNegotiationView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    An example view that does not perform content negotiation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    content_negotiation_class = IgnoreClientContentNegotiation</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'accepted media type'</span>: request.accepted_renderer.media_type</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>17. 版本控制 Versioning</title>
    <url>/2019/10/03/17.%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>API版本控制允许为不同客户端执行不同的行为. REST-framework提供了多种版本控制方案:</p>
<ol>
<li>基于url查询参数的版本控制<code>QueryParameterVersioning</code></li>
<li>基于url中路径段匹配的版本控制<code>URLPathVersioning</code></li>
<li>基于ACCEPT请求头的版本控制<code>AcceptHeaderVersioning</code></li>
<li>基于命名空间的版本控制<code>NamespaceVersioning</code></li>
<li>基于主机名的版本控制<code>HostNameVersioning</code></li>
<li>自定义的版本控制</li>
</ol>
<a id="more"></a>

<p><em>导出路径均为<code>rest_framework.versioning</code></em></p>
<p>任何方案最终都会将请求的版本号保存在<code>request.version</code>中, 当未启用任何版本控制方案时, <code>request.version</code>总是返回<code>None</code>. 可以通过检查<code>request.version</code>为客户端提供不同的数据.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.version == <span class="string">'v1'</span>:</span><br><span class="line">        <span class="keyword">return</span> AccountSerializerVersion1</span><br><span class="line">    <span class="keyword">return</span> AccountSerializer</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="配置版本控制方案"><a href="#配置版本控制方案" class="headerlink" title="配置版本控制方案"></a>配置版本控制方案</h3><p>全局级别:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_VERSIONING_CLASS'</span>: <span class="string">'rest_framework.versioning.NamespaceVersioning'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他可选配置项</p>
<ul>
<li>DEFAULT_VERSION: 默认版本，默认值为None</li>
<li>ALLOWED_VERSIONS：允许的版本，默认为None，不做限制</li>
<li>VERSION_PARAM：用来控制版本控制系统的字符串，默认为’version’</li>
</ul>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="QueryParameterVersioning-基于url查询参数的版本控制"><a href="#QueryParameterVersioning-基于url查询参数的版本控制" class="headerlink" title="QueryParameterVersioning(基于url查询参数的版本控制)"></a>QueryParameterVersioning(基于url查询参数的版本控制)</h3><p>启用基于查询参数的版本控制方案时, 直接在请求中包含<code>version</code>查询参数即可, 请求格式:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/something/?version=0.1</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="URLPathVersioning-基于url中路径段匹配的版本控制"><a href="#URLPathVersioning-基于url中路径段匹配的版本控制" class="headerlink" title="URLPathVersioning(基于url中路径段匹配的版本控制)"></a>URLPathVersioning(基于url中路径段匹配的版本控制)</h3><p>启用基于url路径的版本控制方案后, 需要配置url conf中添加变量(或命名正则表达式).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">'something/(&lt;?P=version&gt;(V1|V2))/bookings/$'</span>, bookings_list), </span><br><span class="line">    re_path(<span class="string">'something/(&lt;?P=version&gt;(V1|V2))/bookings/(?P&lt;pk&gt;[0-9]+)/$'</span>, bookings_detail)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>请求格式</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/v1/bookings/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="HostNameVersioning-基于主机名的版本控制"><a href="#HostNameVersioning-基于主机名的版本控制" class="headerlink" title="HostNameVersioning(基于主机名的版本控制)"></a>HostNameVersioning(基于主机名的版本控制)</h3><p>尝试从hostname中取出version, hostname应当与<code>^([a-zA-Z0-9]+)\.[a-zA-Z0-9]+\.[a-zA-Z0-9]+$</code>相匹配.</p>
<p>请求格式</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bookings/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: v1.example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AcceptHeaderVersioning-基于ACCEPT请求头的版本控制"><a href="#AcceptHeaderVersioning-基于ACCEPT请求头的版本控制" class="headerlink" title="AcceptHeaderVersioning(基于ACCEPT请求头的版本控制)"></a>AcceptHeaderVersioning(基于ACCEPT请求头的版本控制)</h3><p>通过<code>ACCEPT</code>头的version参数获取版本</p>
<p>请求格式:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bookings/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: example.com</span><br><span class="line"><span class="attribute">Accept</span>: application/json; version=1.0</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="NamespaceVersioning-基于命名空间的版本控制"><a href="#NamespaceVersioning-基于命名空间的版本控制" class="headerlink" title="NamespaceVersioning(基于命名空间的版本控制)"></a>NamespaceVersioning(基于命名空间的版本控制)</h3><p>匹配至包含不同版本路径的urlconf, 然后分配至对应的namespace</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bookings/urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^$'</span>, bookings_list, name=<span class="string">'bookings-list'</span>), </span><br><span class="line">    url(<span class="string">r'^(?P&lt;pk&gt;[0-9]+)/$'</span>, bookings_detail, name=<span class="string">'bookings-detail'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^v1/bookings/'</span>, include(<span class="string">'bookings.urls'</span>, namespace=<span class="string">'v1'</span>)), </span><br><span class="line">    url(<span class="string">r'^v2/bookings/'</span>, include(<span class="string">'bookings.urls'</span>, namespace=<span class="string">'v2'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>与URLPathVersioning相比, NamespaceVersioning适用用较大的项目, 因为所有的管理内容在urls.py中进行配置, 而非在各个view中通过request.version进行配置, 更易于管理.</p>
<hr>
<h3 id="自定义版本控制"><a href="#自定义版本控制" class="headerlink" title="自定义版本控制"></a>自定义版本控制</h3><p>子类化<code>BaseVersioning</code>并重写<code>.determine_version()</code>方法, 返回值为期望获取的版本号.</p>
<p>示例:使用自定义的X-API-Version头来确定请求的版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XAPIVersionScheme</span><span class="params">(versioning.BaseVersioning)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_version</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> request.META.get(<span class="string">'HTTP_X_API_VERSION'</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>如果自定义控制方案是基于URL获取version的, 还需要重写<code>reverse()</code>方法.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 分页 Pagination</title>
    <url>/2019/10/03/16.%20%E5%88%86%E9%A1%B5%E5%99%A8%20Paginator/</url>
    <content><![CDATA[<p>分页器可以将较多的数据分为若干页，并在每一页上给出上一页/下一页的链接. DRF支持自定义分页风格，并允许改变每页包含的数据的数量. </p>
<p>分页API应当支持:</p>
<ol>
<li>分页对象的链接，作为响应内容的一部分</li>
<li>分页对象的链接，作为响应头的一部分 (Content-Range或者Link)</li>
</ol>
<a id="more"></a>

<p>当前DRF内置分页器的分页风格都是将链接包含至内容中. </p>
<p>分页器仅会在使用通用视图或视图集时自动应用, 如果使用<code>APIView</code>, 需要自行调用分页接口来保证返回分页响应. 可以查看<code>mixins.ListModelMixin</code>和<code>generics.GenericAPIView</code>来查看示例代码.</p>
<p>将视图的<code>pagination_class</code>设为<code>None</code>可以关闭分页器.</p>
<hr>
<h3 id="设置使用分页器"><a href="#设置使用分页器" class="headerlink" title="设置使用分页器"></a>设置使用分页器</h3><p>全局设置</p>
<p>使用<code>DEFAULT_PAGINATION_CLASS</code>和<code>PAGE_SIZE</code>关键字来设置全局的分页风格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.LimitOffsetPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这两项都必须进行设置.</p>
<p>在view/viewset中则使用<code>pagination_class</code>属性指定分页类.</p>
<hr>
<h3 id="分页器在何处被应用"><a href="#分页器在何处被应用" class="headerlink" title="分页器在何处被应用?"></a>分页器在何处被应用?</h3><p><code>list</code>行为中需要对数量较大的查询集进行分页.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mixins.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="改变分页风格"><a href="#改变分页风格" class="headerlink" title="改变分页风格"></a>改变分页风格</h3><p>继承<code>PageNumberPagination</code>并重写相关属性来自定义分页器类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeResultsSetPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">1000</span></span><br><span class="line">    page_size_query_param = <span class="string">'page_size'</span></span><br><span class="line">    max_page_size = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardResultsSetPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">100</span></span><br><span class="line">    page_size_query_param = <span class="string">'page_size'</span></span><br><span class="line">    max_page_size = <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>如果指定<code>page_size_query_param</code>,则允许客户端来指定每页的大小.</p>
<p>然后在视图中使用自定义分页类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillingRecordsView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Billing.objects.all()</span><br><span class="line">    serializer_class = BillingRecordsSerializer</span><br><span class="line">    pagination_class = StandardResultsSetPagination</span><br></pre></td></tr></table></figure>

<p>或者设置为全局默认分页类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'apps.core.pagination.StandardResultsSetPagination'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="PageNumberPagination"><a href="#PageNumberPagination" class="headerlink" title="PageNumberPagination"></a>PageNumberPagination</h3><p>路径:<code>rest_framework.pagination.PageNumberPagination</code></p>
<p>只接受<code>page</code>作为查询参数</p>
<p>请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET https://api.example.org/accounts/?page=4</span><br></pre></td></tr></table></figure>

<p>响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"count"</span>: <span class="number">1023</span></span><br><span class="line">    <span class="string">"next"</span>: <span class="string">"https://api.example.org/accounts/?page=5"</span>,</span><br><span class="line">    <span class="string">"previous"</span>: <span class="string">"https://api.example.org/accounts/?page=3"</span>,</span><br><span class="line">    <span class="string">"results"</span>: [</span><br><span class="line">       …</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可重写属性如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>django_paginator_class</code></td>
<td>使用的Django中的分页器 默认为<code>django.core.paginator.Paginator</code></td>
</tr>
<tr>
<td><code>page_size</code></td>
<td>数字型，该属性会覆盖<code>PAGE_SIZE</code>，默认为与<code>PAGE_SIZE</code>等值</td>
</tr>
<tr>
<td><code>page_query_param</code></td>
<td>查询参数的关键字，默认为<code>&#39;page&#39;</code></td>
</tr>
<tr>
<td><code>page_size_query_param</code></td>
<td>查询参数中控制每页大小的关键字, 默认为<code>None</code>，即不受客户端控制，仅由服务器端控制.</td>
</tr>
<tr>
<td><code>max_page_size</code></td>
<td>如果设置该项，意味着可请求的最大分页数，该项只有在<code>page_query_param</code>已存在时合法</td>
</tr>
<tr>
<td><code>last_page_strings</code></td>
<td>字符串列表，当查询的<code>page_query_param</code>为其中的值时，返回最后一页，默认为<code>(&#39;last&#39;,)</code></td>
</tr>
<tr>
<td><code>template</code></td>
<td>返回时用来渲染的模板，默认为<code>rest_framework/pagination/numbers.html</code>，可设为<code>None</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="LimitOffsetPagination"><a href="#LimitOffsetPagination" class="headerlink" title="LimitOffsetPagination"></a>LimitOffsetPagination</h3><p>路径: <code>rest_framework.pagination.LimitOffsetPagination</code></p>
<p>支持<code>limit</code>和<code>offset</code>查询参数，较之<code>page</code>更为灵活，因为可以从任意处开始截取指定数量的数据. </p>
<p>请求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET https://api.example.org/accounts/?limit=100&amp;offset=400</span><br></pre></td></tr></table></figure>

<p>响应:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"count"</span>: <span class="number">1023</span></span><br><span class="line">    <span class="string">"next"</span>: <span class="string">"https://api.example.org/accounts/?limit=100&amp;offset=500"</span>,</span><br><span class="line">    <span class="string">"previous"</span>: <span class="string">"https://api.example.org/accounts/?limit=100&amp;offset=300"</span>,</span><br><span class="line">    <span class="string">"results"</span>: [</span><br><span class="line">       …</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果设置了<code>PAGE_SIZE</code>,那么<code>URL</code>中的<code>limit</code>查询参数就是可选的，如果URL中不包含<code>limit</code>，直接从<code>offset</code>处截取出<code>PAGE_SIZE</code>条数据. </p>
<p><code>LimitOffsetPagination</code>可重写的属性如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>default_limit</code></td>
<td>INT</td>
<td>与<code>PAGE_SIZE</code>的意义相同，如果设置，limit参数将为可选</td>
</tr>
<tr>
<td><code>limit_query_param</code></td>
<td>string</td>
<td>用来代表<code>limit</code>含义的关键字，默认就是<code>&#39;limit&#39;</code></td>
</tr>
<tr>
<td><code>offset_query_param</code></td>
<td>string</td>
<td>用来代表<code>offset</code>含义的关键字，默认就是<code>&#39;offset&#39;</code></td>
</tr>
<tr>
<td><code>max_limit</code></td>
<td>INT</td>
<td>用来控制可指定的最大限制条数，默认为<code>None</code></td>
</tr>
<tr>
<td><code>template</code></td>
<td>string</td>
<td>返回时使用的模板，默认为<code>rest_framework/pagination/numbers.html</code>，可以设为<code>None</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="CursorPagination-游标分页器"><a href="#CursorPagination-游标分页器" class="headerlink" title="CursorPagination 游标分页器"></a>CursorPagination 游标分页器</h3><p>不允许直接指定开始位置，页面大小或者请求页数，而只能从开始处逐渐进行偏移</p>
<p>基于光标的分页呈现不透明(无表义)的游标指示符，客户端可以使用该指示符来翻阅结果集. 此分页样式仅显示前向和后退控件，并且不允许客户端导航到任意位置. </p>
<p>基于游标的分页要求结果集中的项具有唯一且不变的排, 排序依据通常可能是记录上的创建时间戳，因为可以提供一致的分页排序. </p>
<p>优势如下:</p>
<ul>
<li>提供一致的分页视图. 正确使用CursorPagination可确保客户端在分页记录时永远不会看到相同的项目，即使在分页过程中其他客户端插入新项目时也是如此. </li>
<li>支持使用非常大的数据集. 对于极大的数据集，使用基于偏移的分页样式的分页可能变得低效或无法使用. 基于游标的分页方案具有固定时间属性，并且不会随著数据集大小的增加而减慢. </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.CursorPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认排序字段名为<code>&#39;created&#39;</code>，如果你的模型中不包含该字段，则必须子类化<code>CursorPagination</code>并重写该属性，然后应用该子类作为排序器</p>
<p>可重写的属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>page_size</code></td>
<td>INT</td>
<td>每页的数据量，同<code>PAGE_SIZE</code></td>
</tr>
<tr>
<td><code>cursor_query_param</code></td>
<td>string</td>
<td>代表cursor含义的查询参数，默认为<code>&#39;cursor&#39;</code></td>
</tr>
<tr>
<td><code>ordering</code></td>
<td>string|listofstring</td>
<td>用来进行后台排序的字段，默认为<code>&#39;-created&#39;</code>,该项会被OrderingFilter的设置所覆盖</td>
</tr>
<tr>
<td><code>template</code></td>
<td>string</td>
<td>返回数据时使用的模板，默认为<code>&quot;rest_framework/pagination/previous_and_next.html&quot;</code>，可以设为<code>None</code></td>
</tr>
</tbody></table>
<p>注意，ordering字段必须指定为该模型中的字段，该字段默认为<code>-created</code>，如果模型没有这个字段就会报错，因此需要为其指定一个存在的，可以用来排序的字段. </p>
<p>使用游标分页器的结果集必须为有序的，所以该字段是必需的.</p>
<p>该参数无法通过配置项实现，必须子类化然后覆盖该属性, 示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#blog/paginations.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> CursorPagination</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycursorpagnitor</span><span class="params">(CursorPagination)</span>:</span></span><br><span class="line">    ordering = <span class="string">'date_created'</span></span><br></pre></td></tr></table></figure>

<p>settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'blog.paginations.MyCursorPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP <span class="number">200</span> OK</span><br><span class="line">Allow: GET, POST, HEAD, OPTIONS</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Vary: Accept</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"next"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/blog/?cursor=bz0xJnA9MjAxOS0wNC0xMSsyMCUzQTAwJTNBMDAlMkIwMCUzQTAw"</span>,</span><br><span class="line">    <span class="string">"previous"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/blog/?cursor=cj0xJnA9MjAxOS0wNC0wOSsxOSUzQTQ2JTNBMzglMkIwMCUzQTAw"</span>,</span><br><span class="line">    <span class="string">"results"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"多标签测试用"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/category/4/"</span>,</span><br><span class="line">            <span class="string">"date_created"</span>: <span class="string">"2019-04-09T19:46:38Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"测试用例4 ，储存"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/category/1/"</span>,</span><br><span class="line">            <span class="string">"date_created"</span>: <span class="string">"2019-04-11T20:00:00Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"测试用例2 ，储存"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"http://127.0.0.1:8000/blog/api/category/2/"</span>,</span><br><span class="line">            <span class="string">"date_created"</span>: <span class="string">"2019-04-29T03:50:51.522801Z"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义分页器"><a href="#自定义分页器" class="headerlink" title="自定义分页器"></a>自定义分页器</h3><p>子类化<code>pagination.BasePagination</code>并重写</p>
<ol>
<li><code>paginate_queryset(self, queryset, request, view=None)</code>方法</li>
<li><code>get_paginated_response(self, data)</code>方法</li>
</ol>
<p><code>paginate_queryset</code>方法接收一个初始的查询集并返回一个只包含请求数据的可迭代对象(获取部分查询集并将其序列化,并返回序列化结果data)<br><code>get_paginated_response</code>方法接收已序列化的数据并返回一个<code>Response</code>实例 (简单地将数据嵌入某些格式中,并作为响应体的内容,返回一个Response) </p>
<p>注意<code>paginate_queryset</code>方法在分页器实例中设置状态，并可能随后被<code>get_paginated_response</code>方法所使用. </p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPagination</span><span class="params">(pagination.PageNumberPagination)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_paginated_response</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'links'</span>: &#123;</span><br><span class="line">                <span class="string">'next'</span>: self.get_next_link(),</span><br><span class="line">                <span class="string">'previous'</span>: self.get_previous_link()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'count'</span>: self.page.paginator.count,</span><br><span class="line">            <span class="string">'results'</span>: data</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'my_project.apps.core.pagination.CustomPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果如果想更改默认排序字段，当构造分页响应的body部分时应当使用<code>OrderedDict</code>，这是可选的</p>
<hr>
<h3 id="分页-amp-概要"><a href="#分页-amp-概要" class="headerlink" title="分页 &amp; 概要"></a>分页 &amp; 概要</h3><p>还可以通过实现<code>get_chema_fields()</code>方法来使REST框架自动生成的概要能够使用分页控件. </p>
<p>该函数的签名 <code>get_schema_fields(self, view)</code>, 返回值为一个<code>coreapi.Field</code>实例的列表. </p>
<p><img src="https://www.django-rest-framework.org/img/link-header-pagination.png" alt></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 过滤 Filter</title>
    <url>/2019/10/03/15.%20%E8%BF%87%E6%BB%A4%20Filter/</url>
    <content><![CDATA[<blockquote>
<p>“由Django Manager提供的全查询集描述了数据库表中的所有对象。可是通常你需要的只是选择所有对象中的一个子集而已。” —— Django文档</p>
</blockquote>
<p>REST-framework默认获得的是一个model的全部查询集, 而通常我们只需要其中一部分而已.</p>
<p>分页器解决的是将全部查询集分批次返回的问题, 而过滤则是要获得我们需要的那部分数据.</p>
<p>最简单的方法就是重写<code>GenericAPIView</code>的子类(例如viewset)的<code>get_queryset</code>方法, 通过重写该方法可以使用各种方式来自定义查询集. </p>
<a id="more"></a>

<hr>
<h3 id="根据当前用户进行过滤"><a href="#根据当前用户进行过滤" class="headerlink" title="根据当前用户进行过滤"></a>根据当前用户进行过滤</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> Purchase</span><br><span class="line"><span class="keyword">from</span> myapp.serializers <span class="keyword">import</span> PurchaseSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    serializer_class = PurchaseSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        This view should return a list of all the purchases</span></span><br><span class="line"><span class="string">        for the currently authenticated user.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        user = self.request.user</span><br><span class="line">        <span class="keyword">return</span> Purchase.objects.filter(purchaser=user)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="根据url的变量-查询参数进行查询"><a href="#根据url的变量-查询参数进行查询" class="headerlink" title="根据url的变量/查询参数进行查询"></a>根据url的变量/查询参数进行查询</h3><h4 id="根据url变量进行过滤"><a href="#根据url变量进行过滤" class="headerlink" title="根据url变量进行过滤"></a>根据url变量进行过滤</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#url.py</span></span><br><span class="line">url(<span class="string">'^purchases/(?P&lt;username&gt;.+)/$'</span>, PurchaseList.as_view()),</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    serializer_class = PurchaseSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        This view should return a list of all the purchases for</span></span><br><span class="line"><span class="string">        the user as determined by the username portion of the URL.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        username = self.kwargs[<span class="string">'username'</span>]</span><br><span class="line">        <span class="keyword">return</span> Purchase.objects.filter(purchaser__username=username)</span><br></pre></td></tr></table></figure>

<h4 id="根据查询参数进行过滤"><a href="#根据查询参数进行过滤" class="headerlink" title="根据查询参数进行过滤"></a>根据查询参数进行过滤</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    serializer_class = PurchaseSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        queryset = Purchase.objects.all()</span><br><span class="line">        username = self.request.query_params.get(<span class="string">'username'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queryset = queryset.filter(purchaser__username=username)</span><br><span class="line">        <span class="keyword">return</span> queryset</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h3><p>rest-framework提供了一些通用的过滤方案, 例如通过模型某些字段的值来过滤结果, 通过搜索功能以过滤结果等, 我们直接配置即可.</p>
<p>首先配置<code>filter_backend</code>, 然后配置相关项</p>
<hr>
<h3 id="SearchFilter-搜索过滤"><a href="#SearchFilter-搜索过滤" class="headerlink" title="SearchFilter 搜索过滤"></a>SearchFilter 搜索过滤</h3><p>支持简单的单参数查询过滤, 基于django admin 的 search 功能实现.</p>
<p>当使用SearchFilter时, 需要设置<code>search_fields</code>属性.<code>search_fields</code>是一个包含该模型text类型字段(例如CharField/TextField)的字符串列表, 对于外键字段, 则需要指定该外键对应外模型的text类型字段, 用双下划线连接.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    filter_backends = [filters.SearchFilter]</span><br><span class="line">    search_fields = [<span class="string">'username'</span>, <span class="string">'email'</span>, <span class="string">'country__country_name'</span>]</span><br></pre></td></tr></table></figure>

<p>然后就可以支持如下的url请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?search=russell</span><br></pre></td></tr></table></figure>

<p>另外, 支持在search_field添加一些符号来更改搜索行为的限制</p>
<p><code>=</code>: exact match 完全匹配<br><code>^</code>: start-with 开头匹配<br><code>@</code>: full-text 全文搜索(仅支持MySQL后端)<br><code>$</code>: regex 正则搜索</p>
<p>例如<br><code>search_fields = [&#39;=username&#39;, &#39;=email&#39;]</code></p>
<p>在默认情况下, 搜索的查询参数名为<code>search</code>, 可以通过<code>SEARCH_PARAM</code>设置项修改, 或者通过<code>get_search_fields()</code>方法动态获得.</p>
<hr>
<h3 id="OrderingFilter-排序过滤"><a href="#OrderingFilter-排序过滤" class="headerlink" title="OrderingFilter 排序过滤"></a>OrderingFilter 排序过滤</h3><p>指定过滤后端, 并指定<code>ordering_fields</code>给出要用以排序的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    filter_backends = [filters.OrderingFilter]</span><br><span class="line">    ordering_fields = [<span class="string">'username'</span>, <span class="string">'email'</span>]</span><br></pre></td></tr></table></figure>

<p>默认的搜索查询参数名为<code>search</code>, 可以通过<code>ORDERING_PARAM</code>设置项修改.</p>
<p>现在可以将这些字段包含在url的查询参数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?ordering=username</span><br></pre></td></tr></table></figure>

<p>或者使用<code>-</code>来指定反向排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?ordering=-username</span><br></pre></td></tr></table></figure>

<p>或者指定多个排序字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/users?ordering=account, username</span><br></pre></td></tr></table></figure>

<p>如果未指定ordering_fields, 则客户端可以通过序列化器的任何readable字段进行排序.(可能会引起某些敏感信息的泄露)</p>
<p>如果确定可以通过model的任意字段进行排序, 可以显式地指定其值为<code>__all__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookingsListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Booking.objects.all()</span><br><span class="line">    serializer_class = BookingSerializer</span><br><span class="line">    filter_backends = [filters.OrderingFilter]</span><br><span class="line">    ordering_fields = <span class="string">'__all__'</span></span><br></pre></td></tr></table></figure>

<p>或者通过ordering属性指定默认排序字段, 数据类型为字符串或字符串列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    filter_backends = [filters.OrderingFilter]</span><br><span class="line">    ordering_fields = [<span class="string">'username'</span>, <span class="string">'email'</span>]</span><br><span class="line">    ordering = [<span class="string">'username'</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DjangoFilterBackend"><a href="#DjangoFilterBackend" class="headerlink" title="DjangoFilterBackend"></a>DjangoFilterBackend</h3><p><code>django-filter</code>库提供了<code>DjangoFilterBackend</code>类, 支持高度定制化的字段过滤. </p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install django-filters</span><br></pre></td></tr></table></figure>

<p>然后将其添加至django项目settings.py的<code>INSTALLED_APPS</code>中.</p>
<p>之后将<code>DjangoFilterBackend</code>设置为rest-framework的默认过滤后端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_FILTER_BACKENDS'</span>: [<span class="string">'django_filters.rest_framework.DjangoFilterBackend'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在view/viewset中通过<code>filter_backends</code>指定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    filter_backends = [DjangoFilterBackend]</span><br></pre></td></tr></table></figure>

<p>如果需要简单的等值查询, 可以设置view/viewset的<code>filterset_fields</code>属性, 指定该过滤后端所使用的字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend]</span><br><span class="line">    filterset_fields = [<span class="string">'category'</span>, <span class="string">'in_stock'</span>]</span><br></pre></td></tr></table></figure>

<p>指定<code>filterset_fields</code>属性会自动生成一个包含这些字段的<code>FilterSet</code>类, 支持如下形式的request</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://example.com/api/products?category=clothing&amp;in_stock=True</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义通用过滤"><a href="#自定义通用过滤" class="headerlink" title="自定义通用过滤"></a>自定义通用过滤</h3><p>继承<code>BaseFilterBackend</code>, 并重写<code>.filter_queryset(self, request, queryset, view)</code>方法, 该方法应该返回一个新的, 过滤后的查询集.</p>
<p>示例: 一个只允许用户获得自己创建的对象的过滤后端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsOwnerFilterBackend</span><span class="params">(filters.BaseFilterBackend)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Filter that only allows users to see their own objects.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter_queryset</span><span class="params">(self, request, queryset, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> queryset.filter(owner=request.user)</span><br></pre></td></tr></table></figure>

<p>自定义过滤后端相较于直接将逻辑写在<code>get_queryset</code>方法中, 优势在于易于复用.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 限流 Throttling</title>
    <url>/2019/10/03/14.%20%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>限流(Throttling)和权限类似, 用以判断一个请求是否应该被处理. 限流是一种<strong>临时</strong>的状态, 用以限制<strong>一段时间内</strong>客户端可以对API发起请求的速率.</p>
<p>在rest-framework中, 可以使用多重限制, 以适用不同的请求类型.</p>
<p>例如定义一个全局的限流策略, 但对已登录的用户施以更少的限制, 或者对一些资源密集型接口施以更严格的限制, 或是施加多重速率限制, 例如将用户的请求限制为每分钟60个请求，但不能多于每天1000个请求.</p>
<p>跟权限一样, 所有的限流检查会在view被执行<strong>之前</strong>进行, 如果限流认证未通过, 抛出<code>exceptions.Throttled</code>, 主体函数不会被执行.</p>
<a id="more"></a>

<p>在使用限流系统时, 有如下两个技术问题:</p>
<ol>
<li>区别不同客户端, 以保证每个客户端作为限流的基本单位的依据到底是什么?</li>
<li>在何处存储每个客户端以及其近期访问的统计数据?</li>
</ol>
<p>对于前者, 在未登录的情况下, 使用的是<code>X-Forwarded-For</code>(HTTP头)和<code>REMOTE_ADDR</code>(WSGI变量)来作为每个客户端特有的标识, 优先级递减.而在登陆的状态下, 使用的则是用户id.</p>
<p>而后者, 答案是Django的缓存. 限流的实现需要使用缓存来保存每个客户端近期已请求的API及其次数等数据, 因此要使用限流必须保证Django的缓存被正确配置.</p>
<p>默认情况下, rest-framework使用默认缓存(default)来保存数据, 如果想指定缓存, 可以重写限流类的<code>cache</code>属性.</p>
<p>更改限流类使用的缓存的示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> caches</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomAnonRateThrottle</span><span class="params">(AnonRateThrottle)</span>:</span></span><br><span class="line">    cache = caches[<span class="string">'alternate'</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="设定限流策略"><a href="#设定限流策略" class="headerlink" title="设定限流策略"></a>设定限流策略</h3><p>我们可以从两个层次设定限流策略</p>
<ol>
<li>全局限流策略, 任何不被单独指定的view会应用该限流策略</li>
<li>视图级别的限流策略, 单独指定某个view/viewset范围内的限流策略, 通过throttle_classes属性给出</li>
</ol>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py 全局限流设置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.throttling.AnonRateThrottle'</span>, </span><br><span class="line">        <span class="string">'rest_framework.throttling.UserRateThrottle'</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'anon'</span>: <span class="string">'100/day'</span>, </span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'1000/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个限流都需要有一个<code>rate</code>属性, 来指定自己的速率限制.我们可以直接重写某个默认限流类并修改rate属性, 也可以在setting中直接配置.</p>
<p>rate是一个字符串, 格式为 <code>次数/时间段</code>, 时间段可用’day’, ‘hour’, ‘minute’, ‘second’, 例如<code>&#39;100/day&#39;</code>, <code>&#39;10/minute&#39;</code> </p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><p>rest-framework 提供了三个限流类</p>
<h3 id="AnonRateThrottle"><a href="#AnonRateThrottle" class="headerlink" title="AnonRateThrottle"></a>AnonRateThrottle</h3><p>用于匿名(未登录)用户的限流, ip地址作为限流依据. </p>
<p>限流速率的给出方式(优先级递减):</p>
<ol>
<li>rate属性</li>
<li>settings文件中的<code>DEFAULT_THROTTLE_RATES[&#39;anon&#39;]</code>项</li>
</ol>
<p><code>UserRateThrottle</code>在简单地为匿名用户设定全局速率限制时适用.</p>
<hr>
<h3 id="UserRateThrottle"><a href="#UserRateThrottle" class="headerlink" title="UserRateThrottle"></a>UserRateThrottle</h3><p>用于已登录用户的限流, 用户id作为限流依据</p>
<p>限流速率的给出方式</p>
<ol>
<li>rate属性</li>
<li>setting文件中的<code>DEFAULT_THROTTLE_RATES[&#39;user&#39;]</code>项</li>
</ol>
<p>可以使用多个UserRateThrottle的子类来实现多重限制.</p>
<p>例如</p>
<p>首先定义多个UserRateThrottle的子类, 并为其指定不同的scope, 以在设置文件中通过<code>DEFAULT_THROTTLE_RATES[scope]</code>为其设定不同rate</p>
<p>(直接重写rate的方式, 显然不如在setting中统一配置更易管理)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BurstRateThrottle</span><span class="params">(UserRateThrottle)</span>:</span></span><br><span class="line">    scope = <span class="string">'burst'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SustainedRateThrottle</span><span class="params">(UserRateThrottle)</span>:</span></span><br><span class="line">    scope = <span class="string">'sustained'</span></span><br></pre></td></tr></table></figure>

<p>然后在setting中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'example.throttles.BurstRateThrottle'</span>, </span><br><span class="line">        <span class="string">'example.throttles.SustainedRateThrottle'</span></span><br><span class="line">    ], </span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'burst'</span>: <span class="string">'60/min'</span>, </span><br><span class="line">        <span class="string">'sustained'</span>: <span class="string">'1000/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserRateThrottle</code>在简单地为每个用户设定全局速率限制时适用.</p>
<hr>
<h3 id="ScopedRateThrottle"><a href="#ScopedRateThrottle" class="headerlink" title="ScopedRateThrottle"></a>ScopedRateThrottle</h3><p>AnonRateThrottle 和 UserRateThrottle 两个限流类都是全局应用的.</p>
<p>例如一个已登录用户, 对任意API的访问次数都被累计, 在达到UserRateThrottle的上限时, 则暂时无法访问任何API.</p>
<p>这显然是不合适的, 我们应该对一些高代价的API施加严格的限制, 但另一些API则应该相当宽松, 而这些API的访问次数累计和访问限制应当分开计算, 即使是来自同一用户的访问.</p>
<p>ScopedRateThrottle类可以按照不同的标识将一些API分组计算, 每个ScopedRateThrottle仅会累计匹配自己唯一标识的API的访问次数.</p>
<p>首先我们为一些View指定限流标识</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactListView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'contacts'</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactDetailView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'contacts'</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'uploads'</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>然后在设置中使用<code>DEFAULT_THROTTLE_RATES[throttle_scope]</code>的方式为每一个限流scope指定速率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.throttling.ScopedRateThrottle'</span>, </span><br><span class="line">    ], </span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'contacts'</span>: <span class="string">'1000/day'</span>, </span><br><span class="line">        <span class="string">'uploads'</span>: <span class="string">'20/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们施加多重速率限制的不同, 在使用UserRateThrottle类时, 我们使用了多个UserRateThrottle的子类来施加多重速率限制, 不同的scope在不同的限流类(子类)中.</p>
<p>而在使用ScopedRateThrottle类时, 我们仅需要指定为view指定不同标识, 然后设定不同标识的限制速率即可, 使用的就是ScopedRateThrottle本身.不同的throttle_scope在不同的view中.</p>
<p>另一点则相当明确: 以上的所有代码中, 我们都不重写rate属性, 而是在设置文件中使用DEFAULT_THROTTLE_RATES[x-scope]的方式进行设置, 这样更易管理.</p>
<hr>
<h3 id="Custom-throttles-自定义限流类"><a href="#Custom-throttles-自定义限流类" class="headerlink" title="Custom throttles 自定义限流类"></a>Custom throttles 自定义限流类</h3><p>自定义限流类需要重写<code>BaseThrottle</code>并实现<code>.allow_request(self, request, view)</code>方法.该方法应该返回一个布尔型, 以判定是否通过了限流验证.</p>
<p>除此之外, 还可以实现<code>.wait()</code>方法, 该方法在allow_request方法返回false时被调用, 应当返回一个推荐值, 指定在接受下一个请求前应当间隔的时间.</p>
<p>在实现了<code>wait()</code>方法后, 如果该方法被调用, 响应中会包含<code>Retry-After</code>头, 以告知客户端应当在推荐值之后再重试.</p>
<p>示例代码 实现一个随机10选9的限流类.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomRateThrottle</span><span class="params">(throttling.BaseThrottle)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_request</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> random.randint(<span class="number">1</span>, <span class="number">10</span>) != <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 缓存 Cache</title>
    <url>/2019/10/03/13.%20%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>rest-framework中的缓存行为可以非常简单地使用Django的缓存来实现.</p>
<a id="more"></a>
<hr>
<h3 id="在APIView和ViewSets中使用缓存"><a href="#在APIView和ViewSets中使用缓存" class="headerlink" title="在APIView和ViewSets中使用缓存"></a>在APIView和ViewSets中使用缓存</h3><p>Django提供了<code>method_decorator</code>以便装饰器能够用在<strong>方法</strong>上，所以仍然可以使用<code>@cache_page</code>或<code>vary_on_cookie</code>这些缓存相关的装饰器来装饰的ViewSet中的方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.Viewset)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Cache requested url for each user for 2 hours</span></span><br><span class="line"><span class="meta">    @method_decorator(cache_page(60*60*2))</span></span><br><span class="line"><span class="meta">    @method_decorator(vary_on_cookie)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        content = &#123;</span><br><span class="line">            <span class="string">'user_feed'</span>: request.user.get_user_feed()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostView</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Cache page for the requested url</span></span><br><span class="line"><span class="meta">    @method_decorator(cache_page(60*60*2))</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        content = &#123;</span><br><span class="line">            <span class="string">'title'</span>: <span class="string">'Post title'</span>,</span><br><span class="line">            <span class="string">'body'</span>: <span class="string">'Post content'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure>

<p>注意, <code>cache_page</code>仅会缓存<code>GET</code>和<code>HEAD</code>请求获取的状态码为200的响应.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 权限 Permissions</title>
    <url>/2019/10/03/12.%20%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>权限与身份认证和限流一起决定一个请求是否应该被允许或是拒绝.</p>
<p>权限检查在视图函数主体运行之前进行, 只有检查通过才会执行函数体, 权限一般使用<code>reuqest.user</code>或者<code>request.auth</code>的信息来进行验证.</p>
<p>rest-framework 中的权限应当始终指定为一个权限类的列表, 列表所有的权限对象必须<strong>都</strong>通过之后才被视为通过.任意权限类检查失败, 会抛出一个<code>exceptions.PermissionDenied</code>或<code>exceptions.NotAuthenticated</code>异常.</p>
<a id="more"></a>


<p>权限检查失败时, 响应的状态码为 <code>403 Forbidden</code> 或 <code>401 Unauthorized</code></p>
<ul>
<li>如果请求通过用户身份认证, 但权限不足, 会返回<code>403 Forbidden</code></li>
<li>如果请求未通过用户身份认证, 但身份认证类不使用<code>WWW-Authenticate</code>头时, 也会返回<code>403 Unauthorized</code></li>
<li>如果请求未通过用户身份认证, 且最先应用的身份认证类中使用<code>WWW-Authenticate</code>, 会返回<code>401 Unauthorized</code>, 并包含合适的<code>WWW-Authenticate</code>头.</li>
</ul>
<hr>
<h3 id="对象级别的权限"><a href="#对象级别的权限" class="headerlink" title="对象级别的权限"></a>对象级别的权限</h3><p>这里的对象一般指的是一个Model的实例, 即某一条数据记录.</p>
<p>对象级别的权限验证会在GenericAPIView及其子类的<code>get_object()</code>方法被调用时进行验证.</p>
<p>如果对象级别的权限验证未通过, 会抛出<code>exceptions.PermissionDenied</code>异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self)</span>:</span></span><br><span class="line">    obj = get_object_or_404(self.get_queryset(), pk=self.kwargs[<span class="string">"pk"</span>])</span><br><span class="line">    self.check_object_permissions(self.request, obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>在rest-framework所提供的所有权限验证类中, 并不直接提供对象级别的验证, 所有的该级别验证都需要通过重写<code>has_object_permission()</code>实现, 而rest-framework会自动使用该方法检查权限.</p>
<p>详情查阅<strong>自定义权限验证</strong>一节. </p>
<hr>
<h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>全局权限设置通过settings的<code>DEFAULT_PERMISSION_CLASSES</code>项进行设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span>, </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者通过<code>permission_classes</code>属性为指定APIview进行设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    permission_classes = (IsAuthenticated, )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在视图中指定permission_classes意味着忽略默认的权限验证类</p>
<p>另外, 每个权限项可以由多个权限类用<code>|</code>、<code>&amp;</code>、<code>~</code>来组合作为权限类列表中的一个对象.</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission, IsAuthenticated, SAFE_METHODS</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadOnly</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> request.method <span class="keyword">in</span> SAFE_METHODS</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    permission_classes = [IsAuthenticated|ReadOnly]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        content = &#123;</span><br><span class="line">            <span class="string">'status'</span>: <span class="string">'request was permitted'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><p>以下各项从<code>rest_framework.permissions</code>中导出</p>
<hr>
<h3 id="AllowAny"><a href="#AllowAny" class="headerlink" title="AllowAny:"></a>AllowAny:</h3><p>无论如何, 允许无限制访问</p>
<hr>
<h3 id="IsAuthenticated"><a href="#IsAuthenticated" class="headerlink" title="IsAuthenticated:"></a>IsAuthenticated:</h3><ol>
<li>身份认证通过, 允许任何访问.</li>
<li>身份认证未通过, 禁止任何访问.</li>
</ol>
<hr>
<h3 id="IsAdminUser"><a href="#IsAdminUser" class="headerlink" title="IsAdminUser"></a>IsAdminUser</h3><ol>
<li>用户的is_stuff == True, 允许任何访问</li>
<li>用户的is_stuff == False, 禁止任何访问</li>
</ol>
<hr>
<h3 id="IsAuthenticatedOrReadOnly"><a href="#IsAuthenticatedOrReadOnly" class="headerlink" title="IsAuthenticatedOrReadOnly"></a>IsAuthenticatedOrReadOnly</h3><ol>
<li>身份认证通过, 允许任何访问</li>
<li>身份认证未通过, 允许只读访问</li>
</ol>
<hr>
<h3 id="DjangoModelPermissions"><a href="#DjangoModelPermissions" class="headerlink" title="DjangoModelPermissions"></a>DjangoModelPermissions</h3><p>该权限与DjangoModelPermissions相关联, 对于用户不同方式的请求, 验证对应的django权限(Model级别的权限验证)</p>
<p>因为必须与模型相关联, 该权限类仅能应用于具有.queryset属性的视图, 且仅有<strong>通过身份认证</strong>的用户才有可能通过权限验证</p>
<ul>
<li><code>POST</code> 请求要求用户对模型具有添加权限。</li>
<li><code>PUT</code> 和 <code>PATCH</code> 请求要求用户对模型具有更改权限。</li>
<li><code>DELETE</code>请求要求用户对模型具有删除权限。</li>
</ul>
<p>如果为匿名用户, 则一定被禁止.</p>
<hr>
<h3 id="DjangoModelPermissionsOrAnonReadOnly"><a href="#DjangoModelPermissionsOrAnonReadOnly" class="headerlink" title="DjangoModelPermissionsOrAnonReadOnly"></a>DjangoModelPermissionsOrAnonReadOnly</h3><p>与前者类似, 但允许匿名用户拥有只读权限.</p>
<hr>
<h3 id="DjangoObjectPermissions"><a href="#DjangoObjectPermissions" class="headerlink" title="DjangoObjectPermissions"></a>DjangoObjectPermissions</h3><p>该类由<a href="https://github.com/rpkilby/django-rest-framework-guardian" target="_blank" rel="noopener">djangorestframework-guardian package</a>提供.</p>
<p>绑定于Django的对象级别的权限验证, 允许对每个对象的权限(Model的实例, 对象级别的权限验证)进行单独指定.</p>
<p>当然, Django默认不支持该功能, 因此需要添加一个支持对象级别权限的权限后端, 例如<code>django-guardian</code></p>
<p>与DjangoModelPermissions一样, 该权限只有在用户已通过身份认证, 且用于与HTTP METHOD相对应的对象级别权限时才会被通过.</p>
<hr>
<h2 id="自定义权限验证"><a href="#自定义权限验证" class="headerlink" title="自定义权限验证"></a>自定义权限验证</h2><p>子类化<code>BasePermission</code>并实现以下两个方法</p>
<ul>
<li><code>.has_permission(self, request, view)</code></li>
<li><code>.has_object_permission(self, request, view, obj)</code></li>
</ul>
<p>这两个方法都应当返回一个布尔型, <code>True</code>代表验证通过, <code>False</code>则代表验证未通过.</p>
<p>前者代表模型级别的权限验证, 后者则是对象级别的权限验证</p>
<p>对象级别的权限验证仅当<code>get_object()</code>被调用时进行检查, 且必须在模型级别的验证通过时才会进行到这一步.</p>
<p>在GenericAPIView的子类中会自动调用<code>check_object_permissions</code>, 而在APIView的子类中你必须手动调用这一方法.</p>
<p>只读操作的HTTP METHOD为<code>GET</code>, <code>OPTION</code>及<code>HEAD</code>, 包含在<code>permissions.SAFE_METHODS</code>中.</p>
<p>示例</p>
<p>使用权限类实现黑名单. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlacklistPermission</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Global permission check for blacklisted IPs.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        ip_addr = request.META[<span class="string">'REMOTE_ADDR'</span>]</span><br><span class="line">        blacklisted = Blacklist.objects.filter(ip_addr=ip_addr).exists()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> blacklisted</span><br></pre></td></tr></table></figure>

<p>自定义权限类, 仅允许对象的拥有者进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsOwnerOrReadOnly</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Object-level permission to only allow owners of an object to edit it.</span></span><br><span class="line"><span class="string">    Assumes the model instance has an `owner` attribute.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_object_permission</span><span class="params">(self, request, view, obj)</span>:</span></span><br><span class="line">        <span class="comment"># Read permissions are allowed to any request, </span></span><br><span class="line">        <span class="comment"># so we'll always allow GET, HEAD or OPTIONS requests.</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Instance must have an attribute named `owner`.</span></span><br><span class="line">        <span class="keyword">return</span> obj.owner == request.user</span><br></pre></td></tr></table></figure>

<p>值得注意的是, 在list操作中, 仅会进行模型级别的权限检查, 对象级别的权限不会被检查(只有在get_object方法被调用时才会进行对象级别的检查), 因此如果有必要, 则需要将其验证逻辑写入filter而非对象级别的权限中, 这样才能保证在get_queryset时获取到适当的queryset. </p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 序列化器 Validator</title>
    <url>/2019/10/03/11.%20%E9%AA%8C%E8%AF%81%E5%99%A8/</url>
    <content><![CDATA[<p>验证器用以确保数据的合法性.在rest-framework中, 验证器应当在字段定义时serializer的Meta中指定. </p>
<p>如果使用的是<code>ModelSerializer</code>, 那么会自动根据<code>Model</code>的字段类型及约束自动生成相关的验证器, 因此大多数时候不太需要手写验证器.</p>
<p>可以使用<code>repr</code>函数查看自动生成的Serializer的定义代码, 该代码包含了全部的验证逻辑, 验证逻辑也仅执行于此处.</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerReportRecord</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    time_raised = models.DateTimeField(default=timezone.now, editable=<span class="literal">False</span>)</span><br><span class="line">    reference = models.CharField(unique=<span class="literal">True</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    description = models.TextField()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serializers.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerReportSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CustomerReportRecord</span><br></pre></td></tr></table></figure>

<p>运行 python manage.py shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from project.example.serializers import CustomerReportSerializer</span><br><span class="line">&gt;&gt;&gt; serializer = CustomerReportSerializer()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(repr(serializer))</span><br><span class="line">CustomerReportSerializer():</span><br><span class="line">    id = IntegerField(label=<span class="string">'ID'</span>, read_only=True)</span><br><span class="line">    time_raised = DateTimeField(read_only=True)</span><br><span class="line">    reference = CharField(max_length=20, validators=[&lt;UniqueValidator(queryset=CustomerReportRecord.objects.all())&gt;])</span><br><span class="line">    description = CharField(style=&#123;<span class="string">'type'</span>: <span class="string">'textarea'</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><hr>
<h3 id="UniqueValidator-唯一约束验证"><a href="#UniqueValidator-唯一约束验证" class="headerlink" title="UniqueValidator 唯一约束验证"></a>UniqueValidator 唯一约束验证</h3><p>实例化时的参数:</p>
<ol>
<li>queryset：划定唯一约束的范围</li>
<li>message: 可选, 验证失败时的错误消息</li>
<li>lookup: 可选, 用于限定对queryset中数据的重复性定义, 默认为exact, 即该字段的值准确等于queryset中的某条数据, 视为重复</li>
</ol>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.validators <span class="keyword">import</span> UniqueValidator</span><br><span class="line"></span><br><span class="line">slug = SlugField(</span><br><span class="line">    max_length=<span class="number">100</span>, </span><br><span class="line">    validators=[UniqueValidator(queryset=BlogPost.objects.all())]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="UniqueTogetherValidator-联合唯一约束验证"><a href="#UniqueTogetherValidator-联合唯一约束验证" class="headerlink" title="UniqueTogetherValidator 联合唯一约束验证"></a>UniqueTogetherValidator 联合唯一约束验证</h3><p>实例化时的参数:</p>
<ol>
<li>queryset: 用于验证的查询集</li>
<li>fields: 联合唯一约束的字段列表</li>
<li>message: 可选, 验证失败时的错误消息</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.validators <span class="keyword">import</span> UniqueTogetherValidator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># ToDo items belong to a parent list, and have an ordering defined</span></span><br><span class="line">        <span class="comment"># by the 'position' field. No two items in a given list may share</span></span><br><span class="line">        <span class="comment"># the same position.</span></span><br><span class="line">        validators = [</span><br><span class="line">            UniqueTogetherValidator(</span><br><span class="line">                queryset=ToDoItem.objects.all(), </span><br><span class="line">                fields=(<span class="string">'list'</span>, <span class="string">'position'</span>)</span><br><span class="line">            )</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>注意：UniqueTogetherValidation类始终强制使用隐式约束, 即它所应用的所有字段始终视为required, 可以使用默认值.</p>
<h3 id="UniqueFor-lt-Range-gt-Validator-时段内唯一约束"><a href="#UniqueFor-lt-Range-gt-Validator-时段内唯一约束" class="headerlink" title="UniqueFor&lt;Range&gt;Validator 时段内唯一约束"></a>UniqueFor&lt;Range&gt;Validator 时段内唯一约束</h3><p><code>UniqueForDateValidator</code> 当日唯一约束<br><code>UniqueForMonthValidator</code> 当月唯一约束<br><code>UniqueForYearValidator</code> 当年唯一约束</p>
<p>实例化时的参数</p>
<ol>
<li>queryset： 用于验证的查询集</li>
<li>field： 字段名, 必须为序列化器中的字段</li>
<li>date_field： 用来判读日期的字段, 必须为序列化器中的日期相关字段</li>
<li>message:可选, 验证失败时的错误消息</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.validators <span class="keyword">import</span> UniqueForYearValidator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># Blog posts should have a slug that is unique for the current year.</span></span><br><span class="line">        validators = [</span><br><span class="line">            UniqueForYearValidator(</span><br><span class="line">                queryset=BlogPostItem.objects.all(), </span><br><span class="line">                field=<span class="string">'slug'</span>, </span><br><span class="line">                date_field=<span class="string">'published'</span></span><br><span class="line">            )</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>注意, <code>date_field</code>字段必须在序列化器进行验证逻辑之前传入序列化器.</p>
<p>这意味着如果不打算从前端传入该日期字段, 则需要保证提供的默认值是在序列化器层次, 而非Model层次. 因为在验证时, Model的默认值函数尚未触发.</p>
<p>如果使用的是ModelSerializer, 会自动将Model字段的默认值作为自己对应序列化器字段的默认值, 因此不用出现问题. </p>
<p>而如果是手写的字段, 就必须显式地为其指定默认值, 否则该验证就无法进行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">published = serializers.DateTimeField(required=<span class="literal">True</span>) <span class="comment">#该字段必须被前端传入</span></span><br><span class="line">published = serializers.DateTimeField(read_only=<span class="literal">True</span>, default=timezone.now) <span class="comment">#该字段不允许前端传入, 但提供默认值</span></span><br><span class="line">published = serializers.HiddenField(default=timezone.now) <span class="comment">#该字段可以由前端传入, 也提供默认值</span></span><br></pre></td></tr></table></figure>

<p>总之, 无论是限制前端必须传入该值, 抑或为其提供默认值, 保证的是当前进行验证时, 该字段已被填充.</p>
<hr>
<h3 id="进阶默认值用法"><a href="#进阶默认值用法" class="headerlink" title="进阶默认值用法"></a>进阶默认值用法</h3><p>当我们不希望某个字段由用户传入时, 通常将其设定为只读并指定其默认值, 不过rest-framework提供了专属字段来简化这一流程.</p>
<p><code>CurrentUserDefault</code>: 自动填充当前用户, 在初始化时必须在context参数中传入request才可用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">owner = serializers.HiddenField(</span><br><span class="line">    default=serializers.CurrentUserDefault()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>CreateOnlyDefault</code>: 仅当序列化器进行<strong>创建</strong>(而非更新)行为时, 生成该字段的默认值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">created_at = serializers.DateTimeField(</span><br><span class="line">    read_only=<span class="literal">True</span>, </span><br><span class="line">    default=serializers.CreateOnlyDefault(timezone.now)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="验证器的限制"><a href="#验证器的限制" class="headerlink" title="验证器的限制"></a>验证器的限制</h2><p>在一些情况下, 必须要手写验证器, 而不是使用<code>ModelSerializer</code>自动生成的验证器.</p>
<h3 id="联合唯一约束的某个字段被设置为可选字段-required-False"><a href="#联合唯一约束的某个字段被设置为可选字段-required-False" class="headerlink" title="联合唯一约束的某个字段被设置为可选字段(required=False)"></a>联合唯一约束的某个字段被设置为可选字段(required=False)</h3><p>有的时候确实有这种需求, 而此时默认生成的联合唯一约束验证器的行为是不明确的, 因此必须将其显式排除并酌情考虑是否需要手写一个行为明确的验证器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillingRecordSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># Apply custom validation either here, or in the view.</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        fields = [<span class="string">'client'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>]</span><br><span class="line">        extra_kwargs = &#123;<span class="string">'client'</span>: &#123;<span class="string">'required'</span>: <span class="literal">False</span>&#125;&#125;</span><br><span class="line">        validators = []  <span class="comment"># Remove a default "unique together" constraint.</span></span><br></pre></td></tr></table></figure>

<h3 id="更新嵌套序列化器"><a href="#更新嵌套序列化器" class="headerlink" title="更新嵌套序列化器"></a>更新嵌套序列化器</h3><p>当嵌套序列化器在更新数据记录时, 唯一约束验证会将当前实例(指记录)排除其进行检查的查询集, 因为当前实例在进行序列化器被实例化时是通过<code>instance=...</code>传入的, 因此在序列化器验证时是可以直接访问的, 所以排除当前实例是可以完成的.</p>
<p>而对于嵌套序列化器的更新操作, 实例并不可用, 也就无法排除当前实例.因此, 也需要显式地移除默认生成的验证器, 并酌情考虑是否需要手写一个验证器.</p>
<hr>
<h3 id="在复杂情况下调试"><a href="#在复杂情况下调试" class="headerlink" title="在复杂情况下调试"></a>在复杂情况下调试</h3><p>至少应该使用repr查看自动生成的验证器的具体代码, 如果有必要, 最好不使用ModelSerializer自动生成的验证器, 而是手写验证器, 这样可以让验证行为更加透明. </p>
<hr>
<h2 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h2><hr>
<h3 id="基于函数的验证器"><a href="#基于函数的验证器" class="headerlink" title="基于函数的验证器"></a>基于函数的验证器</h3><p>该函数需要一个参数用以接收字段的值, 并保证在验证失败时抛出一个<code>serializers.ValidationError</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">even_number</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'This field must be an even number.'</span>)</span><br></pre></td></tr></table></figure>

<p>基于函数的验证器也可以通过直接在序列化器中定义<code>validate_&lt;field_name&gt;</code>方法的方式提供.</p>
<hr>
<h3 id="基于类的验证器"><a href="#基于类的验证器" class="headerlink" title="基于类的验证器"></a>基于类的验证器</h3><p>基于类的验证器需要实现<strong>call</strong>方法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleOf</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base)</span>:</span></span><br><span class="line">        self.base = base</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value % self.base != <span class="number">0</span>:</span><br><span class="line">            message = <span class="string">'This field must be a multiple of %d.'</span> % self.base</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(message)</span><br></pre></td></tr></table></figure>

<p>使用<code>set_context()</code></p>
<p>进阶情况下, 验证器可能需要传入序列化器字段来进行验证, 可以通过声明<code>set_context()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_context</span><span class="params">(self, serializer_field)</span>:</span></span><br><span class="line">    <span class="comment"># Determine if this is an update or a create operation.</span></span><br><span class="line">    <span class="comment"># In `__call__` we can then use that information to modify the validation behavior.</span></span><br><span class="line">    self.is_update = serializer_field.parent.instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>10.2 序列化器字段:关系字段 Serializer Field</title>
    <url>/2019/10/03/10.2%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%AD%97%E6%AE%B5-%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>关系字段用来表示模型之间的关系, 这些字段可用于映射外键, 多对多关系字段, 和单对单关系字段, 反向关联字段, 也可以自定义关系字段.</p>
<p>所有的关系字段定义在<code>relations.py</code>中, 但出于方便起见, 应该在<code>serializers</code>模块中导出, 然后通过<code>serializers.&lt;FieldName&gt;</code>使用关系字段.</p>
<a id="more"></a>

<hr>
<h4 id="查看关系"><a href="#查看关系" class="headerlink" title="查看关系"></a>查看关系</h4><p>当使用<code>ModelSerializer</code>时, 序列化器字段和关系字段都被自动生成, 查看具体定义可以帮助你决定如何自定义关系风格.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python manage.py shell</span></span><br><span class="line">&gt;&gt;&gt; from myapp.serializers import AccountSerializer</span><br><span class="line">&gt;&gt;&gt; serializer = AccountSerializer()</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(repr(serializer))</span><br><span class="line">AccountSerializer():</span><br><span class="line">    id = IntegerField(label=<span class="string">'ID'</span>, read_only=True)</span><br><span class="line">    name = CharField(allow_blank=True, max_length=100, required=False)</span><br><span class="line">    owner = PrimaryKeyRelatedField(queryset=User.objects.all())</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><p>为了理解各种类型的关系字段, 我们首先建立几个模型, 用以在我们的示例代码中使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Album</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    album_name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    artist = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    album = models.ForeignKey(Album, related_name=<span class="string">'tracks'</span>, on_delete=models.CASCADE)</span><br><span class="line">    order = models.IntegerField()</span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    duration = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        unique_together = (<span class="string">'album'</span>, <span class="string">'order'</span>)</span><br><span class="line">        ordering = [<span class="string">'order'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__unicode__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%d: %s'</span> % (self.order, self.title)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="StringRelatedField"><a href="#StringRelatedField" class="headerlink" title="StringRelatedField"></a>StringRelatedField</h3><p>该字段会将外键指向的模型的<code>.__str__()</code>方法的返回值作为展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.StringRelatedField(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>该序列化器将数据序列化为如下格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Things We Lost In The Fire'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Low'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'1: Sunflower'</span>, </span><br><span class="line">        <span class="string">'2: Whitetail'</span>, </span><br><span class="line">        <span class="string">'3: Dinosaur Act'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该字段固定为<code>只读</code>字段</p>
<p>参数:</p>
<p><code>many</code>参数, 如果是*对多字段, 就必须将<code>many</code>设为<code>True</code></p>
<hr>
<h3 id="PrimaryKeyRelatedField"><a href="#PrimaryKeyRelatedField" class="headerlink" title="PrimaryKeyRelatedField"></a>PrimaryKeyRelatedField</h3><p>序列化结果为外模型的主键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.PrimaryKeyRelatedField(many=<span class="literal">True</span>, read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>该字段为读写字段, 可以使用read_only标志来更改为只读.</p>
<p>参数</p>
<p><code>queryset</code>: 用指定一个查询集, 传入(序列化或者反序列化时)时作为验证该字段接收到的值是否合法的范围, </p>
<p><code>many</code>: 对于一个’X对多’字段来说, <code>many</code>必须设为<code>True</code>才能使其接收多个对象(many参数用于关系字段或本身是一个序列器的字段)</p>
<p><code>allow_null</code>: 指定<code>None</code>值是否是合法的输入, 默认为<code>False</code></p>
<p><code>pk_field</code>: 指定一个字段以控制主键值的序列化/反序列化, 例如<code>pk_field = UUIDField(format =&#39;hex&#39;)</code>会将UUID主键序列化为其紧凑的十六进制表示. </p>
<hr>
<h3 id="HyperlinkedRelatedField"><a href="#HyperlinkedRelatedField" class="headerlink" title="HyperlinkedRelatedField"></a>HyperlinkedRelatedField</h3><p>对外模型的序列化结果为指向该外模型detail页面的超链接.</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.HyperlinkedRelatedField(</span><br><span class="line">        many=<span class="literal">True</span>, </span><br><span class="line">        read_only=<span class="literal">True</span>, </span><br><span class="line">        view_name=<span class="string">'track-detail'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Graceland'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Paul Simon'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'http://www.example.com/api/tracks/45/'</span>, </span><br><span class="line">        <span class="string">'http://www.example.com/api/tracks/46/'</span>, </span><br><span class="line">        <span class="string">'http://www.example.com/api/tracks/47/'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认为读写字段, 可以使用read_only标志来更改</p>
<p><code>view_name</code> 必需参数, 指定关联目标的api-view, 如果使用<code>Router</code>来注册, 则为<code>&lt;modelname&gt;-detail</code><br><code>queryset</code> 用以校验输入是否合法的查询集, 如果不设定参数, 则必须置<code>read_only</code>=<code>True</code><br><code>lookup_field</code> 用以检索的关联目标的字段, 应该对应于引用视图上的URL关键字参数, 默认为<code>pk</code><br><code>lookup_url_kwarg</code> 在url conf中定义的关键字参数名, 默认使用与<code>lookup_field</code>相同的值<br><code>format</code> 如果使用格式后缀, 超链接字段将会为目标模型的url使用同样的后缀, 除非重写<code>format</code>参数</p>
<p>注: 写操作时传入的外键字段值是目标对象的detial的超链接.</p>
<hr>
<h3 id="SlugRelatedField"><a href="#SlugRelatedField" class="headerlink" title="SlugRelatedField"></a>SlugRelatedField</h3><p>使用外模型的某个字段来表示模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = serializers.SlugRelatedField(</span><br><span class="line">        many=<span class="literal">True</span>, </span><br><span class="line">        read_only=<span class="literal">True</span>, </span><br><span class="line">        slug_field=<span class="string">'title'</span></span><br><span class="line">     )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Dear John'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Loney Dear'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'Airport Surroundings'</span>, </span><br><span class="line">        <span class="string">'Everything Turns to You'</span>, </span><br><span class="line">        <span class="string">'I Was Only Going Out'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认为读写字段</p>
<p><code>slug_field</code> 指定使用外模型的哪个字段来表示该模型, 注意, <strong>该外模型字段必须受到<code>unique</code>约束</strong></p>
<hr>
<h3 id="HyperlinkedIdentityField"><a href="#HyperlinkedIdentityField" class="headerlink" title="HyperlinkedIdentityField"></a>HyperlinkedIdentityField</h3><p>HyperlinkedIdentityField用于自动生成<strong>当前模型</strong>的超链接, 指向<strong>当前模型</strong>的detial接口.</p>
<p>HyperlinkedModelSerializer中会使用该字段生成指向自身detail界面的<code>url</code>字段以取代<code>id</code>字段. </p>
<p>该字段会传入整个当前对象, 并将其中某个属性作为生成detail链接的字段, 通常用id作为<code>pk</code>.</p>
<p>所以:</p>
<ol>
<li>使用HyperlinkedIdentityField链接到当前正在序列化的对象.</li>
<li>使用HyperlinkedRelatedField链接到与序列化的对象相关的对象.</li>
</ol>
<p>因此, 对于一对一关系, 外键关系, 多对多关系以及基本上任何其他涉及关系的事物(在Django模型中)都应该使用<code>HyperlinkedRelatedField</code>. </p>
<p>使用<code>HyperlinkedRelatedField</code>的唯一时间是url字段, 可以在序列化程序中包含该字段以指向当前对象. </p>
<p>该字段为固化的<code>read_only</code>字段.</p>
<p>参数:</p>
<p><code>view_name</code>: 必需参数, 指定关联目标的api-view, 如果使用<code>Router</code>来注册, 则为<code>&lt;modelname&gt;-detail</code><br><code>lookup_field</code>: 默认为<code>pk</code>, 用于查找当前对象的主字段, 需要与url关键字(lookup_url_kwargs)保持一致.<br><code>lookup_url_kwarg</code>: 用于查找对象的url关键字, 需要与lookup_field保持一致.<br><code>format</code>: 需要为超链接添加的后缀.</p>
<p>请参阅<code>HyperlinkedSerializer</code>一节.</p>
<hr>
<h3 id="嵌套关系"><a href="#嵌套关系" class="headerlink" title="嵌套关系"></a>嵌套关系</h3><p>嵌套关系可以使用序列器作为字段来表示</p>
<p>如果该序列器对应的是*对多关系, 则必须设置<code>many</code>=<code>True</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Track</span><br><span class="line">        fields = (<span class="string">'order'</span>, <span class="string">'title'</span>, <span class="string">'duration'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = TrackSerializer(many=<span class="literal">True</span>, read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; album = Album.objects.create(album_name="The Grey Album", artist='Danger Mouse')</span><br><span class="line">&gt;&gt;&gt; Track.objects.create(album=album, order=1, title='Public Service Announcement', duration=245)</span><br><span class="line">&lt;Track: Track object&gt;</span><br><span class="line">&gt;&gt;&gt; Track.objects.create(album=album, order=2, title='What More Can I Say', duration=264)</span><br><span class="line">&lt;Track: Track object&gt;</span><br><span class="line">&gt;&gt;&gt; Track.objects.create(album=album, order=3, title='Encore', duration=159)</span><br><span class="line">&lt;Track: Track object&gt;</span><br><span class="line">&gt;&gt;&gt; serializer = AlbumSerializer(instance=album)</span><br><span class="line">&gt;&gt;&gt; serializer.data</span><br><span class="line">&#123;</span><br><span class="line">    'album_name': 'The Grey Album', </span><br><span class="line">    'artist': 'Danger Mouse', </span><br><span class="line">    'tracks': [</span><br><span class="line">        &#123;'order': 1, 'title': 'Public Service Announcement', 'duration': 245&#125;, </span><br><span class="line">        &#123;'order': 2, 'title': 'What More Can I Say', 'duration': 264&#125;, </span><br><span class="line">        &#123;'order': 3, 'title': 'Encore', 'duration': 159&#125;, </span><br><span class="line">        ...</span><br><span class="line">    ], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可写的嵌套序列化器"><a href="#可写的嵌套序列化器" class="headerlink" title="可写的嵌套序列化器"></a>可写的嵌套序列化器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Track</span><br><span class="line">        fields = (<span class="string">'order'</span>, <span class="string">'title'</span>, <span class="string">'duration'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = TrackSerializer(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = (<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        tracks_data = validated_data.pop(<span class="string">'tracks'</span>)</span><br><span class="line">        album = Album.objects.create(**validated_data)</span><br><span class="line">        <span class="keyword">for</span> track_data <span class="keyword">in</span> tracks_data:</span><br><span class="line">            Track.objects.create(album=album, **track_data)</span><br><span class="line">        <span class="keyword">return</span> album</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'The Grey Album'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Danger Mouse'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        &#123;<span class="string">'order'</span>: <span class="number">1</span>, <span class="string">'title'</span>: <span class="string">'Public Service Announcement'</span>, <span class="string">'duration'</span>: <span class="number">245</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'order'</span>: <span class="number">2</span>, <span class="string">'title'</span>: <span class="string">'What More Can I Say'</span>, <span class="string">'duration'</span>: <span class="number">264</span>&#125;, </span><br><span class="line">        &#123;<span class="string">'order'</span>: <span class="number">3</span>, <span class="string">'title'</span>: <span class="string">'Encore'</span>, <span class="string">'duration'</span>: <span class="number">159</span>&#125;, </span><br><span class="line">    ], </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer = AlbumSerializer(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.is_valid()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.save()</span><br><span class="line">&lt;Album: Album object&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义关系字段"><a href="#自定义关系字段" class="headerlink" title="自定义关系字段"></a>自定义关系字段</h3><p>子类化<code>RelatedField</code>并实现<code>.to_representation(self, value)</code>方法以实现只读关系字段, 如果要实现读写关系字段, 还要实现<code>.to_internal_value(self, data)</code>方法.</p>
<p>如果想要动态提供queryset用以限制外键的合法范围, 需要重写<code>.get_queryset(self)</code>方法以获得queryset而非在初始化该字段时通过<code>queryset</code>参数指定.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackListingField</span><span class="params">(serializers.RelatedField)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        duration = time.strftime(<span class="string">'%M:%S'</span>, time.gmtime(value.duration))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Track %d: %s (%s)'</span> % (value.order, value.name, duration)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    tracks = TrackListingField(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Album</span><br><span class="line">        fields = [<span class="string">'album_name'</span>, <span class="string">'artist'</span>, <span class="string">'tracks'</span>]</span><br></pre></td></tr></table></figure>

<p>序列化结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'album_name'</span>: <span class="string">'Sometimes I Wish We Were an Eagle'</span>, </span><br><span class="line">    <span class="string">'artist'</span>: <span class="string">'Bill Callahan'</span>, </span><br><span class="line">    <span class="string">'tracks'</span>: [</span><br><span class="line">        <span class="string">'Track 1: Jim Cain (04:39)'</span>, </span><br><span class="line">        <span class="string">'Track 2: Eid Ma Clack Shaw (04:19)'</span>, </span><br><span class="line">        <span class="string">'Track 3: The Wind and the Dove (04:34)'</span>, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义超链接字段"><a href="#自定义超链接字段" class="headerlink" title="自定义超链接字段"></a>自定义超链接字段</h3><p>子类化<code>HyperlinkedRelatedField</code>并考虑重写以下两个方法:</p>
<p><code>get_url(self, obj, view_name, request, format)</code></p>
<p>通过一个obj生成指向它detial的超链接, 如果<code>view_name</code>或<code>lookup_field</code>属性未提供, 或不匹配, 抛出一个<code>NoReverseMatch</code>异常.</p>
<p><code>get_object(self, view_name, view_args, view_kwargs)</code></p>
<p>通过超链接获取对应的实例对象, 如果想要实现可写字段, 则必须重写该方法以在反序列化过程中获得实例对象. 当无法获得对象时, 抛出<code>ObjectDoesNotExist</code>异常.</p>
<p>示例:</p>
<p>我们的URL中包含两个关键字参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/api/&lt;organization_slug&gt;/customers/&lt;customer_pk&gt;/</span><br></pre></td></tr></table></figure>

<p>只接收一个url关键字的默认实现无法序列化/反序列化该格式URL, 所以我们需要自定义超链接字段:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.reverse <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHyperlink</span><span class="params">(serializers.HyperlinkedRelatedField)</span>:</span></span><br><span class="line">    <span class="comment"># We define these as class attributes, so we don't need to pass them as arguments.</span></span><br><span class="line">    view_name = <span class="string">'customer-detail'</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(self, obj, view_name, request, format)</span>:</span></span><br><span class="line">        url_kwargs = &#123;</span><br><span class="line">            <span class="string">'organization_slug'</span>: obj.organization.slug, </span><br><span class="line">            <span class="string">'customer_pk'</span>: obj.pk</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse(view_name, kwargs=url_kwargs, request=request, format=format)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self, view_name, view_args, view_kwargs)</span>:</span></span><br><span class="line">        lookup_kwargs = &#123;</span><br><span class="line">           <span class="string">'organization__slug'</span>: view_kwargs[<span class="string">'organization_slug'</span>], </span><br><span class="line">           <span class="string">'pk'</span>: view_kwargs[<span class="string">'customer_pk'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> self.get_queryset().get(**lookup_kwargs)</span><br></pre></td></tr></table></figure>

<p>注意, 如果想要这种风格与通用视图兼容, 还需要在视图中重写<code>.get_object</code>方法, 以保证查找行为正确. </p>
<p>通常推荐使用平面风格的url, 但是嵌套风格的url在适度使用时也相当合理.</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr>
<h4 id="queryset参数"><a href="#queryset参数" class="headerlink" title="queryset参数"></a>queryset参数</h4><p>在初始化一个字段时传入的queryset用以验证传入的外键是否符合约束, 所以只有在<strong>可写</strong>字段中才需要该参数.</p>
<hr>
<h4 id="自定义HTML展示项"><a href="#自定义HTML展示项" class="headerlink" title="自定义HTML展示项"></a>自定义HTML展示项</h4><p>使用序列化器生成的表格中, 外键字段通常提供可选项来确保用户选择合法的字段值, 任何一个外模型的展示名都是其<code>__str__</code>函数的返回值, 但是可以通过重写<code>display_value</code>方法更改该值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackPrimaryKeyRelatedField</span><span class="params">(serializers.PrimaryKeyRelatedField)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display_value</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Track: %s'</span> % (instance.title)</span><br></pre></td></tr></table></figure>

<p><strong>选项截断</strong></p>
<p>在可选项过多时, 限制选项的截断数量.</p>
<p><code>html_cutoff</code>: 最大截断数量, 超过该数量的选项不会被展示, 默认为1000, 设为None意味着无限制.<br><code>html_cutoff_text</code> 如果截断, 截断处显示的文本. 默认为<code>&quot;More than {count} items…&quot;</code></p>
<p>可以通过<code>HTML_SELECT_CUTOFF</code>和<code>HTML_SELECT_CUTOFF_TEXT</code>设置项来进行更改.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">assigned_to = serializers.SlugRelatedField(</span><br><span class="line">   queryset=User.objects.all(),</span><br><span class="line">   slug_field=<span class="string">'username'</span>,</span><br><span class="line">   style=&#123;<span class="string">'base_template'</span>: <span class="string">'input.html'</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="反向关联字段"><a href="#反向关联字段" class="headerlink" title="反向关联字段"></a>反向关联字段</h4><p>反向关联字段并非定义在当前的模型中, 因此在使用ModelSerializer时不会自动包含该字段.</p>
<p>如果想要包含该字段, 直接将反向关联字段名添加至<code>Meta</code>的<code>fields</code>属性中即可.</p>
<p>模型定义:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    album = models.ForeignKey(Album, related_name=<span class="string">'tracks'</span>, on_delete=models.CASCADE)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>反向关联名为<code>tracks</code>, 所以直接包含该字段即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        fields = [<span class="string">'tracks'</span>, ...]</span><br></pre></td></tr></table></figure>

<p>如果未定义反向关联名, 使用默认的反向关联名<code>&lt;modelname&gt;_set</code>即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        fields = [<span class="string">'track_set'</span>, ...]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="通用关系字段"><a href="#通用关系字段" class="headerlink" title="通用关系字段"></a>通用关系字段</h4><p>如果使用了<a href="https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/" target="_blank" rel="noopener">通用关系字段</a>, 则需要自定义字段, 以明确目标字段应当如何被序列化.</p>
<p>例如, 给出如下Tag模型, 可以与其他任意模型建立通用关系.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Tags arbitrary model instances using a generic relation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See: https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    tag_name = models.SlugField()</span><br><span class="line">    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    tagged_object = GenericForeignKey(<span class="string">'content_type'</span>, <span class="string">'object_id'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.tag_name</span><br></pre></td></tr></table></figure>

<p>以下两个模型, 均与Tag联系. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bookmark</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A bookmark consists of a URL, and 0 or more descriptive tags.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = models.URLField()</span><br><span class="line">    tags = GenericRelation(TaggedItem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A note consists of some text, and 0 or more descriptive tags.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    text = models.CharField(max_length=<span class="number">1000</span>)</span><br><span class="line">    tags = GenericRelation(TaggedItem)</span><br></pre></td></tr></table></figure>

<p>通过自定义字段, 用以实例化添加标签的外模型实例, 使用类型来判断究竟该如何序列化外模型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedObjectRelatedField</span><span class="params">(serializers.RelatedField)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A custom field to use for the `tagged_object` generic relationship.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Serialize tagged objects to a simple textual representation.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, Bookmark):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Bookmark: '</span> + value.url</span><br><span class="line">        <span class="keyword">elif</span> isinstance(value, Note):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Note: '</span> + value.text</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected type of tagged object'</span>)</span><br></pre></td></tr></table></figure>

<p>如果需要嵌套序列化结果, 可以在内部使用另一个序列化器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Serialize bookmark instances using a bookmark serializer,</span></span><br><span class="line"><span class="string">    and note instances using a note serializer.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(value, Bookmark):</span><br><span class="line">        serializer = BookmarkSerializer(value)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(value, Note):</span><br><span class="line">        serializer = NoteSerializer(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Unexpected type of tagged object'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer.data</span><br></pre></td></tr></table></figure>

<p>注意, 在序列化包含<code>Generic Relation</code>字段(即反向关联的通用关系字段)的模型时, 常规的关系字段即可完成, 因为此时外模型的类型总是确定的.</p>
<hr>
<h3 id="通过中间模型关联的多对多-M2M-字段"><a href="#通过中间模型关联的多对多-M2M-字段" class="headerlink" title="通过中间模型关联的多对多(M2M)字段"></a>通过中间模型关联的多对多(M2M)字段</h3><p>默认情况下, 指向通过中间模型建立的多对多关系的序列化器关系字段通常是只读的. </p>
<p>如果要声明一个指向使用了中间模型的<code>ManyToManyField</code>字段的序列化器关系字段, 确保设置<code>read_only=True</code>.</p>
<p>如果想序列化包含在中间模型的额外字段的序列化结果, 可以将中间模型作为<a href="https://www.django-rest-framework.org/api-guide/serializers/#dealing-with-nested-objects" target="_blank" rel="noopener">嵌套对象</a>进行序列化. </p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>10.1 序列化器字段:非关系字段 Serializer Field</title>
    <url>/2019/10/03/10.1%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>序列化器字段进行从原始数据到python原生数据类型的转换, 验证输入值, 以及从其对应的Model实例中获取和设置值.</p>
<p>序列化器字段定义在<code>fields.py</code>中, 但为了方便起见, 应该使用<code>from rest_framework import serializers</code> 并用<code>serializers.&lt;FieldName&gt;</code>的形式来使用.</p>
<a id="more"></a>


<hr>
<h3 id="核心参数："><a href="#核心参数：" class="headerlink" title="核心参数："></a>核心参数：</h3><p>任何序列化器字段在构建时至少可以接收以下参数. 一些字段还可以接收额外的参数, 但以下参数所有字段都会接收. </p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>read_only</code></td>
<td>是否只读</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>write_only</code></td>
<td>是否只写</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>required</code></td>
<td>是否需要</td>
<td>Boolean</td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>default</code></td>
<td>字段默认值</td>
<td>灵活</td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>allow_null</code></td>
<td>是否允许空值</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>source</code></td>
<td>设定本字段数据来源</td>
<td>callable或attribute</td>
<td>本字段</td>
</tr>
<tr>
<td><code>validators</code></td>
<td>指定验证器</td>
<td>list of validator</td>
<td>None</td>
</tr>
<tr>
<td><code>error_message</code></td>
<td>验证出错信息</td>
<td>dict</td>
<td>None</td>
</tr>
<tr>
<td><code>label</code></td>
<td>用于html表格字段的描述</td>
<td>string</td>
<td>None</td>
</tr>
<tr>
<td><code>help_text</code></td>
<td>用于html本字段的帮助文本</td>
<td>string</td>
<td>None</td>
</tr>
<tr>
<td><code>initial</code></td>
<td>用于html本字段的初始值</td>
<td>callable或值</td>
<td>None</td>
</tr>
<tr>
<td><code>style</code></td>
<td>用于html本字段的style参数</td>
<td>dict</td>
<td>None</td>
</tr>
</tbody></table>
<hr>
<p>额外说明:</p>
<h4 id="read-only"><a href="#read-only" class="headerlink" title="read_only"></a><code>read_only</code></h4><p>该参数设为<code>True</code>的字段在<code>create()</code>和<code>update()</code>方法中不会使用</p>
<h4 id="write-only"><a href="#write-only" class="headerlink" title="write_only"></a><code>write_only</code></h4><p>该参数设为<code>True</code>时, 该字段不会被序列化, 但在<code>create()</code>和<code>update()</code>方法中需要该字段</p>
<h4 id="required"><a href="#required" class="headerlink" title="required"></a><code>required</code></h4><p>通常在反序列化过程中, 某个序列化器字段未被传入时, 会抛出错误, 如果某字段该参数设为<code>False</code>时, 则反序列化时没有该参数也不会报错. </p>
<p>设为<code>False</code>还会允许在<strong>序列化过程中</strong>也可以将该字段省略, 如果未传入该字段, 在输出中也就没有该字段. </p>
<h4 id="allow-null"><a href="#allow-null" class="headerlink" title="allow_null"></a><code>allow_null</code></h4><p>该参数设为<code>True</code>时, 允许该字段接收空值(<code>None</code>)作为合法值(序列化和反序列化过程均适用)</p>
<h4 id="default"><a href="#default" class="headerlink" title="default"></a><code>default</code></h4><p>如果该字段未接收到输入的时候, 为其提供一个默认值. </p>
<p>在<strong>部分更新</strong>时, <code>default</code>不会应用, 可指定为某个callable, 在每次使用<code>default</code>时都会进行计算</p>
<p>如果为函数, 该函数不应该接受任何参数. 如果是一个其他callable, 且该callable有<code>set_context</code>方法, 那么会在每次计算前调用, 并将该字段实例作为唯一参数, 与<code>validators</code>的工作方式相同</p>
<p>注意在设置默认值时, 意味着该字段无需被传入, 如果同时设定<code>default</code>和<code>required</code>=<code>True</code>则会报错</p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a><code>source</code></h4><p>用以填充本字段的属性名(通常为与本字段同名的属性, 但可以通过本参数进行额外指定), 可以为某个只接收<code>self</code>参数的方法, 例如<code>URLField(source=&#39;get_absolute_url&#39;)</code>, 或者某个<strong>圆点记法</strong>的属性值, 例如<code>EmailField(source=&#39;user.email&#39;)</code>.</p>
<p>如果设为<code>source</code>=<code>*</code>, 则意味着将正在序列化的整个对象传入该字段. </p>
<h4 id="validators"><a href="#validators" class="headerlink" title="validators"></a><code>validators</code></h4><p>验证器列表, 验证器为一个可以抛出<code>serializers.ValidationError</code>或者Django内置的<code>ValidationError</code>的函数. </p>
<h4 id="error-messages"><a href="#error-messages" class="headerlink" title="error_messages"></a><code>error_messages</code></h4><p>在验证失败后, 返回一个错误信息的字典, 格式为<code>{&#39;field_name&#39;:&#39;error_info&#39;}</code>.</p>
<h4 id="label"><a href="#label" class="headerlink" title="label"></a><code>label</code></h4><p>可能在html表格字段中使用的label标签的值</p>
<h4 id="help-text"><a href="#help-text" class="headerlink" title="help_text"></a><code>help_text</code></h4><p>可能在html表格字段中使用的帮助信息文本</p>
<h4 id="initial"><a href="#initial" class="headerlink" title="initial"></a><code>initial</code></h4><p>可能在html表格字段中使用的预填充值, 可以传入一个<code>callable</code>如同django的表格字段一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    day = serializers.DateField(initial=datetime.date.today)</span><br></pre></td></tr></table></figure>

<h4 id="style"><a href="#style" class="headerlink" title="style"></a><code>style</code></h4><p>可能在html表单字段中使用的内嵌样式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use &lt;input type="password"&gt; for the input.</span></span><br><span class="line">password = serializers.CharField(</span><br><span class="line">    style=&#123;<span class="string">'input_type'</span>: <span class="string">'password'</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a radio input instead of a select input.</span></span><br><span class="line">color_channel = serializers.ChoiceField(</span><br><span class="line">    choices=[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>], </span><br><span class="line">    style=&#123;<span class="string">'base_template'</span>: <span class="string">'radio.html'</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>查看<a href="https://q1mi.github.io/Django-REST-framework-documentation/topics/html-and-forms/" target="_blank" rel="noopener">HTML &amp; Forms</a>文档以获得更多信息. </p>
<hr>
<h2 id="序列化器字段"><a href="#序列化器字段" class="headerlink" title="序列化器字段"></a>序列化器字段</h2><h3 id="布尔型字段"><a href="#布尔型字段" class="headerlink" title="布尔型字段"></a>布尔型字段</h3><h4 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h4><p>布尔型字段, 等同于<code>django.db.models.fields.BooleanField</code></p>
<h4 id="NullBooleanField"><a href="#NullBooleanField" class="headerlink" title="NullBooleanField"></a>NullBooleanField</h4><p>允许空值的布尔型字段, 等同于<code>django.db.models.fields.NullBooleanField</code></p>
<hr>
<h3 id="字符串型字段"><a href="#字符串型字段" class="headerlink" title="字符串型字段"></a>字符串型字段</h3><h4 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h4><p>签名: <code>CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>max_length</code></td>
<td>最大长度</td>
<td>int</td>
<td>无</td>
</tr>
<tr>
<td><code>min_length</code></td>
<td>最小长度</td>
<td>int</td>
<td>无</td>
</tr>
<tr>
<td><code>allow_blank</code></td>
<td>允许空字符串</td>
<td>Boolean</td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>trim_whitespace</code></td>
<td>缩减空格</td>
<td>Boolean</td>
<td><code>True</code></td>
</tr>
</tbody></table>
<h4 id="EmailField"><a href="#EmailField" class="headerlink" title="EmailField"></a>EmailField</h4><p>签名: <code>EmailField(max_length=None, min_length=None, allow_blank=False)</code></p>
<p>自动附加一个邮件地址验证器, 等同于<code>django.db.models.fields.EmailField</code></p>
<h4 id="RegexField"><a href="#RegexField" class="headerlink" title="RegexField"></a>RegexField</h4><p>签名: <code>RegexField(regex, max_length=None, min_length=None, allow_blank=False)</code></p>
<p><code>regex</code>参数为一个代表匹配模式的字符串, 或者python的正则表达式对象</p>
<p>自动附加一个验证字段值是否匹配regex的验证器, 等同于<code>django.core.validators.RegexValidator</code></p>
<h4 id="SlugField"><a href="#SlugField" class="headerlink" title="SlugField"></a>SlugField</h4><p>签名: <code>SlugField(max_length=50, min_length=None, allow_blank=False)</code></p>
<h4 id="URLField"><a href="#URLField" class="headerlink" title="URLField"></a>URLField</h4><p><code>SlugField(max_length=50, min_length=None, allow_blank=False)</code></p>
<h4 id="UUIDField"><a href="#UUIDField" class="headerlink" title="UUIDField"></a>UUIDField</h4><p><code>URLField(max_length=200, min_length=None, allow_blank=False)</code></p>
<h4 id="FilePathField"><a href="#FilePathField" class="headerlink" title="FilePathField"></a>FilePathField</h4><p><code>FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)</code></p>
<h4 id="IPAddressField"><a href="#IPAddressField" class="headerlink" title="IPAddressField"></a>IPAddressField</h4><p><code>IPAddressField(protocol=&#39;both&#39;, unpack_ipv4=False, **options)</code></p>
<p><code>protocol</code>: 指定该地址需符合的协议, <code>ipv4</code>、<code>ipv6</code>或者<code>both</code>(两者均可)<br><code>unpack_ipv4</code>: 解压缩ipv4映射地址, 仅在<code>protocol</code>为<code>both</code>时可用, 默认关闭</p>
<hr>
<h3 id="数字型字段"><a href="#数字型字段" class="headerlink" title="数字型字段"></a>数字型字段</h3><h4 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h4><p><code>IntegerField(max_value=None, min_value=None)</code></p>
<h4 id="FloatField"><a href="#FloatField" class="headerlink" title="FloatField"></a>FloatField</h4><p><code>FloatField(max_value=None, min_value=None)</code></p>
<h4 id="DecimalField"><a href="#DecimalField" class="headerlink" title="DecimalField"></a>DecimalField</h4><p><code>DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)</code></p>
<hr>
<h3 id="时间和日期字段"><a href="#时间和日期字段" class="headerlink" title="时间和日期字段"></a>时间和日期字段</h3><h4 id="DateTimeField"><a href="#DateTimeField" class="headerlink" title="DateTimeField"></a>DateTimeField</h4><p><code>DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)</code></p>
<p><code>format</code>:输出时的格式, 默认为<code>iso-8601</code><br><code>input_formats</code>:输入时的格式列表</p>
<h4 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h4><p><code>DateField(format=api_settings.DATE_FORMAT, input_formats=None)</code></p>
<h4 id="TimeField"><a href="#TimeField" class="headerlink" title="TimeField"></a>TimeField</h4><p><code>TimeField(format=api_settings.TIME_FORMAT, input_formats=None)</code></p>
<h4 id="DurationField"><a href="#DurationField" class="headerlink" title="DurationField"></a>DurationField</h4><p><code>DurationField()</code></p>
<hr>
<h3 id="选择字段"><a href="#选择字段" class="headerlink" title="选择字段"></a>选择字段</h3><h4 id="ChoiceField"><a href="#ChoiceField" class="headerlink" title="ChoiceField"></a>ChoiceField</h4><p>该字段可以接受一个在该字段合法值列表中的值, 对应于mysql中的枚举类</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActApplicant</span><span class="params">(Model)</span>:</span></span><br><span class="line">    status_choices = [</span><br><span class="line">        (<span class="number">0</span>, <span class="string">'未通过'</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="string">'已通过'</span>), </span><br><span class="line">        (<span class="number">2</span>, <span class="string">'申请中'</span>)</span><br><span class="line">    ]</span><br><span class="line">    act = ForeignKey(Act, verbose_name=<span class="string">'活动'</span>, on_delete=CASCADE)</span><br><span class="line">    applicant = ForeignKey(Applicant, verbose_name=<span class="string">'申请人'</span>, on_delete=CASCADE)</span><br><span class="line">    apply_time = DateTimeField(<span class="string">'申请时间'</span>)</span><br><span class="line">    status = SmallIntegerField(<span class="string">'申请状态'</span>, choices=status_choices, default=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.act.title</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        unique_together = (<span class="string">'act'</span>, <span class="string">'applicant'</span>)</span><br><span class="line">        verbose_name = verbose_name_plural = <span class="string">'活动申请'</span></span><br></pre></td></tr></table></figure>

<p><code>ChoiceField(choices)</code></p>
<p><code>choices</code>: 该参数需传入一个合法值的列表或者元素为<code>(key, display_name)</code>格式元组的列表</p>
<h4 id="MultipleChoiceField-choices"><a href="#MultipleChoiceField-choices" class="headerlink" title="MultipleChoiceField(choices)"></a>MultipleChoiceField(choices)</h4><p>多选字段</p>
<p><code>MultipleChoiceField(choices)</code></p>
<hr>
<h3 id="文件上传字段"><a href="#文件上传字段" class="headerlink" title="文件上传字段"></a>文件上传字段</h3><h4 id="FileField"><a href="#FileField" class="headerlink" title="FileField"></a>FileField</h4><p><code>FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</code></p>
<p><code>max_length</code>: 文件名最大长度<br><code>allow_empty_file</code>: 是否允许空文件<br><code>use_url</code>: 是否使用url用于输出表示, 默认为<code>UPLOADED_FILES_USE_URL</code>的值, 默认为<code>True</code></p>
<h4 id="ImageField"><a href="#ImageField" class="headerlink" title="ImageField"></a>ImageField</h4><p><code>ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</code></p>
<hr>
<h3 id="组合字段"><a href="#组合字段" class="headerlink" title="组合字段"></a>组合字段</h3><p>组合字段指的是, 该字段中获得的值应该为一个汇集对象, 即其中包含多个元素. 且可以为其中的任意元素的数据格式进行校验. </p>
<h4 id="ListField"><a href="#ListField" class="headerlink" title="ListField"></a>ListField</h4><p><code>ListField(child=&lt;A_FIELD_INSTANCE&gt;, min_length=None, max_length=None)</code></p>
<p>该字段接收的数据类型为一个列表, 可以指定一个<code>child</code>参数, 该参数必须为另一个字段(另一个序列化器也是一个字段)的实例</p>
<p>会验证接收到的列表中的元素都符合参数<code>child</code>所指向的字段形式. </p>
<p>注意, 该字段接受的数据为一个<code>列表</code>. </p>
<h4 id="DictField"><a href="#DictField" class="headerlink" title="DictField"></a>DictField</h4><p><code>DictField(child=&lt;A_FIELD_INSTANCE&gt;, allow_empty=True)</code></p>
<p>同理, 该字段接收的是一个<code>字典</code></p>
<p>参数:</p>
<ol>
<li>child 一个应该用以校验其中单个键值对中的值的field实例, 如果未提供, 则值不会被校验.</li>
<li>allow_empty 是否允许接收一个空字典.</li>
</ol>
<p>例如, 创建一个校验值为字符串类型的字典的字段, 代码可能如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">document = DictField(child=CharField())</span><br></pre></td></tr></table></figure>

<p>或者直接重写DictField类并指定<code>child</code>属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DocumentField(DictField):</span><br><span class="line">    child = CharField()</span><br></pre></td></tr></table></figure>

<h4 id="JSONField"><a href="#JSONField" class="headerlink" title="JSONField"></a>JSONField</h4><p><code>JSONField(binary)</code></p>
<p>该字段接收的是一个<code>JSON</code>结构的数据, 并可以使用<code>child</code>参数来指定验证其数据合理性的字段实例</p>
<hr>
<h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><h4 id="ReadOnlyField"><a href="#ReadOnlyField" class="headerlink" title="ReadOnlyField"></a>ReadOnlyField</h4><p><code>ReadOnlyField()</code></p>
<p>不常用, 简单返回不加修改的数据值</p>
<h4 id="HiddenField"><a href="#HiddenField" class="headerlink" title="HiddenField"></a>HiddenField</h4><p>不接收用户的输入, 而使用default获得数据</p>
<p><code>HiddenField()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modified = serializers.HiddenField(default=timezone.now)</span><br></pre></td></tr></table></figure>

<p>如果需要基于某些预先提供的字段值运行某些验证, 但是不希望将所有这些字段公开给最终用户, 通常需要HiddenField类, </p>
<h4 id="ModelField"><a href="#ModelField" class="headerlink" title="ModelField"></a>ModelField</h4><p><code>ModelField(model_field=&lt;Django ModelField instance&gt;)</code></p>
<p>该字段绑定于一个Django的Model</p>
<h4 id="SerializerMethodField"><a href="#SerializerMethodField" class="headerlink" title="SerializerMethodField"></a>SerializerMethodField</h4><p><code>SerializerMethodField(method_name=None)</code></p>
<p>该字段接受的值为定义在该序列化器中的method的返回值, 使用<code>method_name</code>来指定具体是哪个方法, 如果不指定, 则尝试调用<code>get_&lt;filed_name&gt;</code>方法, 如果该方法不存在则报错. 该方法除了<code>self</code>之外, 仅接受一个参数<code>obj</code>, 即正在被序列化的对象本身. </p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.utils.timezone <span class="keyword">import</span> now</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    days_since_joined = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days_since_joined</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (now() - obj.date_joined).days</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h3><p>创建自定义序列化器字段需要子类化<code>Field</code>并重写以下方法中至少一个:</p>
<p><code>.to_representation()</code><br><code>.to_internal_value()</code></p>
<p>这两者用以进行从初始数据到原生python数据类型, 可序列化数据的转换. 基本数据类型包括数字, 字符串, 布尔型, <code>data</code>/<code>time</code>/<code>datetime</code>或<code>None</code>, 还可以是只包含基本数据类型元素的列表或者字典, 其他的类型可能也被支持, 取决于渲染器.</p>
<p>前者用于从初始数据到基本数据类型, 可序列化的数据的转换.<br>后者用于从原始数据到python内部基本类型的转换. 在校验失败时抛出<code>serializers.ValidationError</code></p>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="基本自定义字段"><a href="#基本自定义字段" class="headerlink" title="基本自定义字段"></a>基本自定义字段</h4><p>定义一个可用于序列化表示RGB颜色值类的字段. Model和Field定义如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A color represented in the RGB colorspace.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, red, green, blue)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span>(red &gt;= <span class="number">0</span> <span class="keyword">and</span> green &gt;= <span class="number">0</span> <span class="keyword">and</span> blue &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">assert</span>(red &lt; <span class="number">256</span> <span class="keyword">and</span> green &lt; <span class="number">256</span> <span class="keyword">and</span> blue &lt; <span class="number">256</span>)</span><br><span class="line">        self.red, self.green, self.blue = red, green, blue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Color objects are serialized into 'rgb(#, #, #)' notation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"rgb(%d, %d, %d)"</span> % (value.red, value.green, value.blue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        data = data.strip(<span class="string">'rgb('</span>).rstrip(<span class="string">')'</span>)</span><br><span class="line">        red, green, blue = [int(col) <span class="keyword">for</span> col <span class="keyword">in</span> data.split(<span class="string">', '</span>)]</span><br><span class="line">        <span class="keyword">return</span> Color(red, green, blue)</span><br></pre></td></tr></table></figure>

<p>默认序列化器字段会映射至Model的<code>同名</code>字段, 如果需要自定义该序列化器字段应该获得Model的非同名字段, 需要重写<code>.get_attribute()</code>和/或<code>.get_value()</code>.</p>
<p>例如, 创建一个字段用以序列化对象的类名:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassNameField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_attribute</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="comment"># We pass the object instance onto `to_representation`, </span></span><br><span class="line">        <span class="comment"># not just the field attribute.</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Serialize the value's class name.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> value.__class__.__name__</span><br></pre></td></tr></table></figure>

<h4 id="抛出验证错误"><a href="#抛出验证错误" class="headerlink" title="抛出验证错误"></a>抛出验证错误</h4><p>以上的ColorField并无进行任何数据验证, 为了宣示数据是否合法, 在<code>.to_internal_value()</code>方法中添加验证逻辑并在校验失败时抛出<code>serializers.ValidationError</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(data, str):</span><br><span class="line">        msg = <span class="string">'Incorrect type. Expected a string, but got %s'</span></span><br><span class="line">        <span class="keyword">raise</span> ValidationError(msg % type(data).__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r'^rgb\([0-9]+, [0-9]+, [0-9]+\)$'</span>, data):</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'Incorrect format. Expected `rgb(#, #, #)`.'</span>)</span><br><span class="line"></span><br><span class="line">    data = data.strip(<span class="string">'rgb('</span>).rstrip(<span class="string">')'</span>)</span><br><span class="line">    red, green, blue = [int(col) <span class="keyword">for</span> col <span class="keyword">in</span> data.split(<span class="string">', '</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> any([col &gt; <span class="number">255</span> <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> (red, green, blue)]):</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'Value out of range. Must be between 0 and 255.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Color(red, green, blue)</span><br></pre></td></tr></table></figure>

<p><code>.fail</code>方法是抛出<code>ValidationError</code>异常的快捷方式, 从<code>error_messages</code>字典中获取信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default_error_messages = &#123;</span><br><span class="line">    <span class="string">'incorrect_type'</span>: <span class="string">'Incorrect type. Expected a string, but got &#123;input_type&#125;'</span>, </span><br><span class="line">    <span class="string">'incorrect_format'</span>: <span class="string">'Incorrect format. Expected `rgb(#, #, #)`.'</span>, </span><br><span class="line">    <span class="string">'out_of_range'</span>: <span class="string">'Value out of range. Must be between 0 and 255.'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(data, str):</span><br><span class="line">        self.fail(<span class="string">'incorrect_type'</span>, input_type=type(data).__name__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r'^rgb\([0-9]+, [0-9]+, [0-9]+\)$'</span>, data):</span><br><span class="line">        self.fail(<span class="string">'incorrect_format'</span>)</span><br><span class="line"></span><br><span class="line">    data = data.strip(<span class="string">'rgb('</span>).rstrip(<span class="string">')'</span>)</span><br><span class="line">    red, green, blue = [int(col) <span class="keyword">for</span> col <span class="keyword">in</span> data.split(<span class="string">', '</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> any([col &gt; <span class="number">255</span> <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> (red, green, blue)]):</span><br><span class="line">        self.fail(<span class="string">'out_of_range'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Color(red, green, blue)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="使用source-quot-quot"><a href="#使用source-quot-quot" class="headerlink" title="使用source=&quot;*&quot;"></a>使用<code>source=&quot;*&quot;</code></h4><p>在实例化一个字段时, source参数可以为<code>*</code>意味着将整个对象传入该字段, 并在其内部使用该对象. </p>
<p>在自定义字段中可能需要读取不止一个字段的信息用于确定序列化结果, 因此可以使用该参数, 并自定义逻辑.</p>
<p>例如一个坐标模型定义如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataPoint</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    label = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    x_coordinate = models.SmallIntegerField()</span><br><span class="line">    y_coordinate = models.SmallIntegerField()</span><br></pre></td></tr></table></figure>

<p>通过<code>自定义字段</code>和<code>source=&quot;*&quot;</code>, 我们可以使用多个字段的信息来序列化一个字段, 并返回嵌套数据.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoordinateField</span><span class="params">(serializers.Field)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        ret = &#123;</span><br><span class="line">            <span class="string">"x"</span>: value.x_coordinate, </span><br><span class="line">            <span class="string">"y"</span>: value.y_coordinate</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        ret = &#123;</span><br><span class="line">            <span class="string">"x_coordinate"</span>: data[<span class="string">"x"</span>], </span><br><span class="line">            <span class="string">"y_coordinate"</span>: data[<span class="string">"y"</span>], </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataPointSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    coordinates = CoordinateField(source=<span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = DataPoint</span><br><span class="line">        fields = [<span class="string">'label'</span>, <span class="string">'coordinates'</span>]</span><br></pre></td></tr></table></figure>

<p>以上例子未提供验证处理. </p>
<p>这个例子中的关键点在于:</p>
<ol>
<li><code>to_presentation</code>必须被传递整个数据并从中获取序列化结果.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>instance = DataPoint(label=<span class="string">'Example'</span>, x_coordinate=<span class="number">1</span>, y_coordinate=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer = DataPointSerializer(instance)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer.data</span><br><span class="line">ReturnDict([(<span class="string">'label'</span>, <span class="string">'Example'</span>), (<span class="string">'coordinates'</span>, &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;)])</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>除非该字段被指定为只读, 否则<code>.to_internal_value()</code>必须从原始数据中还原映射关系以用以更新目标对象, 该方法所返回的<code>validated_data</code>用以更新实例对象, 因此该数据必须被拆解为符合原Model字段定义结构的数据.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">"label"</span>: <span class="string">"Second Example"</span>, </span><br><span class="line"><span class="meta">... </span>    <span class="string">"coordinates"</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">"x"</span>: <span class="number">3</span>, </span><br><span class="line"><span class="meta">... </span>        <span class="string">"y"</span>: <span class="number">4</span>, </span><br><span class="line"><span class="meta">... </span>    &#125;</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer = DataPointSerializer(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.is_valid()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.validated_data</span><br><span class="line">OrderedDict([(<span class="string">'label'</span>, <span class="string">'Second Example'</span>), </span><br><span class="line">             (<span class="string">'y_coordinate'</span>, <span class="number">4</span>), </span><br><span class="line">             (<span class="string">'x_coordinate'</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

<p>为了更加完备, 我们尝试使用嵌套序列化器完成相同的功能.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedCoordinateSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    x = serializers.IntegerField(source=<span class="string">'x_coordinate'</span>)</span><br><span class="line">    y = serializers.IntegerField(source=<span class="string">'y_coordinate'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataPointSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    coordinates = NestedCoordinateSerializer(source=<span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = DataPoint</span><br><span class="line">        fields = [<span class="string">'label'</span>, <span class="string">'coordinates'</span>]</span><br></pre></td></tr></table></figure>

<p>我们需要将一个作用于外层序列化器的对象整个传入内层序列化器中, 并由此生成嵌套的序列化结果.</p>
<p>序列化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer = DataPointSerializer(instance)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_serializer.data</span><br><span class="line">ReturnDict([(<span class="string">'label'</span>, <span class="string">'testing'</span>), </span><br><span class="line">            (<span class="string">'coordinates'</span>, OrderedDict([(<span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'y'</span>, <span class="number">2</span>)]))])</span><br></pre></td></tr></table></figure>

<p>反序列化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer = DataPointSerializer(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.is_valid()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>in_serializer.validated_data</span><br><span class="line">OrderedDict([(<span class="string">'label'</span>, <span class="string">'still testing'</span>), </span><br><span class="line">             (<span class="string">'x_coordinate'</span>, <span class="number">3</span>), </span><br><span class="line">             (<span class="string">'y_coordinate'</span>, <span class="number">4</span>)])</span><br></pre></td></tr></table></figure>

<p><em>注: 嵌套序列化器可以简单地反序列化嵌套数据, 只是在进行<code>create</code>和<code>update</code>时需要手写这些方法.</em></p>
<p>优点是自动获得了内建的验证器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_data = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">"label"</span>: <span class="string">"still testing"</span>, </span><br><span class="line"><span class="meta">... </span>    <span class="string">"coordinates"</span>: &#123;</span><br><span class="line"><span class="meta">... </span>        <span class="string">"x"</span>: <span class="string">'a'</span>, </span><br><span class="line"><span class="meta">... </span>        <span class="string">"y"</span>: <span class="string">'b'</span>, </span><br><span class="line"><span class="meta">... </span>    &#125;</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_serializer = DataPointSerializer(data=invalid_data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_serializer.is_valid()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invalid_serializer.errors</span><br><span class="line">ReturnDict([(<span class="string">'coordinates'</span>, </span><br><span class="line">             &#123;<span class="string">'x'</span>: [<span class="string">'A valid integer is required.'</span>], </span><br><span class="line">              <span class="string">'y'</span>: [<span class="string">'A valid integer is required.'</span>]&#125;)])</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ol>
<li>Serializer的<code>to_representation()</code>会调用每个Field的<code>to_representation</code>来完成序列化过程.</li>
<li>Serialzier继承自<code>Field</code>, 是rest_framework.fields中的<code>Field</code>, 并非Django的<code>Field</code></li>
<li>自定义字段相较于使用<code>SerializerMethodField</code>在于可以复用</li>
</ol>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>9.2 序列化器:内置序列化器 Serializer</title>
    <url>/2019/10/03/9.2%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<p>除了基本的<code>Serializer</code>类, rest-framework内置了几种序列化器类, 以供快速构建可用的序列化器, 或提供更基础的序列化器实现.</p>
<a id="more"></a>

<h3 id="ModelSerializer"><a href="#ModelSerializer" class="headerlink" title="ModelSerializer"></a>ModelSerializer</h3><p>ModelSerializer可以指定一个<code>model</code>属性, 指明根据哪个模型自动生成序列化器, 生成的内容包括</p>
<ol>
<li>自动生成与模型相对应的一组字段。</li>
<li>自动生成与模型字段的默认值和约束条件相对应的默认值和验证器.</li>
<li>简单地实现了对应该模型的<code>.create()</code>方法和<code>.update()</code>方法。</li>
</ol>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure>

<p>对于外约束字段, 默认使用<code>PrimaryKeyRelatedField</code>字段.(具体参见下一节<strong>序列化器关系字段</strong>)</p>
<p>注意, 根据Model生成字段时, <strong>不包括</strong>反向关联字段, 因为该字段并没有定义在当前模型中. 如果有需要, 可以手动定义该字段(参见<strong>快速开始</strong>一节).</p>
<p>可以使用<code>repr</code>查看定义该序列化器的实际代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python manage.py shell</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> myapp.serializers <span class="keyword">import</span> AccountSerializer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer = AccountSerializer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(serializer))</span><br><span class="line">AccountSerializer():</span><br><span class="line">    id = IntegerField(label=<span class="string">'ID'</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    name = CharField(allow_blank=<span class="literal">True</span>, max_length=<span class="number">100</span>, required=<span class="literal">False</span>)</span><br><span class="line">    owner = PrimaryKeyRelatedField(queryset=User.objects.all())</span><br></pre></td></tr></table></figure>

<h4 id="指定要包含的字段"><a href="#指定要包含的字段" class="headerlink" title="指定要包含的字段"></a>指定要包含的字段</h4><p>序列化器可能只需要包含模型的部分字段. 可通过以下方式指定:</p>
<ol>
<li>使用内部类<code>Meta</code>的<code>fields</code>属性指定一个字符串列表, 以指明需要包含的Model字段.</li>
<li>使用内部类<code>Meta</code>的<code>exclude</code>属性指定一个字符串列表, 以指明不需要包含的Model字段.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>)</span><br><span class="line">        <span class="comment">#exclude = ('users',)</span></span><br></pre></td></tr></table></figure>

<p> <code>fileds</code>属性可以设定为一个特殊值<code>__all__</code>, 代表包含该模型的所有字段.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = <span class="string">'__all__'</span></span><br></pre></td></tr></table></figure>

<p>注: 必须提供<code>fields</code>或<code>exclude</code>中的一个.</p>
<hr>
<h4 id="包含额外的字段和重写某些字段"><a href="#包含额外的字段和重写某些字段" class="headerlink" title="包含额外的字段和重写某些字段"></a>包含额外的字段和重写某些字段</h4><p>使用ModelSerializer仍然可以添加自定义字段或重写默认的字段，与在Serializer类一样直接声明即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    url = serializers.CharField(source=<span class="string">'get_absolute_url'</span>, read_only=<span class="literal">True</span>)</span><br><span class="line">    groups = serializers.PrimaryKeyRelatedField(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="指明只读字段"><a href="#指明只读字段" class="headerlink" title="指明只读字段"></a>指明只读字段</h4><p>在显式定义字段时, 直接传入<code>read_only=True</code>即可将该字段指为只读字段, </p>
<p>但ModelSerializer的模型相关字段是自动生成的, 因此无法直接修改定义字段的代码.</p>
<p>可以通过内部类<code>Meta</code>的<code>read_only_fields</code>属性指明一个字符串列表, 其中包含的所有字段被指定为<strong>只读</strong>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>]</span><br><span class="line">        read_only_fields = [<span class="string">'account_name'</span>]</span><br></pre></td></tr></table></figure>

<p>注: 如果声明一个嵌套序列化器字段并期望其只读, 必须在定义该字段时传入<code>read_only=True</code>, 将该字段包含在<code>read_only_fields</code>列表中无效, 原因不明.</p>
<p>只读字段指的是不允许用户传入的字段, 如果这些字段在存储时是必须的, 通常由内部指定:</p>
<ol>
<li>在存储过程中为<code>.save()</code>方法传入对应于只读字段的额外关键字参数, 参见9.1.</li>
<li>为其指定默认值, 只读字段的默认值在存储时自动被应用.</li>
</ol>
<p>另外, 如果一个只读字段要参与验证, 例如<code>unique_together</code>验证, 则必须为其指定默认值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = serializers.PrimaryKeyRelatedField(read_only=<span class="literal">True</span>, default=serializers.CurrentUserDefault())</span><br></pre></td></tr></table></figure>

<p><code>CurrentUserDefault</code>具体参见<strong>验证器</strong>一节的<strong>进阶默认值使用</strong>部分.</p>
<hr>
<h4 id="添加额外的参数"><a href="#添加额外的参数" class="headerlink" title="添加额外的参数"></a>添加额外的参数</h4><p>如上所述, 为ModelSerializer自动生成的字段进行部分修改较为不方便. </p>
<p>如果需要修改的内容过多, 可以直接重写该字段以覆盖自动生成的字段.</p>
<p>如果仅需要少量修改, 则可以通过内部类<code>Meta</code>的<code>extra_kwargs</code>属性为各个字段添加额外的关键字参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>)</span><br><span class="line">        extra_kwargs = &#123;<span class="string">'password'</span>: &#123;<span class="string">'write_only'</span>: <span class="literal">True</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        user = User(</span><br><span class="line">            email=validated_data[<span class="string">'email'</span>],</span><br><span class="line">            username=validated_data[<span class="string">'username'</span>]</span><br><span class="line">        )</span><br><span class="line">        user.set_password(validated_data[<span class="string">'password'</span>])</span><br><span class="line">        user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="声明嵌套序列化器"><a href="#声明嵌套序列化器" class="headerlink" title="声明嵌套序列化器"></a>声明嵌套序列化器</h4><p>直接通过内部类<code>Meta</code>的<code>depth</code>属性指明需要嵌套的深度, ModelSerializer会自动将所有外键字段替换为与外键模型相对应的ModelSerializer.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'account_name'</span>, <span class="string">'users'</span>, <span class="string">'created'</span>]</span><br><span class="line">        depth = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>使用这种方案生成的内层序列化器, 默认包含该模型的所有字段并且不包含任何额外字段. 如果想要自定义这些内容, 仍需手动嵌套.</p>
<h4 id="关系字段"><a href="#关系字段" class="headerlink" title="关系字段"></a>关系字段</h4><p>对于外键和多对多字段, ModelSerializer默认使用的是<code>PrimaryKeyRelatedField</code>字段.(具体参见下一节<strong>序列化器字段</strong>), 该字段会将外键字段序列化为相关外模型的<strong>主键</strong>(默认id字段)的值.</p>
<p>详情参阅下一节<strong>序列化器关系字段</strong></p>
<hr>
<h3 id="HyperlinkedModelSerializer"><a href="#HyperlinkedModelSerializer" class="headerlink" title="HyperlinkedModelSerializer"></a>HyperlinkedModelSerializer</h3><p>几乎与<code>ModelSerializer</code>一致, 唯一不同之处是对于id和外键的处理.</p>
<p><code>HyperlinkedModelSerializer</code>为对象外键使用的字段是<code>HyperlinkedRelatedField</code>, 序列化结果为指向该外模型对象detail的超链接.</p>
<p>默认不包含自身的id字段, 取而代之的是使用<code>HyperlinkedIdentityField</code>自动生成指向当前对象detial超链接的<code>url</code>字段.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://127.0.0.1:8000/api/books/1/"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Book"</span>,</span><br><span class="line">    <span class="string">"pages"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">"country"</span>: <span class="string">"http://127.0.0.1:8000/api/countries/1/"</span>,</span><br><span class="line">    <span class="string">"author"</span>: [</span><br><span class="line">        <span class="string">"http://127.0.0.1:8000/api/persons/1/"</span>,</span><br><span class="line">        <span class="string">"http://127.0.0.1:8000/api/persons/2/"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前, 自身/外模型需要存在detail接口, 也就是说, 此方案需要在打算构建一整套api时使用, 否则一个无效的url只会引起误解.</p>
<p>该url被期望是一个绝对url而非相对url, 因此需要为序列化器传入额外的关键字参数<code>request</code>, 以确保序列化器能使用当前请求信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = AccountSerializer(queryset, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="如何生成超链接"><a href="#如何生成超链接" class="headerlink" title="如何生成超链接"></a>如何生成超链接</h4><p>url需要指向正确的detail接口, 如何确定这个url?</p>
<p>在定义一个<code>HyperlinkedRelatedField</code>字段时, 需要指定以下四个参数</p>
<ol>
<li>view_name 指向的外模型的detail页面的pattern-name</li>
<li>lookup_field 用以传递给detail页面url用以获取对象的字段, 默认为<code>pk</code>, 通常需要与目标pattern中的url变量名一致.</li>
<li>lookup_field_kwargs  期望生成的url中与lookup_field所对应的url关键字变量名, 默认与上一参数保持一致值.</li>
<li>format 如果设定格式后缀, 目标url会附加该后缀.</li>
</ol>
<p>这四个参数作为依据生成指向对象detail页面的url.</p>
<p>示例:</p>
<p>数据模型如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># book/models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">	age = models.IntegerField(default=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">	population = models.IntegerField(default=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">	pages = models.IntegerField(default=<span class="number">100</span>)</span><br><span class="line">	author = models.ManyToManyField(<span class="string">'book.Person'</span>)</span><br><span class="line">	country = models.ForeignKey(<span class="string">'book.Country'</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>

<p>序列化器和视图如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># book/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets, serializers</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model = Book</span><br><span class="line">		fields = <span class="string">"__all__"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountrySerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model = Country</span><br><span class="line">		fields = <span class="string">"__all__"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonSerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model = Person</span><br><span class="line">		fields = <span class="string">"__all__"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">	queryset = Book.objects.all()</span><br><span class="line">	serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">	queryset = Person.objects.all()</span><br><span class="line">	serializer_class = PersonSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountryViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">	queryset = Country.objects.all()</span><br><span class="line">	serializer_class = CountrySerializer</span><br></pre></td></tr></table></figure>

<p>使用路由器注册如下, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># project/urls.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">from</span> book.views <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'books'</span>, BookViewSet)</span><br><span class="line">router.register(<span class="string">r'persons'</span>, PersonViewSet)</span><br><span class="line">router.register(<span class="string">r'countries'</span>, CountryViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'api/'</span>, include(router.urls))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在Router中注册时, 对于任意的viewset, 指定的basename会用以生成url-name(或称pattern-name), 该basename默认为viewset的<code>.querset</code>所指定的Model名.</p>
<p>所以在以上例子中, </p>
<ul>
<li>BookViewSet的base-name为<code>book</code>, 生成的book的接口名为 <code>book-detail</code>和<code>book-list</code></li>
<li>PersonViewSet的base-name为<code>person</code>, 生成的url的pattern-name为<code>person-detail</code>和<code>person-list</code></li>
<li>CountryViewSet的base-name为<code>country</code>, 生成的url的pattern-name为<code>country-detail</code>和<code>country-list</code></li>
</ul>
<p>BookSerializer获取到country和author的外模型名字分别为<code>Country</code>和<code>Person</code>, 生成字段时, 对应字段的<code>view_name</code>参数填充<code>country-detail</code>和<code>person-detail</code>, 然后在序列化过程中, 调用<code>reverse()</code>函数反查真正的url, 然后将外模型对应的<code>pk</code>填入, 获得目标url. </p>
<p><code>url</code>作为生成的超链接的默认字段名, 可以通过<code>URL_FIELD_NAME</code>设置项修改.</p>
<hr>
<h3 id="ListSerializer"><a href="#ListSerializer" class="headerlink" title="ListSerializer"></a>ListSerializer</h3><p>能序列化和一次验证多个对象，通常会作为序列器中的一个字段而不是直接使用作为主序列器。</p>
<p>你通常不需要直接使用ListSerializer，而是应该在实例化一个序列化器时简单地传递一个many=True参数, 实际返回的实例就不是<code>Serializer</code>而是<code>ListSerializer</code>, 后者使用多个对象实例化多个前者, 并将多个前者实例的序列化结果收集至自己的<code>.data</code>属性.</p>
<p>当一个序列化器在带有many=True选项被序列化时，将创建一个ListSerializer实例, 该序列化器类将成为ListSerializer类的子类。</p>
<p>默认多对多约束字段映射的是many=True的PrimaryKeyRelatedField，且allow_empty=True</p>
<hr>
<h4 id="自定义ListSerializer行为"><a href="#自定义ListSerializer行为" class="headerlink" title="自定义ListSerializer行为"></a>自定义ListSerializer行为</h4><p>通常一个ListSerializer会将传入的所有对象进行序列化以及反序列化, 以下情况可能需要自定义<code>ListSerializer</code>行为</p>
<ol>
<li>希望提供列表的特定验证，例如检查一个元素是否与列表中的另外一个元素冲突。</li>
<li>自定义多个对象的创建或更新行为。</li>
</ol>
<p>在一些嵌套序列化器中, 关于一对多, 多对多 外模型的过滤操作依赖于重写ListSerializer.</p>
<p>例如某些内容只是逻辑删除, 实际还存在于数据库中, 所以必须避免这些记录的序列化结果出现在最终的序列化结果中.</p>
<ol>
<li>子类化ListSerializer, 然后在<code>.to_representation()</code>方法中加入过滤逻辑, 根据逻辑决定是否调用<code>super().to_representation()</code></li>
<li>将序列化器的内部类<code>Meta</code>的<code>list_serializer_class</code>属性指向新的ListSerializer</li>
</ol>
<p>注意指定了新ListSerializer之后, 所有many=true的字段均会应用该新ListSerializer, 因此在完成过滤逻辑时应该考虑多个字段.</p>
<h5 id="自定义多个对象的创建"><a href="#自定义多个对象的创建" class="headerlink" title="自定义多个对象的创建"></a>自定义多个对象的创建</h5><p>默认情况下，多个对象的创建默认实现是简单地调用列表中每个对象的.create()方法，如果要自定义实现，那么你需要自定义当被传递many=True参数时使用的ListSerializer类中的.create()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListSerializer</span><span class="params">(serializers.ListSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        books = [Book(**item) <span class="keyword">for</span> item <span class="keyword">in</span> validated_data]</span><br><span class="line">        <span class="keyword">return</span> Book.objects.bulk_create(books)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        list_serializer_class = BookListSerializer</span><br></pre></td></tr></table></figure>

<h5 id="自定义多对象的更新"><a href="#自定义多对象的更新" class="headerlink" title="自定义多对象的更新"></a>自定义多对象的更新</h5><p>默认情况下，ListSerializer类不支持多对象的更新。这是因为插入和删除的预期行为是不明确的。</p>
<p>要支持多对象更新的话你需要自己明确地实现。编写多个对象更新的代码时要注意以下几点：</p>
<ol>
<li>如何确定数据列表中的每个元素应该对应更新哪个实例？</li>
<li>如何处理插入？它们是无效的？还是创建新对象？</li>
<li>移除应该如何处理？它们是要删除对象还是删除关联关系？它们应该被忽略还是提示无效操作？</li>
<li>排序如何处理？改变两个元素的位置是否意味着任何状态改变或者应该被忽视？</li>
<li>你需要向实例序列化器中显式添加一个id字段. 默认隐式生成的id字段是read_only, 这会导致它在更新时被删除.一旦你明确地声明它，它将在列表序列化器的update方法中可用。</li>
</ol>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListSerializer</span><span class="params">(serializers.ListSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        <span class="comment"># Maps for id-&gt;instance and id-&gt;data item.</span></span><br><span class="line">        book_mapping = &#123;book.id: book <span class="keyword">for</span> book <span class="keyword">in</span> instance&#125;</span><br><span class="line">        data_mapping = &#123;item[<span class="string">'id'</span>]: item <span class="keyword">for</span> item <span class="keyword">in</span> validated_data&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Perform creations and updates.</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> book_id, data <span class="keyword">in</span> data_mapping.items():</span><br><span class="line">            book = book_mapping.get(book_id, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> book <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                ret.append(self.child.create(data))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret.append(self.child.update(book, data))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Perform deletions.</span></span><br><span class="line">        <span class="keyword">for</span> book_id, book <span class="keyword">in</span> book_mapping.items():</span><br><span class="line">            <span class="keyword">if</span> book_id <span class="keyword">not</span> <span class="keyword">in</span> data_mapping:</span><br><span class="line">                book.delete()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="comment"># 我们需要使用主键来识别列表中的元素，</span></span><br><span class="line">    <span class="comment"># 所以在这里使用可写的字段，而不是默认的只读字段。</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        list_serializer_class = BookListSerializer</span><br></pre></td></tr></table></figure>

<h5 id="自定义ListSerializer初始化行为"><a href="#自定义ListSerializer初始化行为" class="headerlink" title="自定义ListSerializer初始化行为"></a>自定义ListSerializer初始化行为</h5><p>当一个many=True的序列化器进行初始化时, 我们需要决定哪个参数和关键字参数应该被传入用以实例化单个对象的<code>child</code>Serializer或作为<code>parent</code>的ListSerializer的<code>__init__()</code>方法</p>
<p>默认的行为是<code>validateors</code>以及任何自定义关键字参数只传递给<code>child</code>, 除此之外的所有参数由两个类共有.</p>
<p>有可能需要定义当many=True时子类和父类应当使用那些类, 所以可以重写<code>many_init()</code>方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">many_init</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># Instantiate the child serializer.</span></span><br><span class="line">    kwargs[<span class="string">'child'</span>] = cls()</span><br><span class="line">    <span class="comment"># Instantiate the parent list serializer.</span></span><br><span class="line">    <span class="keyword">return</span> CustomListSerializer(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>注: 该方法最高定义在<code>BaseSerializer</code>中.</p>
<hr>
<h3 id="BaseSerializer"><a href="#BaseSerializer" class="headerlink" title="BaseSerializer"></a>BaseSerializer</h3><p>继承关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializerMetaclass</span><span class="params">(type)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSerializer</span><span class="params">(Field)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListSerializer</span><span class="params">(BaseSerializer)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializer</span><span class="params">(BaseSerializer, metaclass=SerializerMetaclass)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelSerializer</span><span class="params">(Serializer)</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HyperlinkedModelSerializer</span><span class="params">(ModelSerializer)</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>BaseSerializer</p>
<p>属性&amp;方法</p>
<p><code>.data</code><br><code>.is_valid()</code><br><code>.validated_data</code><br><code>.errors</code><br><code>.save()</code></p>
<p>以及四个可重写的方法, 用以实现额外功能.</p>
<p><code>.to_representation()</code> 序列化主函数.<br><code>.to_internal_value()</code> 反序列化主函数.<br><code>.create()</code> 存储函数.<br><code>.update()</code> 更新函数.</p>
<h4 id="实现只读BaseSerializer"><a href="#实现只读BaseSerializer" class="headerlink" title="实现只读BaseSerializer"></a>实现只读BaseSerializer</h4><p>Model定义如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighScore</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    created = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    player_name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    score = models.IntegerField()</span><br></pre></td></tr></table></figure>

<p>序列化器如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighScoreSerializer</span><span class="params">(serializers.BaseSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'score'</span>: obj.score,</span><br><span class="line">            <span class="string">'player_name'</span>: obj.player_name</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后用其序列化一个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">high_score</span><span class="params">(request, pk)</span>:</span></span><br><span class="line">    instance = HighScore.objects.get(pk=pk)</span><br><span class="line">    serializer = HighScoreSerializer(instance)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>或是序列化多个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_high_scores</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = HighScore.objects.order_by(<span class="string">'-score'</span>)</span><br><span class="line">    serializer = HighScoreSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<h4 id="实现可读可写的BaseSerializer"><a href="#实现可读可写的BaseSerializer" class="headerlink" title="实现可读可写的BaseSerializer"></a>实现可读可写的BaseSerializer</h4><p>那么,我们还必须实现<code>.to_internal_value()</code>方法, 该方法返回经验证的数据用以构建对象实例, 并在验证失败时抛出<code>serializers.ValidationError</code>异常.</p>
<p>一旦实现<code>.to_internal_value()</code>方法, 我们就可以使用<code>is_valid()</code>方法, 以及<code>validated_data</code>和<code>errors</code>属性.</p>
<p>如果还想支持存储操作, 还必须要实现<code>created</code>和<code>update</code>其中之一或两者, 取决于需求.</p>
<p>以下是可读写的HighScoreSerializer, 上一个例子的增强版:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighScoreSerializer</span><span class="params">(serializers.BaseSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_internal_value</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        score = data.get(<span class="string">'score'</span>)</span><br><span class="line">        player_name = data.get(<span class="string">'player_name'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Perform the data validation.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> score:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(&#123;</span><br><span class="line">                <span class="string">'score'</span>: <span class="string">'This field is required.'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> player_name:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(&#123;</span><br><span class="line">                <span class="string">'player_name'</span>: <span class="string">'This field is required.'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">if</span> len(player_name) &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(&#123;</span><br><span class="line">                <span class="string">'player_name'</span>: <span class="string">'May not be more than 10 characters.'</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Return the validated values. This will be available as</span></span><br><span class="line">        <span class="comment"># the `.validated_data` property.</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'score'</span>: int(score),</span><br><span class="line">            <span class="string">'player_name'</span>: player_name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'score'</span>: obj.score,</span><br><span class="line">            <span class="string">'player_name'</span>: obj.player_name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HighScore.objects.create(**validated_data)</span><br></pre></td></tr></table></figure>

<h4 id="实现新的基本类"><a href="#实现新的基本类" class="headerlink" title="实现新的基本类"></a>实现新的基本类</h4><p>如果想要实现新的通用序列化器类, 为某些特定的序列化风格或者对某些存储后端进行适配, 继承<code>BaseSerializer</code>并重写其中某些方法.</p>
<p>以下为一个泛型序列化器的例子, 可以将任意复杂类型的对象解构为原始表达(即原生python数据类型).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectSerializer</span><span class="params">(serializers.BaseSerializer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A read-only serializer that coerces arbitrary complex objects</span></span><br><span class="line"><span class="string">    into primitive representations.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        output = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> attribute_name <span class="keyword">in</span> dir(obj):</span><br><span class="line">            attribute = getattr(obj, attribute_name)</span><br><span class="line">            <span class="keyword">if</span> attribute_name.startswith(<span class="string">'_'</span>):</span><br><span class="line">                <span class="comment"># Ignore private attributes.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">elif</span> hasattr(attribute, <span class="string">'__call__'</span>):</span><br><span class="line">                <span class="comment"># Ignore methods and other callables.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">elif</span> isinstance(attribute, (str, int, bool, float, type(<span class="literal">None</span>))):</span><br><span class="line">                <span class="comment"># Primitive types can be passed through unmodified.</span></span><br><span class="line">                output[attribute_name] = attribute</span><br><span class="line">            <span class="keyword">elif</span> isinstance(attribute, list):</span><br><span class="line">                <span class="comment"># Recursively deal with items in lists.</span></span><br><span class="line">                output[attribute_name] = [</span><br><span class="line">                    self.to_representation(item) <span class="keyword">for</span> item <span class="keyword">in</span> attribute</span><br><span class="line">                ]</span><br><span class="line">            <span class="keyword">elif</span> isinstance(attribute, dict):</span><br><span class="line">                <span class="comment"># Recursively deal with items in dictionaries.</span></span><br><span class="line">                output[attribute_name] = &#123;</span><br><span class="line">                    str(key): self.to_representation(value)</span><br><span class="line">                    <span class="keyword">for</span> key, value <span class="keyword">in</span> attribute.items()</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Force anything else to its string representation.</span></span><br><span class="line">                output[attribute_name] = str(attribute)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="进阶序列化器用法"><a href="#进阶序列化器用法" class="headerlink" title="进阶序列化器用法"></a>进阶序列化器用法</h3><h4 id="重写序列化和反序列化行为"><a href="#重写序列化和反序列化行为" class="headerlink" title="重写序列化和反序列化行为"></a>重写序列化和反序列化行为</h4><p>重写<code>.to_representation()</code> 或 <code>.to_internal_value()</code>方法即可更改序列化或反序列化过程</p>
<p><em>这里不得不提一句, 反序列化过程指的是从数据中获得原生python数据类型的<code>validated_data</code>为止.</em><br><em>至于重建对象并存储, 或是使用这些数据更新一个现有实例, 则纯属额外操作, 不能称之为<code>反序列化</code>的一环.</em></p>
<ol>
<li>增加新的行为</li>
<li>更改现有行为</li>
<li>提高某个频繁被访问且返回大量数据的端点的序列化表现.</li>
</ol>
<p>这两个方法的签名如下: </p>
<p><code>.to_representation(self, obj)</code></p>
<p>该方法接收一个实例, 并返回原生的表达式, 通常意味着python基本数据类型, 具体是什么类型可能需要考虑渲染器可以处理何种类型.</p>
<p>(通常就是Dict了.)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">    <span class="string">"""Convert `username` to lowercase."""</span></span><br><span class="line">    ret = super().to_representation(instance)</span><br><span class="line">    ret[<span class="string">'username'</span>] = ret[<span class="string">'username'</span>].lower()</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p><code>.to_internal_value(self, data)</code></p>
<p>接受未经验证的数据类型, 并返回验证过的原生python数据类型的数据.</p>
<p>如果调用<code>save()</code>方法的话, 返回值将被作为<code>validated_data</code>传入<code>.create()</code>和<code>.update()</code>方法中.</p>
<p>如果数据校验失败, 应当抛出<code>serializers.ValidationError(errors)</code>, 并将出错信息存储至<code>.error</code>属性中.</p>
<p>如果想实现对象级别的验证, 请重写<code>.validate()</code>方法.</p>
<p>传入的data通常为<code>request.data</code>, 所以具体的数据类型取决于API使用了何种解析器.</p>
<hr>
<h4 id="Serializer继承"><a href="#Serializer继承" class="headerlink" title="Serializer继承"></a>Serializer继承</h4><p>可以以提供通用方法或字段为目的定义一个序列化器, 然后供其他多个序列化器继承.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseSerializer</span><span class="params">(Serializer)</span>:</span></span><br><span class="line">    my_field = serializers.CharField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_my_field</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySerializer</span><span class="params">(MyBaseSerializer)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>需要注意的点是Meta并不会自动继承, 如果需要, 手动继承.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(MyBaseSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(MyBaseSerializer.Meta)</span>:</span></span><br><span class="line">        model = Account</span><br></pre></td></tr></table></figure>

<p>当然, 继承Meta并不推荐, 绝大多数时候应该显式声明Meta的属性.</p>
<p>注意: </p>
<ol>
<li>如果内部类Meta类继承自多个类，则只使用第一个类</li>
<li>通过在子类上将名称设置为None，可以显式删除从父类继承的Field</li>
</ol>
<hr>
<h4 id="动态改变序列化器字段"><a href="#动态改变序列化器字段" class="headerlink" title="动态改变序列化器字段"></a>动态改变序列化器字段</h4><p>一旦序列化器被实例化，该序列化器的字段字典就可以通过<code>.fields</code>属性来访问, 通过该属性可以动态改变序列化器.</p>
<p>示例代码:指定在初始化一个序列化器时可以指定哪些字段应当被使用的动态字段序列化器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicFieldsModelSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A ModelSerializer that takes an additional `fields` argument that</span></span><br><span class="line"><span class="string">    controls which fields should be displayed.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Don't pass the 'fields' arg up to the superclass</span></span><br><span class="line">        fields = kwargs.pop(<span class="string">'fields'</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Instantiate the superclass normally</span></span><br><span class="line">        super(DynamicFieldsModelSerializer, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fields <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Drop any fields that are not specified in the `fields` argument.</span></span><br><span class="line">            allowed = set(fields)</span><br><span class="line">            existing = set(self.fields.keys())</span><br><span class="line">            <span class="keyword">for</span> field_name <span class="keyword">in</span> existing - allowed:<span class="comment">#(集合减法)</span></span><br><span class="line">                self.fields.pop(field_name)</span><br></pre></td></tr></table></figure>

<p>然后就可以通过传参来控制序列器实例化时使用的字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class UserSerializer(DynamicFieldsModelSerializer):</span><br><span class="line">&gt;&gt;&gt;     class Meta:</span><br><span class="line">&gt;&gt;&gt;         model = User</span><br><span class="line">&gt;&gt;&gt;         fields = (<span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'email'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> UserSerializer(user)</span><br><span class="line">&#123;<span class="string">'id'</span>: 2, <span class="string">'username'</span>: <span class="string">'jonwatts'</span>, <span class="string">'email'</span>: <span class="string">'jon@example.com'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> UserSerializer(user, fields=(<span class="string">'id'</span>, <span class="string">'email'</span>))</span><br><span class="line">&#123;<span class="string">'id'</span>: 2, <span class="string">'email'</span>: <span class="string">'jon@example.com'</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="自定义默认字段"><a href="#自定义默认字段" class="headerlink" title="自定义默认字段"></a>自定义默认字段</h4><p>在2.0+版本中可用.<br>在3.0+版本中, 相关方法不复存在.</p>
<hr>
<h3 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h3><p>…</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>9.1 序列化器:数据验证 Serializer</title>
    <url>/2019/10/03/9.%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8/</url>
    <content><![CDATA[<p>序列化器将查询集(queryset)和模型实例(model instances)这样的复杂数据转换为原生python类型，以供渲染成JSON，XML等内容类型, 同时还提供反序列化功能，在验证了传入数据的合理性之后，允许将解析出的数据转换为复杂类型. </p>
<p>rest-framework中的serializers与Django的Form和ModelForm类非常像, Serializer类提供了通用方法来控制响应的输出，ModelSerializer类为创建用于处理模型实例和查询集的序列化程序提供了有用的快捷实现方式. </p>
<a id="more"></a>

<h3 id="声明序列化器"><a href="#声明序列化器" class="headerlink" title="声明序列化器"></a>声明序列化器</h3><p>首先创建一个Model, 以及一个该Model的对象.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email, content, created=None)</span>:</span></span><br><span class="line">        self.email = email</span><br><span class="line">        self.content = content</span><br><span class="line">        self.created = created <span class="keyword">or</span> datetime.now()</span><br><span class="line"></span><br><span class="line">comment = Comment(email=<span class="string">'leila@example.com'</span>, content=<span class="string">'foo bar'</span>)</span><br></pre></td></tr></table></figure>

<p>然后声明一个序列化器, 字段和该Model保持一致, 可以用来序列化和反序列化该对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="将一个对象序列化"><a href="#将一个对象序列化" class="headerlink" title="将一个对象序列化"></a>将一个对象序列化</h3><p>像使用Django的Form类一样使用Serializer.</p>
<p>实例化一个序列化器, 使用<code>instance</code>参数传入想要进行序列化的对象, 并在之后访问<code>.data</code>属性获得序列化结果.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(instance=comment)</span><br><span class="line">serializer.data</span><br><span class="line"><span class="comment"># &#123;'email': 'leila@example.com', 'content': 'foo bar', 'created': '2016-01-27T15:17:10.375877'&#125;</span></span><br></pre></td></tr></table></figure>

<p>序列化结果是原生的python类型, 接下来我们将其渲染为json类型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"></span><br><span class="line">json = JSONRenderer().render(serializer.data)</span><br><span class="line">json</span><br><span class="line"><span class="comment"># b'&#123;"email":"leila@example.com", "content":"foo bar", "created":"2016-01-27T15:17:10.375877"&#125;'</span></span><br></pre></td></tr></table></figure>

<p>当然, 在rest-framework中, 渲染器的选择和渲染过程通常是在视图处理函数返回Response后自动进行的, 我们只需要确保Response中包含的数据是合法的即可. 具体查阅<code>Renderer</code>一节.</p>
<hr>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化过程中, 序列化器接收数据, 并将其重新构建为复杂数据类型(即<strong>构造数据类型</strong>, 在python中就是<strong>对象</strong>, 在rest-framework中则通常专指<strong>Model的实例</strong>), 以便进一步操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的json指的是上面代码中生成的json</span></span><br><span class="line">stream = io.BytesIO(json)</span><br><span class="line">data = JSONParser().parse(stream)</span><br></pre></td></tr></table></figure>

<p>在传入数据后, serializer根据自己的字段, 自动验证其数据合法性, 并转换为原生python数据类型, 放入<code>validated_data</code>属性中.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(data=data)</span><br><span class="line">serializer.is_valid()</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">serializer.validated_data</span><br><span class="line"><span class="comment"># &#123;'content': 'foo bar', 'email': 'leila@example.com', 'created': datetime.datetime(2012, 08, 22, 16, 20, 09, 822243)&#125;</span></span><br></pre></td></tr></table></figure>

<p>之后使用<code>validated_data</code>属性进行操作, 例如更新对象的属性, 并存储入数据库.</p>
<hr>
<h3 id="存储实例对象"><a href="#存储实例对象" class="headerlink" title="存储实例对象"></a>存储实例对象</h3><p>为了将数据(<code>validated_data</code>)重构为对象, 我们需要实现create方法或者update方法, 或同时实现两者.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Comment(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        instance.email = validated_data.get(<span class="string">'email'</span>, instance.email)</span><br><span class="line">        instance.content = validated_data.get(<span class="string">'content'</span>, instance.content)</span><br><span class="line">        instance.created = validated_data.get(<span class="string">'created'</span>, instance.created)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>

<p>在实现了以上方法之后, 我们就可以使用serializer.save(), 该方法会自动调用create或update, 重构实例.</p>
<p>如果该实例是Django Model的某个实例, 需要将其保存至数据库, 代码则应该如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Comment.objects.create(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        instance.email = validated_data.get(<span class="string">'email'</span>, instance.email)</span><br><span class="line">        instance.content = validated_data.get(<span class="string">'content'</span>, instance.content)</span><br><span class="line">        instance.created = validated_data.get(<span class="string">'created'</span>, instance.created)</span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>

<p>这样, 当我们使用<code>.save()</code>方法时, 会使用<code>validated_data</code>创建一个Model实例并储存至数据库, 然后返回该实例.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">comment = serializer.save()</span><br></pre></td></tr></table></figure>

<p>调用<code>.save()</code>方法时, 可能创建一个新的实例(<code>create</code>), 或是更新一个现有实例(<code>update</code>), 取决于实例化序列化器时是否传入了一个现有实例(<code>instance</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .save()将会调用.create()创建一个新的实例</span></span><br><span class="line">serializer = CommentSerializer(data=data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># .save将会调用.update()更新一个现有的Comment实例</span></span><br><span class="line">serializer = CommentSerializer(instance=comment, data=data)</span><br></pre></td></tr></table></figure>

<p><code>create</code>和<code>update</code>的实现都是可选的, 你可以实现其中任意一个, 或者实现两者, 取决于实际需要.</p>
<hr>
<h4 id="为-save-方法传递额外关键字参数"><a href="#为-save-方法传递额外关键字参数" class="headerlink" title="为.save()方法传递额外关键字参数"></a>为<code>.save()</code>方法传递额外关键字参数</h4><p>在调用时可以为<code>.save</code>传递任意关键字参数, 这些关键字参数在保存/更新实例时, 都会被注入到实例中, 作为实例的属性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># view.py</span></span><br><span class="line">serializer.save(owner=request.user)</span><br></pre></td></tr></table></figure>

<p>所有的附加关键字参数将被包含至<code>validated_data</code>中, 在<code>.create()</code>和<code>.update()</code>被调用时使用.</p>
<hr>
<h4 id="直接重写-save"><a href="#直接重写-save" class="headerlink" title="直接重写.save()"></a>直接重写<code>.save()</code></h4><p>有时候, 单独实现create或者update意义不大, 例如我们想要在验证数据合法性之后将其使用email发送, 就应该直接重写<code>.save()</code>方法, 表意明确.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactForm</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    message = serializers.CharField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        email = self.validated_data[<span class="string">'email'</span>]</span><br><span class="line">        message = self.validated_data[<span class="string">'message'</span>]</span><br><span class="line">        send_email(<span class="keyword">from</span>=email, message=message)</span><br></pre></td></tr></table></figure>

<p>注意在这种情况下, 直接访问<code>serializer</code>的<code>validated_data</code>属性.</p>
<hr>
<h2 id="验证数据合法性"><a href="#验证数据合法性" class="headerlink" title="验证数据合法性"></a>验证数据合法性</h2><p>在访问<code>validated_data</code>属性或存储一个实例之前, 应该总是调用<code>is_valid</code>方法来验证数据是否合法, 如果验证未通过, <code>.errors</code>属性将会包含一个字典, 描述产生错误的字段和信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(data=&#123;<span class="string">'email'</span>: <span class="string">'foobar'</span>, <span class="string">'content'</span>: <span class="string">'baz'</span>&#125;)</span><br><span class="line">serializer.is_valid()</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">serializer.errors</span><br><span class="line"><span class="comment"># &#123;'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']&#125;</span></span><br></pre></td></tr></table></figure>

<p>字典中的每个键是字段名, 对应的值则是该字段的出错信息. 一个可能存在的特殊键是<code>non_field_errors</code>, 里面会存储一些通用的验证错误(不具体与某个字段相关).</p>
<p>该特殊键的键名可以通过<code>NON_FIELD_ERRORS_KEY</code>设置项进行修改.</p>
<hr>
<h4 id="在数据验证失败时抛出异常"><a href="#在数据验证失败时抛出异常" class="headerlink" title="在数据验证失败时抛出异常"></a>在数据验证失败时抛出异常</h4><p><code>is_valid</code>方法的<code>raise_exception</code>参数为<code>True</code>时, 当数据验证失败抛出<code>serializers.ValidationError</code>异常(而非存储出错信息).</p>
<p>该异常会由REST-framework提供的默认异常处理程序自动处理，默认情况下将返回<code>HTTP 400 Bad Request</code>响应.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="为字段添加自定义验证"><a href="#为字段添加自定义验证" class="headerlink" title="为字段添加自定义验证"></a>为字段添加自定义验证</h4><p>在定义序列化器时, 添加名为<code>.validate_&lt;field_name&gt;</code>的方法, 该方法会自动用于对应字段的数据验证.</p>
<p><code>.validate_&lt;field_name&gt;</code>方法仅接收一个参数<code>value</code>, 即该字段的数据, 返回值为经过验证(或进一步处理)的数据, 或在此之前就抛出<code>serializers.ValidationError</code>异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPostSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = serializers.CharField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_title</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Check that the blog post is about Django.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'django'</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">"Blog post is not about Django"</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>注意, 可选字段(required=False)如果没有获得数据, 该字段的验证也就不会进行.</p>
<hr>
<h4 id="为对象添加自定义验证"><a href="#为对象添加自定义验证" class="headerlink" title="为对象添加自定义验证."></a>为对象添加自定义验证.</h4><p>对象级别的验证, 即针对整个对象的验证, 与任何字段无关, 自定义<code>.validate()</code>方法来进行该验证.</p>
<p><code>validate</code>方法接收一个<code>data</code>参数, 即传入序列化器的所有数据.返回值为经过验证(处理)的数据, 或在此之前就抛出<code>serializers.ValidationError</code>异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    description = serializers.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    start = serializers.DateTimeField()</span><br><span class="line">    finish = serializers.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Check that the start is before the stop.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">'start'</span>] &gt; data[<span class="string">'finish'</span>]:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">"finish must occur after start"</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h4><p>对象级别的验证和字段级别的验证都是通过重写/添加特定方法名的方法在验证流程中调用，除此之外，我们还可以直接定义一个验证器函数，在定义字段时指定.</p>
<p>一些可复用的验证行为应当被写为验证器, 并酌情添加至字段或对象级别, 详情参考<strong>验证器</strong>(Validator)一节.</p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple_of_ten</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value % <span class="number">10</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Not a multiple of ten'</span>)</span><br></pre></td></tr></table></figure>

<p>为字段添加验证器, 在定义字段时添加.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameRecord</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    score = IntegerField(validators=[multiple_of_ten])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>为对象添加验证器, 在Meta属性中添加.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    name = serializers.CharField()</span><br><span class="line">    room_number = serializers.IntegerField(choices=[<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">201</span>])</span><br><span class="line">    date = serializers.DateField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># Each room only has one event per day.</span></span><br><span class="line">        validators = UniqueTogetherValidator(</span><br><span class="line">            queryset=Event.objects.all(), </span><br><span class="line">            fields=[<span class="string">'room_number'</span>, <span class="string">'date'</span>]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>验证器不需要返回初始数据, 仅需要在验证失败时抛出<code>serializers.ValidationError</code>异常. </p>
<p>每个字段/对象可包含多个验证器.</p>
<hr>
<h3 id="访问初始数据和实例"><a href="#访问初始数据和实例" class="headerlink" title="访问初始数据和实例"></a>访问初始数据和实例</h3><p>实例化序列化器之后, 使用<code>.instance</code>属性访问初始传入实例的属性, 使用<code>.initial_data</code>访问未经验证的初始数据. </p>
<hr>
<h3 id="部分更新"><a href="#部分更新" class="headerlink" title="部分更新"></a>部分更新</h3><p>在实例化序列化器时, 需要传入所有必填字段的值, 但在更新实例时仅需要部分字段的值, 此时需要将<code>partial</code>参数设为<code>True</code>来允许仅传入部分字段.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(instance=comment, data=&#123;<span class="string">'content'</span>: <span class="string">u'foo bar'</span>&#125;, partial=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="嵌套序列化器"><a href="#嵌套序列化器" class="headerlink" title="嵌套序列化器"></a>嵌套序列化器</h3><p>如果一个Model的某个字段指向的是另一个模型(例如外键，多对多字段), 则外模型本身也就是一个对象, 而非单纯的原生python数据类型.</p>
<p>如果对应某个外键字段的序列化器字段被指定为(另)一个序列化器，就形成了序列化器的嵌套，该外模型被指定的序列化器进行序列化, 且由此生成的序列化结果也是嵌套的. </p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    email = serializers.EmailField()</span><br><span class="line">    username = serializers.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    user = UserSerializer()</span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<p>示例序列化结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"content"</span>: <span class="string">"some content"</span>, </span><br><span class="line">	<span class="string">"created"</span>: <span class="string">"2019-09-30"</span>, </span><br><span class="line">	<span class="string">"user"</span>: &#123;</span><br><span class="line">		<span class="string">"email"</span>: <span class="string">"example@gmail.com"</span>, </span><br><span class="line">		<span class="string">"username"</span>: <span class="string">"username"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该外键字段允许为空, 则为其添加<code>reuqired=False</code>参数.</p>
<p>如果该外键字段为只读, 则为其添加<code>read_only=True</code>参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    user = UserSerializer(required=<span class="literal">False</span>)  <span class="comment"># 可能是匿名用户. </span></span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<p>如果该字段可能对应多个外模型, 例如一对多, 多对多字段, 则需要添加<code>many=True</code>参数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    user = UserSerializer(required=<span class="literal">False</span>)</span><br><span class="line">    edits = EditItemSerializer(many=<span class="literal">True</span>)  <span class="comment"># edit'项的嵌套列表</span></span><br><span class="line">    content = serializers.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    created = serializers.DateTimeField()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="可写的嵌套序列化器"><a href="#可写的嵌套序列化器" class="headerlink" title="可写的嵌套序列化器"></a>可写的嵌套序列化器</h3><p>嵌套序列化器一般不用来进行反序列化, 不过也可以实现这一点. 嵌套序列化器涉及到两个模型, 因此如果涉及到数据库相关操作, 我们需要在重写<code>update</code>和<code>create</code>方法时保存多个对象.</p>
<h4 id="验证数据合法性-1"><a href="#验证数据合法性-1" class="headerlink" title="验证数据合法性"></a>验证数据合法性</h4><p>嵌套的数据在验证合法性时, 如果未通过, 那么其错误信息也会是嵌套结构, 与数据保持一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = CommentSerializer(data=&#123;<span class="string">'user'</span>: &#123;<span class="string">'email'</span>: <span class="string">'foobar'</span>, <span class="string">'username'</span>: <span class="string">'doe'</span>&#125;, <span class="string">'content'</span>: <span class="string">'baz'</span>&#125;)</span><br><span class="line">serializer.is_valid()</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">serializer.errors</span><br><span class="line"><span class="comment"># &#123;'user': &#123;'email': ['Enter a valid e-mail address.']&#125;, 'created': ['This field is required.']&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用嵌套数据进行create"><a href="#使用嵌套数据进行create" class="headerlink" title="使用嵌套数据进行create"></a>使用嵌套数据进行<code>create</code></h4><p>从嵌套数据中取出(pop)内层的数据, 并分别处理.</p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    profile = ProfileSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = [<span class="string">'username'</span>, <span class="string">'email'</span>, <span class="string">'profile'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        profile_data = validated_data.pop(<span class="string">'profile'</span>)</span><br><span class="line">        user = User.objects.create(**validated_data)</span><br><span class="line">        Profile.objects.create(user=user, **profile_data)</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<h4 id="使用嵌套数据进行update"><a href="#使用嵌套数据进行update" class="headerlink" title="使用嵌套数据进行update"></a>使用嵌套数据进行<code>update</code></h4><p>在更新时处理好关系模型需要慎重考虑, 例如外模型部分的字段可能未提供, 或者为空值, 在这些情况下, 如何更新模型? 可选项:</p>
<ol>
<li>在数据库中将关联字段设置成NULL. </li>
<li>删除关联的实例. </li>
<li>忽略数据并保留这个实例. </li>
<li>抛出验证错误. </li>
</ol>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">   profile_data = validated_data.pop(<span class="string">'profile'</span>)</span><br><span class="line">   <span class="comment"># 当该字段不存在时会抛出DoesNotExist异常, 所以要么保证必须传入该字段, 要么处理该异常.</span></span><br><span class="line">   profile = instance.profile</span><br><span class="line"></span><br><span class="line">   instance.username = validated_data.get(<span class="string">'username'</span>, instance.username)</span><br><span class="line">   instance.email = validated_data.get(<span class="string">'email'</span>, instance.email)</span><br><span class="line">   instance.save()</span><br><span class="line"></span><br><span class="line">   profile.is_premium_member = profile_data.get(</span><br><span class="line">       <span class="string">'is_premium_member'</span>, </span><br><span class="line">       profile.is_premium_member</span><br><span class="line">   )</span><br><span class="line">   profile.has_support_contract = profile_data.get(</span><br><span class="line">       <span class="string">'has_support_contract'</span>, </span><br><span class="line">       profile.has_support_contract</span><br><span class="line">    )</span><br><span class="line">   profile.save()</span><br></pre></td></tr></table></figure>

<p>因为嵌套关系的创建和更新行为可能不明确，并且可能需要关联模型间的复杂依赖关系，REST framework 3 要求始终明确的定义这些方法, 而非依赖于默认行为.</p>
<p>注意: 在<code>ModelSerializer</code>中, 默认不提供对嵌套序列化器的可写支持.</p>
<hr>
<h3 id="处理多个对象"><a href="#处理多个对象" class="headerlink" title="处理多个对象"></a>处理多个对象</h3><p><strong>序列化多个对象</strong></p>
<p>在实例化一个序列化器时, 如果传入的实例是一个查询集而非单个对象, 则需要将<code>many</code>参数置为<code>True</code>, 以便序列化器依次作用于每个对象.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryset = Book.objects.all()</span><br><span class="line">serializer = BookSerializer(instance=queryset, many=<span class="literal">True</span>)</span><br><span class="line">serializer.data</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#     &#123;'id': 0, 'title': 'The electric kool-aid acid test', 'author': 'Tom Wolfe'&#125;, </span></span><br><span class="line"><span class="comment">#     &#123;'id': 1, 'title': 'If this is a man', 'author': 'Primo Levi'&#125;, </span></span><br><span class="line"><span class="comment">#     &#123;'id': 2, 'title': 'The wind-up bird chronicle', 'author': 'Haruki Murakami'&#125;</span></span><br><span class="line"><span class="comment"># ]</span></span><br></pre></td></tr></table></figure>

<h4 id="反序列化多个对象"><a href="#反序列化多个对象" class="headerlink" title="反序列化多个对象"></a>反序列化多个对象</h4><p>反序列化多个对象默认支持多个对象的创建，但是不支持多个对象的更新. 有关如何支持或自定义这些情况的更多信息，请查看<code>ListSerializer</code>部分. </p>
<hr>
<h3 id="额外的上下文"><a href="#额外的上下文" class="headerlink" title="额外的上下文"></a>额外的上下文</h3><p>在某些情况下，除了要序列化的对象之外，还需要为序列化程序提供额外的上下文. 一个常见的情况是，如果使用包含超链接关系字段的序列化器, 需要序列化器能够访问当前的请求以便正确生成完全限定的URL. </p>
<p>你可以在实例化序列化器的时候传递一个context参数来传递任意的附加上下文. 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serializer = AccountSerializer(account, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">serializer.data</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	'id': 6, </span></span><br><span class="line"><span class="string">	'owner': u'denvercoder9', </span></span><br><span class="line"><span class="string">	'created': datetime.datetime(2013, 2, 12, 09, 44, 56, 678870), </span></span><br><span class="line"><span class="string">	'details': 'http://example.com/accounts/6/details'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>这个上下文的字典可以在任何序列化器字段的逻辑中使用，例如<code>.to_representation()</code>方法中可以通过访问<code>self.context</code>属性获取上下文字典. </p>
<p>注: 在通用视图中, 自动传递给序列化器上下文中包括了<code>request</code>, <code>format</code>等信息, 因此可以直接使用, 详情查看<strong>通用视图</strong>一节.</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简而言之, 在rest-framework 序列化器的作用: </p>
<ol>
<li>序列化: 接受一个模型实例, 并将其序列化为原生的python数据类型, 例如字典, 以便可以简单地被渲染为json, xml或者其他内容类型.</li>
<li>反序列化: 接受一个json, xml或者其他内容类型的数据, 将其转为python原生数据类型, 以便进行一些相关操作, 例如创建实例并存储进数据库.</li>
</ol>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 渲染器 Renderers</title>
    <url>/2019/10/03/8.%20%E6%B8%B2%E6%9F%93%E5%99%A8/</url>
    <content><![CDATA[<p>处理函数中返回的<code>Response</code>只包含纯粹的数据, 之后在<code>finalize_response</code>中被进一步处理, 并在合适的时机渲染为真正的HTTP响应.</p>
<p>渲染器完成的就是将Response渲染为http响应的任务, 选择合适的渲染器需要根据<strong>内容协商</strong>的结果进行(内容协商主要依据<code>Accept</code>头和URL后缀, 具体参见内容协商一节)</p>
<p>例如, 一个在url中带有<code>.json</code>后缀的请求, 期望得到一个json格式的数据, 所以应该使用<code>JSONRenderer</code>返回纯json数据.</p>
<p>而通过浏览器进行访问时, <code>Accpet</code>头被浏览器自动设置为<code>text/html</code>, rest-framework会选择<code>BrowsableAPIRenderer</code>, 将数据放在<code>rest_framework/api.html</code>模板中进行渲染, 返回一个友好的完整HTML页面.</p>
<hr>
<a id="more"></a>

<h2 id="设置渲染器"><a href="#设置渲染器" class="headerlink" title="设置渲染器"></a>设置渲染器</h2><p>可用的渲染器类应当被设置为一个列表, 且从前向后, 优先级依次递减. rest-framework会根据内容协商结果来判断应当使用哪个渲染器.</p>
<p>全局设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>, </span><br><span class="line">        <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>, </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在视图中通过<code>renderer_classes</code>属性进行设置.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCountView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A view that returns the count of active users in JSON.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    renderer_classes = [JSONRenderer]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        user_count = User.objects.filter(active=<span class="literal">True</span>).count()</span><br><span class="line">        content = &#123;<span class="string">'user_count'</span>: user_count&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure>

<p>在设置渲染器类时, <strong>顺序</strong>是很关键的因素.</p>
<p>例如, 如果API提供JSON响应和适于浏览的API响应，则可能需要将JSONRenderer放在首位，以便向不指定Accept标头的客户端发送JSON响应, 因为这才是常规请求.<br>或者, 如果API提供常规页面和API响应, 那么需要将<code>TemplateHTMLRenderer</code>放在首位, 因为一些旧版本浏览器会发送不当的<code>Accept</code>, 服务端需要避免向其发送JSON数据. </p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h3 id="JSONRenderer"><a href="#JSONRenderer" class="headerlink" title="JSONRenderer"></a>JSONRenderer</h3><p>使用utf-8编码将请求的数据渲染为JSON，默认包括<code>unicode</code>字符，并使用紧凑格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"unicode black star"</span>:<span class="string">"★"</span>, <span class="string">"value"</span>:<span class="number">999</span>&#125;</span><br></pre></td></tr></table></figure>

<p>该渲染器可以接收<code>Accept</code>头的<code>indent</code>参数, 并在结果中响应该缩进请求.</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: application/json; indent=4</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"unicode black star"</span>: <span class="string">"★"</span>, </span><br><span class="line">    <span class="string">"value"</span>: <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>UNICODE_JSON</code>和<code>COMPACT_JSON</code>更改默认JSON编码样式</p>
<p>响应信息:</p>
<p>媒体类型: <strong>application/json</strong><br>格式: <strong>.json</strong><br>编码: <strong>None</strong></p>
<hr>
<h3 id="TemplateHTMLRenderer"><a href="#TemplateHTMLRenderer" class="headerlink" title="TemplateHTMLRenderer"></a>TemplateHTMLRenderer</h3><p>使用Django的标准模板将数据渲染成HTML. 在view中创建Response时需要指定<code>template_name</code>参数, 且传递给Response的数据无需序列化</p>
<p>因为只是将数据内容渲染进模板中, 与常规的Django的render操作相同</p>
<p>模板名称优先级</p>
<ol>
<li>创建Response时指定的<code>template_name</code>参数。</li>
<li>在view中定义的<code>.template_name</code>属性。</li>
<li>调用view.get_template_names()的返回结果。</li>
</ol>
<p>使用示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDetail</span><span class="params">(generics.RetrieveAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回给定用户的模板HTML表示的视图。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    renderer_classes = (TemplateHTMLRenderer, )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        self.object = self.get_object()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'user'</span>: self.object&#125;, template_name=<span class="string">'user_detail.html'</span>)</span><br></pre></td></tr></table></figure>

<p>可以使用TemplateHTMLRenderer来返回使用REST框架的常规HTML页面，或者从单个路径返回HTML和API响应。<br>如果打算构建使用<code>TemplateHTMLRenderer</code>和其他渲染类的网站，应该将<code>TemplateHTMLRenderer</code>列为<code>renderer_classes</code>列表中的第一个类，当接收到不正确格式的ACCEPT头的请求时，会默认使用该渲染器。</p>
<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.html</strong><br>编码: <strong>utf-8</strong></p>
<hr>
<h3 id="StaticHTMLRenderer"><a href="#StaticHTMLRenderer" class="headerlink" title="StaticHTMLRenderer"></a>StaticHTMLRenderer</h3><p>一个简单的渲染器，返回预渲染的HTML, 与其他渲染器不同，传递给Response的数据应该是表示要返回的响应的字符串(这些内容都不会被转义)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(('GET', ))</span></span><br><span class="line"><span class="meta">@renderer_classes((StaticHTMLRenderer, ))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_html_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    data = <span class="string">'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.html</strong><br>编码: <strong>utf-8</strong></p>
<hr>
<h3 id="BrowsableAPIRenderer"><a href="#BrowsableAPIRenderer" class="headerlink" title="BrowsableAPIRenderer"></a>BrowsableAPIRenderer</h3><p>将数据渲染成易于浏览的API界面, rest-framework专属, 开发时相当有用.</p>
<p><img src="https://www.django-rest-framework.org/img/quickstart.png" alt></p>
<p>这个渲染器根据其他渲染器的优先级使用最优先的渲染器，生成api数据，然后使用rest框架提供的模板，将数据渲染为在页面中包含api风格(数据)的响应</p>
<h4 id="自定义BrowsableAPIRenderer"><a href="#自定义BrowsableAPIRenderer" class="headerlink" title="自定义BrowsableAPIRenderer"></a>自定义BrowsableAPIRenderer</h4><p>默认情况下，在使用BrowsableAPIRenderer时, <strong>数据</strong>部分将使用<strong>其他</strong>渲染器中优先级最高的一个进行渲染, 然后再渲染进rest-framework提供的模板.</p>
<p>如果需要自定义此行为，例如使用HTML作为默认返回格式，但在可浏览的API中使用JSON，则可以通过重写get_default_renderer()方法来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomBrowsableAPIRenderer</span><span class="params">(BrowsableAPIRenderer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_default_renderer</span><span class="params">(self, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> JSONRenderer()</span><br></pre></td></tr></table></figure>

<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.api</strong><br>编码: <strong>utf-8</strong><br>模板: <strong>rest_framework/api.html</strong></p>
<hr>
<h3 id="AdminRenderer"><a href="#AdminRenderer" class="headerlink" title="AdminRenderer"></a>AdminRenderer</h3><p>将数据渲染给HTML以进行类似后台管理风格的展示：</p>
<p><img src="https://q1mi.github.io/Django-REST-framework-documentation/img/admin.png" alt></p>
<p>此渲染器适用于CRUD风格的Web API, 还提供用于管理数据的用户友好界面. 不支持嵌套序列器以及列表序列化器，因为html表单无法支持这些类型</p>
<p>注意: 只有当数据中存在正确配置的<code>URL_FIELD_NAME</code>属性(默认为指向detail页面的url)时，AdminRenderer才能够包含指向detail页面的链接。</p>
<p>对于HyperlinkedModelSerializer来说，该属性会被自动设置, 因此不会出现问题. 但是对于ModelSerializer 或者简单的Serializer类，则必须手动设置.</p>
<p>例如，我们使用模型get_absolute_url方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    url = serializers.CharField(source=<span class="string">'get_absolute_url'</span>, read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Account</span><br></pre></td></tr></table></figure>

<p>这里可能需要进一步描述: 数据的<code>属性</code>, 即对应渲染器中的<code>字段</code>, 因为渲染器会将数据渲染为 <code>{&quot;filed&quot;: &quot;value&quot;}</code></p>
<p>响应信息:</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>.admin</strong><br>编码: <strong>utf-8</strong><br>模板: <strong>rest_framework/admin.html</strong></p>
<hr>
<h3 id="HTMLFormRenderer"><a href="#HTMLFormRenderer" class="headerlink" title="HTMLFormRenderer"></a>HTMLFormRenderer</h3><p>将序列化程序返回的数据渲染为HTML表单。此渲染器的输出不包括封闭的<code>&lt;form&gt;</code>标签，隐藏的CSRF输入或任何提交按钮。</p>
<p>此渲染器不是直接使用，而是可以通过将序列化器实例传递给render_form模板标记来替代模板。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;% load rest_framework %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/submit-report/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;% render_form serializer %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Save"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如需详细了解，查阅 HTML &amp; Forms 文档。</p>
<p>媒体类型: <strong>text/html</strong><br>格式: <strong>form</strong><br>编码: <strong>utf-8</strong><br>模板: <strong>rest_framework/horizontal/form.html</strong></p>
<hr>
<h3 id="MultiPartRenderer"><a href="#MultiPartRenderer" class="headerlink" title="MultiPartRenderer"></a>MultiPartRenderer</h3><p>此渲染器用于渲染HTML multipart表单数据。 它不适合作为响应渲染器，而是用于创建测试请求，使用REST framework的 测试客户端和测试请求工厂。</p>
<p>媒体类型: <strong>multipart/form-data; boundary=BoUnDaRyStRiNg</strong><br>格式: <strong>.multipart</strong><br>编码: <strong>utf-8</strong></p>
<hr>
<h2 id="自定义渲染器"><a href="#自定义渲染器" class="headerlink" title="自定义渲染器"></a>自定义渲染器</h2><p>子类化BaseRenderer，设置<code>.media_type</code>和<code>.format</code>属性，并且实现 <code>.render(self, data, media_type=None, renderer_context=None)</code> 方法, 该方法应当返回一个字节<code>bytestring</code>，它将被用于HTTP响应的主体. </p>
<p>render方法参数解释:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
<th>default</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>视图处理函数所返回数据</td>
<td>无</td>
</tr>
<tr>
<td>media_type</td>
<td>如果提供，应为内容协商阶段确定的所接受的媒体类型。 该类型会优先根据客户端的Accept头来确定，因为Accept头的内容可能比渲染器的media_type属性更具体，例如可能包括媒体类型<strong>参数</strong>, 例如”application/json; nested=true”</td>
<td>None</td>
</tr>
<tr>
<td>renderer_context</td>
<td>如果提供，应当为视图提供的上下文字典，默认会包含如下关键字<code>view</code>, <code>request</code>, <code>response</code>, <code>args</code>, <code>kwargs</code></td>
<td>None</td>
</tr>
</tbody></table>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.encoding <span class="keyword">import</span> smart_unicode</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> renderers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainTextRenderer</span><span class="params">(renderers.BaseRenderer)</span>:</span></span><br><span class="line">    media_type = <span class="string">'text/plain'</span></span><br><span class="line">    format = <span class="string">'txt'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, data, media_type=None, renderer_context=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> data.encode(self.charset)</span><br></pre></td></tr></table></figure>

<h4 id="设定字符集"><a href="#设定字符集" class="headerlink" title="设定字符集"></a>设定字符集</h4><p>默认会使用urf-8编码，如果需要改变，则设置渲染器的<code>charset</code>属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainTextRenderer</span><span class="params">(renderers.BaseRenderer)</span>:</span></span><br><span class="line">    media_type = <span class="string">'text/plain'</span></span><br><span class="line">    format = <span class="string">'txt'</span></span><br><span class="line">    charset = <span class="string">'iso-8859-1'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, data, media_type=None, renderer_context=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> data.encode(self.charset)</span><br></pre></td></tr></table></figure>

<p>注意，如果一个渲染类返回了一个<code>unicode</code>字符串，则响应内容将被<code>Response</code>类强制转换成<code>bytestring</code>，渲染器上的设置的<code>charset</code>属性将用于确定编码。</p>
<p>如果渲染器返回一个<code>bytestring</code>表示原始的二进制内容，则应该设置字符集的值为<code>None</code>，确保响应请求头的<code>Content-Type</code>中不会设置<code>charset</code>值。</p>
<p>在某些情况下你可能还需要将<code>render_style</code>属性设置成<code>&#39;binary&#39;</code>。这么做也将确保可浏览的API不会尝试将二进制内容显示为字符串。</p>
<p><strong>图片渲染器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPEGRenderer</span><span class="params">(renderers.BaseRenderer)</span>:</span></span><br><span class="line">    media_type = <span class="string">'image/jpeg'</span></span><br><span class="line">    format = <span class="string">'jpg'</span></span><br><span class="line">    charset = <span class="literal">None</span></span><br><span class="line">    render_style = <span class="string">'binary'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, data, media_type=None, renderer_context=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="进阶渲染器使用"><a href="#进阶渲染器使用" class="headerlink" title="进阶渲染器使用"></a>进阶渲染器使用</h2><p>使用REST框架来做一些非常灵活的事，例如</p>
<ul>
<li>根据请求的媒体类型，从同一个路径既能提供单独的或者嵌套的表示。</li>
<li>提供常规HTML网页和来自同一路径的基于JSON的API响应。</li>
<li>为API客户端指定要使用的多种类型的HTML表示形式。</li>
<li>未指定渲染器的媒体类型，例如使用<code>media_type = &#39;image/*&#39;</code>，并使用<code>Accept</code>标头来更改响应的编码。</li>
</ul>
<hr>
<h3 id="根据媒体类型的不同行为"><a href="#根据媒体类型的不同行为" class="headerlink" title="根据媒体类型的不同行为"></a>根据媒体类型的不同行为</h3><p>在某些情况下，你可能希望视图根据所接受的媒体类型使用不同的序列化样式. </p>
<p>如果需要实现这个功能, 可以根据 request.accepted_renderer 在运行时确定已选择的渲染器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@api_view(('GET', ))</span></span><br><span class="line"><span class="meta">@renderer_classes((TemplateHTMLRenderer, JSONRenderer))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_users</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一个可以返回系统中用户的JSON或HTML表示的视图。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Users.objects.filter(active=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.accepted_renderer.format == <span class="string">'html'</span>:</span><br><span class="line">        <span class="comment"># TemplateHTMLRenderer 采用一个上下文的字典，</span></span><br><span class="line">        <span class="comment"># 并且额外需要一个 'template_name'。</span></span><br><span class="line">        <span class="comment"># 它不需要序列化。</span></span><br><span class="line">        data = &#123;<span class="string">'users'</span>: queryset&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(data, template_name=<span class="string">'list_users.html'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># JSONRenderer 需要正常的序列化数据。</span></span><br><span class="line">    serializer = UserSerializer(instance=queryset)</span><br><span class="line">    data = serializer.data</span><br><span class="line">    <span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="不明确的媒体类型"><a href="#不明确的媒体类型" class="headerlink" title="不明确的媒体类型"></a>不明确的媒体类型</h3><p>在某些情况下你可能希望渲染器提供一系列媒体类型。 在这种情况下，你可以通过为 media_type 设置诸如 image/* 或 <em>/</em>这样的值来指定应该响应的媒体类型。</p>
<p>如果你指定了渲染器的媒体类型，你应该确保在返回响应时使用 content_type 属性明确指定媒体类型。 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Response(data, content_type=<span class="string">'image/png'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义媒体类型"><a href="#自定义媒体类型" class="headerlink" title="自定义媒体类型"></a>自定义媒体类型</h3><p>许多Web API的目标，简单的具有超链接的<code>JSON</code>响应可能就已经足够了。如果你想完全拥抱RESTful设计和HATEOAS则需要更详细地考虑媒体类型的设计和使用。</p>
<p>用Roy Fielding的话来说，”REST API 应该花费所有的描述性努力来定义用于表示资源和驱动应用程序状态的媒体类型（们），或者为现有的标准媒体类型定义扩展关系名称和/或超文本启用标记。”。</p>
<p>有关自定义媒体类型的优秀示例，请参阅GitHub关于自定义 application/vnd.github+json 媒体类型的应用以及 Mike Amundsen的IANA认可的 application/vnd.collection+json JSON超媒体。</p>
<hr>
<h3 id="处理渲染异常-amp-HTML错误视图"><a href="#处理渲染异常-amp-HTML错误视图" class="headerlink" title="处理渲染异常&amp;HTML错误视图"></a>处理渲染异常&amp;HTML错误视图</h3><p>通常渲染器都具有相同的行为，无论它处理的是正常的响应还是由异常引起的响应, 如 <code>Http404</code>, <code>PermissionDenied</code>异常, 或者一个<code>APIException</code>的子类。</p>
<p>如果你正在使用 TemplateHTMLRenderer 或 StaticHTMLRenderer 时抛出了异常，行为略有不同。 并且反映 Django对错误视图的默认处理.</p>
<p>由HTML渲染器引发和处理的异常将尝试按照优先顺序使用以下方法之一进行渲染。</p>
<ol>
<li>加载并渲染一个名为 {status_code}.html的模板。</li>
<li>加载并渲染一个名为 api_exception.html的模板。</li>
<li>渲染HTTP状态码和文本，例如 “404 Not Found”。</li>
<li>使用一个包括status_code和details的 RequestContext 渲染。</li>
</ol>
<p>注意: 如果设置<code>DEBUG=True</code>，Django将展示它的标准回溯错误页面而不是渲染HTTP状态码和文本, 所以不会看到以上的HTML错误页面.</p>
<hr>
<h2 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h2><p>YAML<br>XML<br>JSONP<br>MessagePack<br>CSV<br>UltraJSON<br>CamelCase JSON<br>Pandas (CSV, Excel, PNG)<br>LaTeX</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 解析器 Parsers</title>
    <url>/2019/10/03/7.%20%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>resquest携带的数据可能是json格式，可能是一个完整的表单数据, 还可能是xml类型的数据，解析器的工作内容就是从中获取到清洁的数据, 并转换为python原生数据类型放入<code>request.data</code>属性中以供调用.</p>
<p>rest-framework提供了大量内建的解析器, 允许接受多种媒体类型的请求. </p>
<p>在开发客户端应用时, 发送请求时应该包含<code>Content-Type</code>头, 以便后端确定需要使用的解析. 如果未包含该HTTP头, 大多数客户端会将<code>Content-Type</code>设置为<code>application/x-www-form-urlencoded</code>, 可能与实际的内容格式不符.</p>
<p>例如, 在使用<code>ajax</code>发送<code>json</code>格式的数据时, 应该确保包含<code>contentType：&#39;application / json&#39;</code>设置.</p>
<a id="more"></a>

<hr>
<h3 id="设置解析器"><a href="#设置解析器" class="headerlink" title="设置解析器"></a>设置解析器</h3><p>可用的解析器类总是通过一个列表进行设置, 且优先级从前向后递减.</p>
<p>设置全局解析器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settigns.py</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>, </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用<code>parser_classes</code>属性为视图指定解析器类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A view that can accept POST requests with JSON content.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser_classes = [JSONParser]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'received data'</span>: request.data&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h3 id="JSONParser"><a href="#JSONParser" class="headerlink" title="JSONParser"></a>JSONParser</h3><p>.media_type: application/json</p>
<hr>
<h3 id="FormParser"><a href="#FormParser" class="headerlink" title="FormParser"></a>FormParser</h3><p>.media_type: application/x-www-form-urlencoded</p>
<p>request.data将被填充一个QueryDict的数据。</p>
<p>注: QueryDict 允许一个键对应多个值.</p>
<hr>
<h3 id="MultiPartParser"><a href="#MultiPartParser" class="headerlink" title="MultiPartParser"></a>MultiPartParser</h3><p>.media_type: multipart/form-data</p>
<p>解析 multipart HTML表单内容，支持文件上传. request.data 将被一个 QueryDict填充。</p>
<p>你通常会同时使用FormParser和MultiPartParser两者，以便完全支持HTML表单数据。</p>
<hr>
<h3 id="FileUploadParser"><a href="#FileUploadParser" class="headerlink" title="FileUploadParser"></a>FileUploadParser</h3><p>.media_type: <code>*/*</code></p>
<p>解析<strong>原始</strong>文件上传内容. request.data 属性将是有单个key<code>file</code>的包含上传文件的<code>字典</code>。</p>
<p>如果使用<code>FileUploadParser</code>的请求的url中包含名为<code>filename</code>的关键字参数, 该参数的值将被作为文件名.(参见示例代码)</p>
<p>如果api路径中不包含该关键字, 客户端必须在在<code>Content-Disposition</code>头中设置文件名, 例如 <code>Content-Disposition: attachment; filename=upload.jpg</code></p>
<p>注意: 该解析器仅当客户端将文件流作为原始数据请求时使用, 即请求的body中不包含任何的结构化数据, 而是文件本身(这就是为什么无法直接在body中包含文件名), FileUploadParser也仅仅会将请求的body视为文件本身.</p>
<p>在使用FileUploadParser时, 除了文件本身, 附加信息的传递需要通过请求头或者从url中获取. 理论上来说, 在上传文件方面, 它的效率可能更高.</p>
<p>只有构建一个纯粹的文件上传接口时才需要使用FileUploadParser, 基于web的文件上传都应当使用<code>MultiPartParser</code>.</p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUploadView</span><span class="params">(views.APIView)</span>:</span></span><br><span class="line">    parser_classes = [FileUploadParser]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, filename, format=None)</span>:</span></span><br><span class="line">        file_obj = request.data[<span class="string">'file'</span>]</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># do some stuff with uploaded file</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">return</span> Response(status=<span class="number">204</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    url(<span class="string">r'^upload/(?P&lt;filename&gt;[^/]+)$'</span>, FileUploadView.as_view())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他扩展解析器"><a href="#其他扩展解析器" class="headerlink" title="其他扩展解析器"></a>其他扩展解析器</h3><p>YAMLParser <code>djangorestframework-yaml</code>包提供<br>XMLParser <code>djangorestframework-xml</code>包提供<br>MessagePack <code>djangorestframework-msgpack</code>包提供<br>CamelCase JSON <code>djangorestframework-camel-case</code>包提供</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 路由器 Router</title>
    <url>/2019/10/03/6.%20%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h3><p><code>路由器</code>这个名称似乎存在歧义, 不过翻译为<code>路由</code>似乎也是不合适的, 毕竟是<code>Router</code>而不是<code>Route</code></p>
<p>rest-framework的<code>Router</code>所提供的是自动将一组url映射至特定处理函数的功能, 在上一节viewsets中已有提及.</p>
<a id="more"></a>


<p>简单示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"></span><br><span class="line">router = routers.SimpleRouter()</span><br><span class="line">router.register(<span class="string">r'users'</span>, UserViewSet)</span><br><span class="line">router.register(<span class="string">r'accounts'</span>, AccountViewSet)</span><br><span class="line">urlpatterns = router.urls</span><br></pre></td></tr></table></figure>

<p>实例化一个Router, 调用<code>register</code>方法, 然后将<code>Router.url</code>包含至urlpatterns.</p>
<p>register方法需要至少两个必要参数: </p>
<ul>
<li><code>prefix</code>, 该组路由的前缀.</li>
<li><code>viewset</code>, 改组路由映射的视图集.</li>
</ul>
<p>以及可能可选的参数</p>
<ul>
<li><code>base_name</code> 该组路由的url-name的基础部分, 如果设置了<code>.queryset</code>属性, 则为Model名.如果是通过<code>get_queryset</code>提供视图集, 则必须手动指定该参数.</li>
</ul>
<p>以上Router注册了两个视图集, 生成的 URL patterns 如下</p>
<p>URL pattern: ^users/$ Name: ‘user-list’<br>URL pattern: ^users/{pk}/$ Name: ‘user-detail’<br>URL pattern: ^accounts/$ Name: ‘account-list’<br>URL pattern: ^accounts/{pk}/$ Name: ‘account-detail’</p>
<p>使用<code>include</code>函数, 将生成的路由包含至现存的urlpatterns</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^forgot-password/$'</span>, ForgotPasswordFormView.as_view()), </span><br><span class="line">    url(<span class="string">r'^'</span>, include(router.urls)), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>还可以在使用<code>include</code>的时候添加命名空间(APP命名空间, 实例命名空间均可)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^forgot-password/$'</span>, ForgotPasswordFormView.as_view()), </span><br><span class="line">    url(<span class="string">r'^api/'</span>, include((router.urls, <span class="string">'app_name'</span>))), </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^forgot-password/$'</span>, ForgotPasswordFormView.as_view()), </span><br><span class="line">    url(<span class="string">r'^api/'</span>, include((router.urls, <span class="string">'app_name'</span>), namespace=<span class="string">'instance_name'</span>)), </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>查看Django的<a href="https://docs.djangoproject.com/en/stable/topics/http/urls/" target="_blank" rel="noopener">URL namespace docs</a>和<code>include</code><a href="https://docs.djangoproject.com/en/stable/ref/urls/#include" target="_blank" rel="noopener">API reference</a>获得更多细节.</p>
<hr>
<p>注意: 如果使用了命名空间和超链接序列化器, 需要确保<code>view_name</code>参数能正确地反映命名空间. 在以上例子中, 应当为<code>view_name=&#39;app_name:user-detail&#39;</code>以确保超链接关系字段能生成正确的超链接.</p>
<p>注意, view_name的默认值为<code>%(model_name)-detail</code>, 因此, 除非是Model命名冲突, 否则不应该使用命名空间.</p>
<hr>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h3 id="SimpleRouter"><a href="#SimpleRouter" class="headerlink" title="SimpleRouter"></a>SimpleRouter</h3><table border="1">
    <tr><th>URL Style</th><th>HTTP Method</th><th>Action</th><th>URL Name</th></tr>
    <tr><td rowspan="2">{prefix}/</td><td>GET</td><td>list</td><td rowspan="2">{basename}-list</td></tr>
    <tr><td>POST</td><td>create</td></tr>
    <tr><td rowspan="4">{prefix}/{lookup}/</td><td>GET</td><td>retrieve</td><td rowspan="4">{basename}-detail</td></tr>
    <tr><td>PUT</td><td>update</td></tr>
    <tr><td>PATCH</td><td>partial_update</td></tr>
    <tr><td>DELETE</td><td>destroy</td></tr>
    <tr><td>{prefix}/{methodname}/</td><td>GET, 或被`methods`参数声明的方法</td><td>@action(detail=False)装饰的方法</td><td>{basename}-{methodname}</td></tr>
    <tr><td>{prefix}/{lookup}/{methodname}/</td><td>GET, 或被`methods`参数声明的方法</td><td>@action(detail=True)装饰的方法</td><td>{basename}-{methodname}</td></tr>
</table>

<p>默认情况下，由SimpleRouter创建的URL将附加尾部斜杠。 在实例化路由器时，可以通过将trailing_slash参数设置为<code>False</code>来修改此行为, 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">router = SimpleRouter(trailing_slash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>尾部斜杠在Django中是常见的，但是在其他一些框架（如Rails）中默认不使用. 选择使用哪种风格在很大程度上是个人偏好问题，虽然一些javascript框架可能需要一个特定的路由风格。</p>
<p>路由器将匹配包含除斜杠和句点字符以外的任何字符的查找值。对于更严格（或更宽松）的查找模式，请在视图集上设置lookup_value_regex属性。例如，你可以将查找限制为有效的UUID：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModelViewSet</span><span class="params">(mixins.RetrieveModelMixin, viewsets.GenericViewSet)</span>:</span></span><br><span class="line">    lookup_field = <span class="string">'my_model_id'</span></span><br><span class="line">    lookup_value_regex = <span class="string">'[0-9a-f]&#123;32&#125;'</span></span><br></pre></td></tr></table></figure>

<h3 id="DefaultRouter"><a href="#DefaultRouter" class="headerlink" title="DefaultRouter"></a>DefaultRouter</h3><p>与SimpleRouter不同之处有两点:</p>
<ol>
<li>支持可选后缀以确定返回具体的页面形式，是带有html元素的页面，还是纯json</li>
<li>额外生成一个默认返回所有列表视图的超链接的API根视图 api-root</li>
</ol>
<table border="1">
    <tr><th>URL 样式</th><th>HTTP 方法</th><th>动作</th><th>URL 名称</th></tr>
    <tr><td>[.format]</td><td>GET</td><td>automatically generated root view</td><td>api-root</td></tr>
    <tr><td rowspan="2">{prefix}/[.format]</td><td>GET</td><td>list</td><td rowspan="2">{basename}-list</td></tr>
    <tr><td>POST</td><td>create</td></tr>
    <tr><td rowspan="4">{prefix}/{lookup}/[.format]</td><td>GET</td><td>retrieve</td><td rowspan="4">{basename}-detail</td></tr>
    <tr><td>PUT</td><td>update</td></tr>
    <tr><td>PATCH</td><td>partial_update</td></tr>
    <tr><td>DELETE</td><td>destroy</td></tr>
    <tr><td>{prefix}/{methodname}/[.format]</td><td>GET, or as specified by `methods` argument</td><td>`@list_route` decorated method</td><td>{basename}-{methodname}</td></tr>
    <tr><td>{prefix}/{lookup}/{methodname}/[.format]</td><td>GET, or as specified by `methods` argument</td><td>`@detail_route` decorated method</td><td>{basename}-{methodname}</td></tr>
</table>

<p>同样可以使用trailing_slash=False来取消url样式的尾端斜杠:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">router = DefaultRouter(trailing_slash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义Routers"><a href="#自定义Routers" class="headerlink" title="自定义Routers"></a>自定义Routers</h2><p>通常这个并不需要，不过仍然可以给出参数来定义特定要求的API网址，之所以自定义Router而不是直接为其指定url的原因是可以增加复用.</p>
<p>具体可参阅<a href="https://www.django-rest-framework.org/api-guide/routers/#custom-routers" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 视图集 viewsets</title>
    <url>/2019/10/03/5.%20%E8%A7%86%E5%9B%BE%E9%9B%86/</url>
    <content><![CDATA[<p>rest-framework 允许将一组相关逻辑的视图组合在同一个视图类中, 叫做<code>视图集</code>(viewset).</p>
<p>一个视图集是一个单纯的CBV, 只提供<code>行为</code>(action)例如<code>list</code>和<code>create</code>, 不提供任何处理函数(handler)例如<code>get</code>或<code>post</code>.</p>
<p>视图集的处理函数需要通过在as_view()方法中传入映射字典对各个处理函数和行为进行映射.</p>
<p>(注: viewset的as_view()方法已重写, 可以接收一个字典作为参数, 完成行为和处理方法之间的绑定)</p>
<p>当然, 通常我们使用Router对视图集进行注册. </p>
<a id="more"></a>

<p>例如定义一个视图集, 可以列出所有用户, 或取得其中任一个用户的信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404</span><br><span class="line"><span class="keyword">from</span> myapps.serializers <span class="keyword">import</span> UserSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A simple ViewSet for listing or retrieving users.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        queryset = User.objects.all()</span><br><span class="line">        serializer = UserSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        queryset = User.objects.all()</span><br><span class="line">        user = get_object_or_404(queryset, pk=pk)</span><br><span class="line">        serializer = UserSerializer(user)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>该视图集应当如下注册: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'/user/'</span>, UserViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>&#125;), name=<span class="string">'user-list'</span>), </span><br><span class="line">    path(<span class="string">'/user/&lt;pk&gt;'</span>, UserViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'retrieve'</span>&#125;), name=<span class="string">'user-detail'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>对于普通的viewset, 以上的绑定行为是非常模式化的, 所以通常使用<code>Router</code>完成绑定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> myapp.views <span class="keyword">import</span> UserViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"></span><br><span class="line">router = DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'users'</span>, UserViewSet, basename=<span class="string">'user'</span>)</span><br><span class="line">urlpatterns = router.urls</span><br></pre></td></tr></table></figure>

<p>与手动绑定的效果一致, 甚至还支持额外的路由, 详情可查看Router一节.</p>
<p>相较于自己写视图集, 通常使用已有的提供各种action的ModelViewSet更为合算. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset for viewing and editing user instances.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    queryset = User.objects.all()</span><br></pre></td></tr></table></figure>

<p>ViewSet相较于View有两个主要优势:</p>
<ol>
<li>重复的逻辑可以最大程度地复用, 例如上例中, 只需要定义一次queryset, 而在之前的UserViewSet中, 需要在每个方法中获取queryset.</li>
<li>通过使用Router注册, 免去手写 URL conf.</li>
</ol>
<p>当然, 有得有失, 使用ViewSet意味着可以更快地构建API, 并提供相当统一的API格式, 而使用View则可以最大限度且更加清晰地控制视图行为.</p>
<hr>
<h3 id="内省viewset动作"><a href="#内省viewset动作" class="headerlink" title="内省viewset动作"></a>内省viewset动作</h3><p>在dispatch执行过程中, 以下属性可用:</p>
<ol>
<li>basename: 创建url时的 url name.</li>
<li>action 当前执行的action, 例如<code>list</code>, <code>create</code>, 字符串.</li>
<li>detail 当前执行的action是否针对某个具体对象, 还是针对查询集.</li>
<li>suffix 视图集展示的后缀.</li>
<li>name 视图集展示的名字.</li>
<li>description 视图集展示的描述.</li>
</ol>
<p>可以用这些属性来在执行时获取当前信息, 便于执行不同的逻辑.</p>
<p>例如, 动态获取序列化器, 为retrieve行为提供特定的序列化器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewset</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.action == <span class="string">'retrieve'</span>:</span><br><span class="line">			<span class="keyword">return</span> FullAccountSerializer</span><br><span class="line">		<span class="keyword">return</span> BasicAccountSerializer</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="添加额外行为"><a href="#添加额外行为" class="headerlink" title="添加额外行为"></a>添加额外行为</h3><p>为viewset添加额外action, 需要使用<code>@action</code>装饰器, </p>
<p>该装饰器一般需要</p>
<ol>
<li>必要参数<code>detail</code>, 布尔型, 以指明该方法应当作用于单个对象或是查询集.</li>
<li>可选参数 methods, 列表, 指明该额外的行为应当允许何种http method进行访问, 默认值为<code>[&quot;get&quot;]</code></li>
<li>可选参数<code>url_name</code>, 指明该路由所绑定至路由的url name</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status, viewsets</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> myapp.serializers <span class="keyword">import</span> UserSerializer, PasswordSerializer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset that provides the standard actions</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=True, methods=['post'])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        user = self.get_object()</span><br><span class="line">        serializer = PasswordSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            user.set_password(serializer.data[<span class="string">'password'</span>])</span><br><span class="line">            user.save()</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'status'</span>: <span class="string">'password set'</span>&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.errors, </span><br><span class="line">                            status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recent_users</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        recent_users = User.objects.all().order_by(<span class="string">'-last_login'</span>)</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(recent_users)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(recent_users, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p><code>@action</code>还可以包含任意关键字参数, 仅会生效至该路由.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@action(detail=True, methods=['post'], permission_classes=[IsAdminOrIsSelf])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>以上的<code>set_password</code>会在访问<code>users/{pk}/set_password/</code>时被调用, 具体自定义路由的url请查阅<code>Router</code>一节. </p>
<p>注意应用于实例对象的action需要包含<code>pk</code>参数, 而启用后缀协商则需要包含<code>format</code>参数, 或者直接接收任意关键字参数<code>**kwargs</code>.</p>
<p>在程序中查看所有额外行为, 调用<code>.get_extra_actions()</code>方法.</p>
<hr>
<h3 id="为自定义行为根据http-method提供不同行为"><a href="#为自定义行为根据http-method提供不同行为" class="headerlink" title="为自定义行为根据http method提供不同行为"></a>为自定义行为根据http method提供不同行为</h3><p>通常需要在<code>@action</code>中提供包含多个http method的<code>methods</code>参数, 然后在函数体中进行判断</p>
<p>不过更好的选择是使用额外路由对象自带的合并功能, 将多个自定义行为合并, 共用同一个路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@action(detail=True, methods=['put'], name='Change Password')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">    <span class="string">"""Update the user's password."""</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@password.mapping.delete</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_password</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">    <span class="string">"""Delete the user's password."""</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>以上代码, 可以对<code>users/{pk}/password/</code>使用<code>PUT</code>和<code>DELETE</code>, 会分别执行password行为和delete_password行为.</p>
<hr>
<h3 id="反查action的路由"><a href="#反查action的路由" class="headerlink" title="反查action的路由"></a>反查action的路由</h3><p>在运行时获得某个行为所对应的路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>view.reverse_action(<span class="string">'set-password'</span>, args=[<span class="string">'1'</span>])</span><br><span class="line"><span class="string">'http://localhost:8000/api/users/1/set_password'</span></span><br></pre></td></tr></table></figure>

<p>或是在使用<code>@action</code>时传入了<code>url_name</code>参数的话, 可以通过该属性进行反查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>view.reverse_action(view.set_password.url_name, args=[<span class="string">'1'</span>])</span><br><span class="line"><span class="string">'http://localhost:8000/api/users/1/set_password'</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><h3 id="ViewSet"><a href="#ViewSet" class="headerlink" title="ViewSet"></a>ViewSet</h3><p>ViewSet继承自APIView, 本身并不提供任何的操作和处理方法，所以如果直接子类化ViewSet类，需要自己实现<code>action</code>，并完成请求方法和处理方法的绑定. </p>
<h3 id="GenericViewSet"><a href="#GenericViewSet" class="headerlink" title="GenericViewSet"></a>GenericViewSet</h3><p>通用视图集继承自通用视图 <code>GenericViewSet</code>, 提供了<code>get_object</code>, <code>get_queryset</code>等方法和通用视图的基本行为, 但并不包含任何<code>行为</code>, 与通用视图的设计理念类似, 需要通过<code>混入</code>混合类来提供行为, 并组合成为可用的视图集.</p>
<h3 id="ModelViewSet"><a href="#ModelViewSet" class="headerlink" title="ModelViewSet"></a>ModelViewSet</h3><p>由通用视图集GenericViewSet 混入<code>所有</code>的混合类而形成的视图集. ModelViewSet 最低仅需给出查询集和序列化器就可以自动构建出一套完整的包含所有行为的视图集.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A simple ViewSet for viewing and editing accounts.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Account.objects.all()</span><br><span class="line">    serializer_class = AccountSerializer</span><br><span class="line">    permission_classes = [IsAccountAdminOrReadOnly]</span><br></pre></td></tr></table></figure>

<p>所支持的行为包括 <code>retrieve</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>partial_update</code>, <code>destory</code> 行为, 使用Router类注册即可直接进行访问.</p>
<h3 id="ReadOnlyModelViewSet"><a href="#ReadOnlyModelViewSet" class="headerlink" title="ReadOnlyModelViewSet"></a>ReadOnlyModelViewSet</h3><p>由通用视图集GenericViewSet混合<code>mixins.ListModelMixin</code>和<code>mixins.RetrieveModelMixin</code>实现的视图集, 仅支持<code>list</code>和<code>retrieve</code>行为, 即<code>只读</code>行为.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountViewSet</span><span class="params">(viewsets.ReadOnlyModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A simple ViewSet for viewing accounts.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Account.objects.all()</span><br><span class="line">    serializer_class = AccountSerializer</span><br></pre></td></tr></table></figure>

<h3 id="自定义视图集"><a href="#自定义视图集" class="headerlink" title="自定义视图集"></a>自定义视图集</h3><p>使用通用视图集GenericViewSet提供基本架构, 并混入所需的混合类, 即可迅速构建自定义视图集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixins</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateListRetrieveViewSet</span><span class="params">(mixins.CreateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                                mixins.ListModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                                mixins.RetrieveModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                                viewsets.GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset that provides `retrieve`, `create`, and `list` actions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To use it, override the class and set the `.queryset` and</span></span><br><span class="line"><span class="string">    `.serializer_class` attributes.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 通用视图 Generic views</title>
    <url>/2019/10/03/4.%20%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>API的构建总是与Model打交道,所以如何抽象与之相关的重复代码是设计rest-framework的重中之重.</p>
<p>CBV最大的好处在于可以组合一些可复用的行为.例如常用的<code>混入</code>(Mixin)就是极佳的设计思路.</p>
<p>rest-framework提供了很多预置的view用以提供常规功能. </p>
<p>当然也可以使用最基本的APIView, 或是使用genericView以及<code>混入</code>(mixins)来进行组合.</p>
<a id="more"></a>

<p>示例: </p>
<p>通常在使用通用视图的时候,需要重写一些属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django`.contrib.auth.models`<span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> myapp`.serializers`<span class="keyword">import</span> UserSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> generics</span><br><span class="line"><span class="keyword">from</span> rest_framework`.permissions`<span class="keyword">import</span> IsAdminUser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    permission_classes = [IsAdminUser]</span><br></pre></td></tr></table></figure>

<p>或者在复杂的情况下,需要重写一些<code>方法</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    permission_classes = (IsAdminUser, )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># Note the use of `get_queryset()` instead of `self.queryset`</span></span><br><span class="line">        queryset = self.get_queryset()</span><br><span class="line">        serializer = UserSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>而对于最简单的一些情况,直接在<code>.as_view</code>方法中添加参数即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r'^/users/'</span>, </span><br><span class="line">	ListCreateAPIView.as_view(</span><br><span class="line">		queryset=User`.objects.all(),`</span><br><span class="line">		serializer_class=UserSerializer</span><br><span class="line">		), </span><br><span class="line">	name=<span class="string">'user-list'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>API参考</p>
<p><code>GenericAPIView</code> 继承自APIView, 提供了list的detil的基本行为前提: 获得查询集和获得某一个对象</p>
<p>属性</p>
<ul>
<li><code>.queryset</code> 用于从视图返回对象的查询结果集, 设置此属性或者重写get_queryset()来取得结果集。结果会<code>缓存</code>, 以供后续请求的调用。</li>
<li><code>.serializer_class</code> 用于验证和反序列化输入以及序列化输出的Serializer类, 设置此属性或者重写get_serializer_class()方法</li>
<li><code>.lookup_field</code> 用于执行各个model实例的对象查找时使用的字段, 默认是’pk’, 如果使用超链接api的时候, 需要改动这一项, 必须在api视图和序列化类都设置查找字段</li>
<li><code>.lookup_url_kwarg</code> 应用对象查找的url关键字参数, 默认情况下使用与lookup_field相同的值</li>
<li><code>.pagination_class</code> 指定分页类, 默认为settings中的DEFAULT_PAGINATION_CLASS, 该项的默认值为rest_framework.pagination.PageNumberPagination</li>
<li><code>.filter_backends</code> 用于过滤查询集的过滤器后端类的列表。默认值取决于DEFAULT_FILTER_BACKENDS设置项.</li>
</ul>
<p>方法</p>
<ul>
<li><code>.get_queryset(self)</code> 获得查询集.</li>
<li><code>.get_object(self)</code> 获得实例对象(指某条记录构建的Model实例).</li>
<li><code>.get_serializer_class(self)</code> 获得用于序列化的类.</li>
<li><code>.filter_queryset(self,</code>queryset) 进行过滤操作.</li>
</ul>
<p>其他钩子函数:</p>
<p>以下钩子函数由相应的混入类提供, 并可以简单地重写以改变保存或删除时地行为.</p>
<p><code>perform_create(self, serializer)</code> 在创建一个新的对象之前被<code>CreateModelMixin</code>调用<br><code>perform_update(self, serializer)</code> 在更新一个已存对象之前由<code>UpdateModelMixin</code>调用<br><code>perform_destroy(self, instance)</code> 在删除一个现存对象之前由<code>DestroyModelMixin</code>调用</p>
<p>其他方法</p>
<ul>
<li><code>get_serializer_context(self)</code> 获取为序列化器提供的上下文,返回值须为Dict类型.默认<code>已包含&#39;request&#39;</code>,’view’和’format’.</li>
<li><code>get_serializer(self, instance=None, data=None, many=False, partial=False)</code> 获取已被传入数据的序列化器实例.</li>
<li><code>get_paginated_response(self, data)</code> 获得应用分页风格后的Response实例.</li>
<li><code>paginate_queryset(self, queryset)</code> 将查询集进行分页,返回一个分页对象或是在无分页器时返回None.</li>
<li><code>filter_queryset(self, queryset)</code> 需求一个查询集,并返回一个新的过滤后的查询集.</li>
</ul>
<p>建立一个API的两个基本要素为<code>查询集</code>和<code>序列化器</code>,因此在以上属性或方法中</p>
<ol>
<li>必须设置<code>.queryset</code>属性或重写<code>get_queryset</code>来给定<code>查询集</code></li>
<li>必须设置<code>serializer_class</code>属性或重写<code>get_serializer_class</code>来给定<code>序列化器</code></li>
</ol>
<p>其他所有的属性和方法因为已有默认值或默认实现,因此都是可选的.</p>
<p>示例代码:</p>
<p>通过重写<code>get_queryset</code>获得查询集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">    user = self.request.user</span><br><span class="line">    <span class="keyword">return</span> user.accounts.all()</span><br></pre></td></tr></table></figure>

<p>通过重写<code>get_object</code>获得某个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self)</span>:</span></span><br><span class="line">    queryset = self.get_queryset()</span><br><span class="line">    filter = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> self.multiple_lookup_fields:</span><br><span class="line">        filter[field] = self.kwargs[field]</span><br><span class="line"></span><br><span class="line">    obj = get_object_or_404(queryset, **filter)</span><br><span class="line">    self.check_object_permissions(self.request, obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>重写<code>filter_queryset</code>过滤查询集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_queryset</span><span class="params">(self, queryset)</span>:</span></span><br><span class="line">    filter_backends = [CategoryFilter]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'geo_route'</span> <span class="keyword">in</span> self.request.query_params:</span><br><span class="line">        filter_backends = [GeoRouteFilter, CategoryFilter]</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'geo_point'</span> <span class="keyword">in</span> self.request.query_params:</span><br><span class="line">        filter_backends = [GeoPointFilter, CategoryFilter]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> list(filter_backends):</span><br><span class="line">        queryset = backend().filter_queryset(self.request, queryset, view=self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queryset</span><br></pre></td></tr></table></figure>

<p>重写<code>get_serializer_class</code>为不同状态的请求动态提供序列化器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">        <span class="keyword">return</span> FullAccountSerializer</span><br><span class="line">    <span class="keyword">return</span> BasicAccountSerializer</span><br></pre></td></tr></table></figure>

<p>使用钩子函数,在创建一条记录前为其添加属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    serializer.save(user=self.request.user)</span><br></pre></td></tr></table></figure>

<p>使用钩子函数,在创建一条记录后进行邮件通知</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_update</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    instance = serializer.save()</span><br><span class="line">    send_email_confirmation(user=self.request.user, modified=instance)</span><br></pre></td></tr></table></figure>

<p>使用钩子函数,为其进行额外的数据合法性检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    queryset = SignupRequest.objects.filter(user=self.request.user)</span><br><span class="line">    <span class="keyword">if</span> queryset.exists():</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">'You have already signed up'</span>)</span><br><span class="line">    serializer.save(user=self.request.user)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="混入-Mixins"><a href="#混入-Mixins" class="headerlink" title="混入(Mixins)"></a>混入(Mixins)</h2><p>GenericAPIView无法被作为视图类直接使用,因为它没有实现任何与HTTP METHOD同名的处理函数, 例如<code>get</code>或是<code>post</code>等,因此GenericAPIView不能处理任何请求.</p>
<p>GenericAPIView仅仅是提供了基本架构, 以及获取数据的接口,而如何将获取的查询集或是对象转为响应,这些<code>行为</code>都由以下的混入类完成.</p>
<p>(导出路径均为<code>rest_framework.mixins</code>)</p>
<ul>
<li><code>ListModelMixin</code> 提供 <code>list</code>行为,可以将查询集列出.</li>
<li><code>CreateModelMixin</code> 提供<code>create</code>行为, 可以创建一个新的model实例。</li>
<li><code>etrieveModelMixin</code> 提供<code>retrieve</code>行为, 可以取回一个现有的model实例。</li>
<li><code>UpdateModelMixin</code> 提供 <code>.update</code>和<code>partial_update</code>行为, 可以更新/部分更新现有模型实例</li>
<li><code>DestroyModelMixin</code> 提供一个 <code>.destroy</code>行为, 可以删除现有模型实例。</li>
</ul>
<p>当我们谈<code>行为</code>(action)的时候,指的是:<code>list</code> <code>detail</code> <code>update</code> <code>retrieve</code> <code>destory</code>这些对数据的操作,而非<code>get</code>,<code>post</code>, <code>update</code>这些真正执行的<code>视图函数</code>, 这些视图函数当然会调用这些已实现的行为,但不能将他们混为一谈.</p>
<p>使用多重继承的方式来构建我们的视图函数,首先根据需求酌情继承混入类, 最后继承GenericAPIView</p>
<p>示例代码: 实现一个列出数据的视图类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixins</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListAPIView</span><span class="params">(mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  GenericAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Concrete view for listing a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>或者一个能读取,修改,删除实例的视图类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetrieveUpdateDestroyAPIView</span><span class="params">(mixins.RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                   mixins.UpdateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                   mixins.DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                   GenericAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Concrete view for retrieving, updating or deleting a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">patch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.partial_update(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.destroy(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>以GenericAPIView提供基本架构,以混入类提供<code>行为</code>,并在处理方法调用<code>行为</code>,就形成了可用的视图类.</p>
<hr>
<p>已混合的类(Mixined)</p>
<p>以下类都是根据常用需求,按照以上思路混合好的一些类,这些类都能作为视图类,只要设定好查询集和序列化器就可以直接投入使用.</p>
<table>
<thead>
<tr>
<th>Mixined</th>
<th>inherit from</th>
<th>method</th>
</tr>
</thead>
<tbody><tr>
<td>CreateAPIView</td>
<td>GenericAPIView, CreateModelMixin</td>
<td>post</td>
</tr>
<tr>
<td>ListAPIView</td>
<td>GenericAPIView, ListModelMixin</td>
<td>get</td>
</tr>
<tr>
<td>RetrieveAPIView</td>
<td>GenericAPIView, RetrieveModelMixin</td>
<td>get</td>
</tr>
<tr>
<td>DestroyAPIView</td>
<td>GenericAPIView, DestroyModelMixin</td>
<td>delete</td>
</tr>
<tr>
<td>UpdateAPIView</td>
<td>GenericAPIView, UpdateModelMixin</td>
<td>update</td>
</tr>
<tr>
<td>ListCreateAPIView</td>
<td>GenericAPIView, ListModelMixin, CreateModelMixin</td>
<td>get,post</td>
</tr>
<tr>
<td>RetrieveUpdateAPIView</td>
<td>GenericAPIView, RetrieveModelMixin, UpdateModelMixin</td>
<td>get, put,patch</td>
</tr>
<tr>
<td>RetrieveDestroyAPIView</td>
<td>GenericAPIView, RetrieveModelMixin, DestroyModelMixin</td>
<td>get, delete</td>
</tr>
<tr>
<td>RetrieveUpdateDestroyAPIView</td>
<td>GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin</td>
<td>get,put, patch,delete</td>
</tr>
</tbody></table>
<hr>
<h2 id="自定义通用视图"><a href="#自定义通用视图" class="headerlink" title="自定义通用视图"></a>自定义通用视图</h2><p>通常情况下, 应该使用现有通用视图并自定义某些行为. 当然, 如果想要对多个视图作出更改并重用某些行为, 有必要直接重写通用视图.</p>
<h4 id="创建自定义混合类"><a href="#创建自定义混合类" class="headerlink" title="创建自定义混合类"></a>创建自定义混合类</h4><p>例如, 如果想要基于url中多个字段来查找数据对象, 可以创建如下混合类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleFieldLookupMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Apply this mixin to any view or viewset to get multiple field filtering</span></span><br><span class="line"><span class="string">    based on a `lookup_fields` attribute, instead of the default single field filtering.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self)</span>:</span></span><br><span class="line">        queryset = self.get_queryset()             <span class="comment"># Get the base queryset</span></span><br><span class="line">        queryset = self.filter_queryset(queryset)  <span class="comment"># Apply any filter backends</span></span><br><span class="line">        filter = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> self.lookup_fields:</span><br><span class="line">            <span class="keyword">if</span> self.kwargs[field]: <span class="comment"># Ignore empty fields.</span></span><br><span class="line">                filter[field] = self.kwargs[field]</span><br><span class="line">        obj = get_object_or_404(queryset, **filter)  <span class="comment"># Lookup the object</span></span><br><span class="line">        self.check_object_permissions(self.request, obj)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

<p>然后可以简单地将该混合类混入视图中来应用自定义行为.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetrieveUserView</span><span class="params">(MultipleFieldLookupMixin, generics.RetrieveAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line">    lookup_fields = [<span class="string">'account'</span>, <span class="string">'username'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="创建自定义通用视图基类"><a href="#创建自定义通用视图基类" class="headerlink" title="创建自定义通用视图基类"></a>创建自定义通用视图基类</h4><p>如果需要在多个视图函数中混入该类, 则可以更进一步, 直接将该类与现有混合类创建新的基本视图, 并在整个项目中使用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRetrieveView</span><span class="params">(MultipleFieldLookupMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                       generics.RetrieveAPIView)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRetrieveUpdateDestroyView</span><span class="params">(MultipleFieldLookupMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                                    generics.RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 基于类的视图 Class-based Views</title>
    <url>/2019/10/03/3.%20%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%A7%86%E5%9B%BE%20Class-based%20Views/</url>
    <content><![CDATA[<h3 id="基于类的视图"><a href="#基于类的视图" class="headerlink" title="基于类的视图"></a>基于类的视图</h3><p>基于类的视图具有很多的优点,因此是推荐使用的不二选择.</p>
<p>rest-framework的<code>APIView</code>类继承自Django的<code>View</code>类, 它与View的不同之处包括如下几点:</p>
<ol>
<li>确定将请求封装为<code>Response</code>, 而非Django的<code>HttpRequest</code>.</li>
<li>进行内容协商并为<code>Response</code>选择正确的渲染器.</li>
<li>捕获任何<code>APIException</code>异常,并渲染为合适的响应.</li>
<li>在为请求分配任何处理函数前进行合适的权限/限流验证.</li>
</ol>
<p>使用APIView的方式与View类似,定义与HTTP METHOD同名的方法,然后相关的请求就会被分配至对应的方法中处理:</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> authentication, permissions</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListUsers</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    View to list all users in the system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * Requires token authentication.</span></span><br><span class="line"><span class="string">    * Only admin users are able to access this view.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    authentication_classes = [authentication.TokenAuthentication]</span><br><span class="line">    permission_classes = [permissions.IsAdminUser]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return a list of all users.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        usernames = [user.username <span class="keyword">for</span> user <span class="keyword">in</span> User.objects.all()]</span><br><span class="line">        <span class="keyword">return</span> Response(usernames)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="基于函数的视图"><a href="#基于函数的视图" class="headerlink" title="基于函数的视图"></a>基于函数的视图</h3><p>当然, 在某些情况下,使用基于函数的视图函数也可能是更好的选择</p>
<p>基于函数的视图,必须使用@api_view装饰器以确保以上基本特性,并为任何附加方案增添对应的装饰器.</p>
<p>所以基于函数的视图在rest-framework中总是附加着一连串装饰器,可用的装饰器包括</p>
<ul>
<li>@renderer_classes(…)</li>
<li>@parser_classes(…)</li>
<li>@authentication_classes(…)</li>
<li>@throttle_classes(…)</li>
<li>@permission_classes(…)</li>
</ul>
<p>以上所有装饰器的参数都必须是一个列表或者元组,包含相应的类.</p>
<p>使用基于函数的视图的示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view, throttle_classes</span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> UserRateThrottle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OncePerDayUserThrottle</span><span class="params">(UserRateThrottle)</span>:</span></span><br><span class="line">        rate = <span class="string">'1/day'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(['GET'])</span></span><br><span class="line"><span class="meta">@throttle_classes([OncePerDayUserThrottle])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(&#123;<span class="string">"message"</span>: <span class="string">"Hello for today! See you tomorrow!"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>基于函数的视图在rest-framework中仅在实现非常简单的功能的情况下值得一用,绝大多数情况下使用CBV才是最佳选择.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 响应 Responses</title>
    <url>/2019/10/03/2.%20%E5%93%8D%E5%BA%94%20Response/</url>
    <content><![CDATA[<p>rest-framework的Response继承自Django的<code>SimpleTemplateResponse</code></p>
<p>Response 初始化时本身只包含纯粹的数据,而在之后被rest-framework通过内容协商确定客户端所需格式后,渲染为真正的HTTP响应.</p>
<p>推荐使用Response而非常规的<code>HttpResponse</code>或<code>StreamingHttpResponse</code>理由是Response提供了更好的接口可以根据内容协商以渲染为各种不同的格式.</p>
<p>除非需要深度化定制, 应当一直使用APIView或者使用同样返回Response的@api_view装饰的view函数,以确保视图可以进行内容协商和渲染不同类型的响应.</p>
<hr>
<a id="more"></a>

<p>签名: <code>Response(data, status=None, template_name=None, headers=None, content_type=None)</code></p>
<p>参数解释:</p>
<ul>
<li>data 作为响应主体内容的data, 需要为简单数据类型,例如Dict</li>
<li>status 响应的状态码, 默认为200</li>
<li>template_name: 可选,使用<code>HTMLRenderer</code>时要使用的模板名称。</li>
<li>headers: 额外添加的HTTP响应头的字典</li>
<li>content_type：通常由renderer自主决定，但也有可能需要明确指定</li>
</ul>
<p>属性:</p>
<ul>
<li><code>.data</code> 未渲染但应当是序列化过后的简单数据类型的data</li>
<li><code>.status_code</code> 状态码</li>
<li><code>.content</code> 渲染后的响应内容,调用该属性等于强制立即渲染.</li>
<li><code>.template_name</code> 用以渲染的html模板.仅在渲染器为<code>HTMLRenderer</code>(或类似的自定义渲染器)时不为空.</li>
<li><code>.accepted_renderer</code> 将用于进行渲染的渲染器类</li>
<li><code>.accepted_media_type</code> 在内容协商阶段确定响应内容的媒体类型</li>
<li><code>.renderer_context</code> 其他需要被传递给渲染器的额外上下文.</li>
</ul>
<p>当然,还包含标准<code>HttpResponse</code>包含的所有属性/方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = Response()</span><br><span class="line">response[<span class="string">'Cache-Control'</span>] = <span class="string">'no-cache'</span></span><br></pre></td></tr></table></figure>

<p>还包括继承自<code>SimpleTemplateResponse</code>的<code>render()</code>方法, 当然通常并不需要手动调用该方法,因为它是由Django的标准响应周期来处理的。</p>
<p>注: <code>SimpleTemplateResponse</code>与默认的<code>HttpResponse</code>行为模式不同,包括延迟渲染等特性,可以查阅Django文档了解.</p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 请求 Requests</title>
    <url>/2019/10/03/1.%20%E8%AF%B7%E6%B1%82%20request/</url>
    <content><![CDATA[<p>APIView的子类中的request不是django标准的HttpRequest类，而是经由rest_framework扩展的Request类</p>
<p>相较于HttpRequest添加的属性如下</p>
<p>请求解析相关:</p>
<ul>
<li><code>.data</code>类似于Django中request的<code>.POST</code>或者<code>.files</code>, 但在REST API中, put方法和putch方法也会被经常使用,因此这样可以避免命名带来的歧义.</li>
<li><code>.query_params</code>请求的查询参数, 等同于Django中的request.GET, 但命名更加准确.</li>
<li><code>.parsers</code>该请求所使用的parsers类,具体参看parsers一节.</li>
</ul>
<p>内容协商相关:</p>
<ul>
<li><code>.accepted_renderer</code>由内容协商阶段选择的renderer实例</li>
<li><code>.accepted_media_type</code>由内容协商阶段接受的媒体类型的字符串</li>
</ul>
<a id="more"></a>

<p>用户身份认证相关:</p>
<ul>
<li><code>.user</code>已认证的请求返回一个<code>django.contrib.auth.models.User</code>实例，未认证的请求返回一个<code>django.contrib.auth.models.AnonymousUser</code>实例。</li>
<li><code>.auth</code>未认证或没有其他上下文，则为None</li>
<li><code>.authenticators</code>用于进行认证的实例类</li>
</ul>
<p>浏览器增强:</p>
<ul>
<li><code>.method</code> 请求的HTTP METHOD, 全大写</li>
<li><code>.content_type</code>请 求体内容的媒体类型</li>
<li><code>.stream</code> 一个表示请求主体内容的流，通常依赖于rest_framework的默认请求解析行为</li>
</ul>
<p>标准HttpRequest属性:</p>
<p>其他Django标准HttpRequest的<code>所有</code>属性,例如</p>
<ul>
<li>.META</li>
<li>.session</li>
</ul>
<p>等等.</p>
<p>但Response不是<code>继承</code>(inherited)自HttpRequest,而是使用<code>聚合</code>(compostion)的方式拓展HttpRequest的实例.</p>
<p>关于继承和聚合,查看我的<a href>另一篇博客</a></p>
]]></content>
      <tags>
        <tag>django-rest-framework中文文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo自定义代码高亮</title>
    <url>/2019/08/22/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<p>以Next主题为例, 只提供了五种代码高亮样式, 在都不满足需要的情况下, 可能需要进行自定义.</p>
<p>因为Next并没有提供接口, 所以需要直接修改相关css代码.</p>
<hr>
<h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>被一对反引号标记的行内代码, 默认情况下是灰色背景, 文本颜色不变, 如果需要修改, 则找到<code>&lt;code&gt;</code>选择器部分:</p>
<p>行内代码高亮的css部分定义在<code>next/source.css/_common/component/highlight/highlight.styl</code>中.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">  <span class="attribute">color</span>: $code-foreground;</span><br><span class="line">  <span class="attribute">background</span>: $code-background;</span><br><span class="line">  <span class="attribute">border-radius</span>: $code-border-radius;</span><br><span class="line">  font-size $code-font-size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改为红色文本, 淡红色背景, 则更改<code>color</code>和<code>background</code>属性:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(255,192,203, 0.1);</span><br><span class="line">  <span class="attribute">border-radius</span>: $code-border-radius;</span><br><span class="line">  font-size $code-font-size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="高亮主题"><a href="#高亮主题" class="headerlink" title="高亮主题"></a>高亮主题</h3><p>Hexo提供了五种代码高亮主题: <code>normal</code>, <code>night</code>, <code>night blue</code>, <code>night bright</code>, <code>night eighties</code>.</p>
<p>高亮主题的css部分定义在<code>next/source.css/_common/component/highlight/theme.styl</code>中, 在这里我们能看到具体的方案配色:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">if $highlight_theme == "normal"</span><br><span class="line">  $highlight-background   = #f7f7f7</span><br><span class="line">  $highlight-current-line = #efefef</span><br><span class="line">  $highlight-selection    = #d6d6d6</span><br><span class="line">  $highlight-foreground   = #4d4d4c</span><br><span class="line">  $highlight-comment      = #8e908c</span><br><span class="line">  $highlight-red          = #c82829</span><br><span class="line">  $highlight-orange       = #f5871f</span><br><span class="line">  $highlight-yellow       = #eab700</span><br><span class="line">  $highlight-green        = #718c00</span><br><span class="line">  $highlight-aqua         = #3e999f</span><br><span class="line">  $highlight-blue         = #4271ae</span><br><span class="line">  $highlight-purple       = #8959a8</span><br><span class="line">  $highlight-gutter       = &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#869194</span>,</span><br><span class="line">    <span class="selector-tag">bg-color</span>: <span class="selector-id">#eff2f3</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>直接更改某个主题的配色, 然后应用该主题即可.</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法基础</title>
    <url>/2019/07/31/SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域(后端)</title>
    <url>/2019/07/07/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>由于浏览器的安全限制, 因此需要一种机制来保证允许安全的跨域请求.</p>
<a id="more"></a>

<hr>
<h3 id="CORS-Cross-Origin-Resource-Sharing-跨源资源共享"><a href="#CORS-Cross-Origin-Resource-Sharing-跨源资源共享" class="headerlink" title="CORS(Cross-Origin Resource Sharing)跨源资源共享"></a>CORS(Cross-Origin Resource Sharing)跨源资源共享</h3><p>CORS是一种机制, 它定义了一组HTTP头部, 用以对浏览器声明可以允许对哪些网站发起跨域请求</p>
<p>即：浏览器拦不拦截该跨域请求, 要询问过被请求的网站之后再做决定. 当然, 也必须浏览器能支持CORS才能理解并使用CORS机制来完成跨域请求.</p>
<p>基本所有的主流浏览器都支持CORS.</p>
<p>跨域请求的流程:</p>
<p>发起跨域请求的B网站, 浏览器, 以及接收到跨域请求的A网站</p>
<ol>
<li>B网页中内嵌的js要求浏览器对A发送请求</li>
<li>浏览器并不直接对A发起请求, 而是通过预检请求(请求方式一般为OPTION)先询问A, 是否接受该请求</li>
<li>A收到浏览器的请求, 并通过响应的头部告诉浏览器, 它允许B引用自己的资源</li>
<li>浏览器得到肯定的答复, 真正对A发起(B要求浏览器发起的)请求</li>
</ol>
<p>这样, 浏览器就实现了跨域请求, 所有跨域请求都要得到目标域的允许, 不会影响安全性. </p>
<hr>
<h3 id="CORS头"><a href="#CORS头" class="headerlink" title="CORS头"></a>CORS头</h3><p>CORS新增了一些HTTP header字段, 这些字段用于目标域返回给浏览器用以告诉浏览器是否允许该跨域请求</p>
<table>
<thead>
<tr>
<th>HTTP头</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Access-Control-Allow-Origin</td>
<td>指定允许访问该资源的外域URL, 如果是通配符<code>*</code>, 代表允许来自所有域的请求</td>
</tr>
<tr>
<td>Access-Control-Allow-Methods</td>
<td>指定允许进行跨域请求的method, 如果是通配符<code>*</code>,代表允许所有method的请求</td>
</tr>
<tr>
<td>Access-Control-Allow-Headers</td>
<td>指定实际请求中允许携带的首部字段,如果是通配符<code>*</code>,代表允许携带任意首部的请求</td>
</tr>
<tr>
<td>Access-Control-Max-Age</td>
<td>指定本次预检请求的结果能够被缓存多久(无论是允许, 还是不允许)</td>
</tr>
<tr>
<td>Access-Control-Expose-Headers</td>
<td>指定浏览器可以在跨域访问中获得的除了基本头之外的响应头</td>
</tr>
<tr>
<td>Access-Control-Allow-Credentials</td>
<td>布尔型, 指定实际请求中是否允许携带Cookie,  默认为不允许</td>
</tr>
</tbody></table>
<p>以下字段用于发送预检或发送实际跨域请求时, 浏览器告知服务器端的信息</p>
<table>
<thead>
<tr>
<th>HTTP头部</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Origin</td>
<td>给出预检请求和实际请求的源站</td>
</tr>
<tr>
<td>Access-Control-Request-Method</td>
<td>预检时使用, 将实际请求所使用的HTTP方法告知服务器</td>
</tr>
<tr>
<td>Access-Control-Request-Headers</td>
<td>预检时使用, 将实际请求所携带的首部字段告知服务器</td>
</tr>
</tbody></table>
<hr>
<h3 id="在Django中允许跨站请求"><a href="#在Django中允许跨站请求" class="headerlink" title="在Django中允许跨站请求"></a>在Django中允许跨站请求</h3><p><a href="https://pypi.org/project/django-cors-headers/" target="_blank" rel="noopener">django-cors-headers</a>包是对CORS的服务器端实现,允许django服务器接收来自浏览器的跨域请求</p>
<p>通过pip安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>

<p>添加到INSTALLED_APP中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'corsheaders'</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>添加中间件, 通过中间件为响应添加CORS相关的头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [ </span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'corsheaders.middleware.CorsMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>corsheaders.middleware.CorsMiddleware</code>要放在尽量靠前的位置, 以便能够为最终的响应添加头</p>
<hr>
<p>设置项</p>
<p><code>CORS_ORIGIN_WHITELIST</code>: 字符串列表, 给出所有允许跨域请求的源<br><code>CORS_ORIGIN_REGEX_WHITELIST</code>: 正则表达式列表, 给出所有允许跨院请求的源的格式<br><code>CORS_ORIGIN_ALLOW_ALL</code>: 布尔型, 是否允许所有的跨域请求<br><code>CORS_URLS_REGEX</code>: 正则表达式列表, 给出本网站允许跨域请求的URL, 在网站只有部分URL允许跨域请求时有用<br><code>CORS_ALLOW_METHODS</code>：字符串列表, 给出所有允许跨域请求的方式<br><code>CORS_ALLOW_HEADERS</code>：字符串列表, 允许实际请求携带的头<br><code>CORS_EXPOSE_HEADERS</code>: 字符串列表, 允许在跨域请求中暴露的额外响应头<br><code>CORS_PREFLIGHT_MAX_AGE</code>: 整数, 给出该预检请求的结果缓存时间(秒), 默认为一天<br><code>CORS_ALLOW_CREDENTIALS</code>：布尔型, 是否允许实际请求携带cookie</p>
<hr>
<h4 id="如何让跨域请求通过CSRF中间件"><a href="#如何让跨域请求通过CSRF中间件" class="headerlink" title="如何让跨域请求通过CSRF中间件:"></a>如何让跨域请求通过CSRF中间件:</h4><p>Django的CORS和CSRF保护是分离的, 所以CSRF的防御并不会自动允许CORS所允许的域的POST请求.<br>如果想允许跨域的不安全请求方式, 除了要将源添加入django-cors-headers的CORS_ORIGIN_WHITELIST<br>还需要将其添加入<a href="https://docs.djangoproject.com/en/dev/ref/settings/#csrf-trusted-origins" target="_blank" rel="noopener">CSRF_TRUSTED_ORIGINS</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    &apos;http://read.only.com&apos;,</span><br><span class="line">    &apos;http://change.allowed.com&apos;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">CSRF_TRUSTED_ORIGINS = (</span><br><span class="line">    &apos;change.allowed.com&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p>如果除了需要设置项, 还需要使用代码来判断请求是否被允许, 可以使用django信号来完成. 可以参考<a href="https://pypi.org/project/django-cors-headers/" target="_blank" rel="noopener">官方文档</a></p>
<p>参考:<br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a><br><a href="https://www.jianshu.com/p/f880878c1398" target="_blank" rel="noopener">什么是跨域请求以及实现跨域的方案</a><br><a href="https://blog.csdn.net/lambert310/article/details/51683775" target="_blank" rel="noopener">什么是跨域？怎么解决跨域问题？</a><br><a href="https://www.jianshu.com/p/f880878c1398" target="_blank" rel="noopener">什么是跨域请求以及实现跨域的方案</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制</a>  </p>
]]></content>
      <tags>
        <tag>前端安全</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击原理和防御</title>
    <url>/2019/07/02/XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>XSS(Cross Site Script)跨站脚本攻击，属于一种注入攻击，黑客通过”HTML注入”篡改了网页，插入恶意脚本，从而在用户浏览网页时，控制用户浏览器。</p>
<p>前提条件:</p>
<ol>
<li>向web页面注入恶意html代码</li>
<li>恶意代码能被浏览器成功执行</li>
</ol>
<a id="more"></a>


<p>根据攻击来源不同，XSS分为两类:</p>
<ol>
<li>反射型XSS: 给用户发送页面或者链接，让用户点击来发起攻击，也叫做”非持久型XSS”</li>
<li>存储型XSS: 把攻击存放在服务器端，每个打开网页的用户都自动加载恶意代码，也叫做”持久性XSS”</li>
</ol>
<p>如何防御?</p>
<ol>
<li>避免在cookie中存放重要敏感信息.</li>
<li>进行字符转义，用户输入的信息应当被转义后使用，无论是URL还是表单内容甚至cookie.</li>
<li>表单提交使用post方式而非get方式.</li>
</ol>
]]></content>
      <tags>
        <tag>前端安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF攻击原理和防御</title>
    <url>/2019/07/02/CSRF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>CSRF(Cross-site request forgery) 跨站请求伪造, 也被缩写为XSRF</p>
<p>CSRF的本质是外站盗用用户的身份并伪造成用户发送请求, 造成隐私和财产安全</p>
<a id="more"></a>

<p>实现攻击的原理</p>
<ol>
<li>用户浏览并登录信任网站A</li>
<li>A在浏览器生成Cookie, 并以此来保持在A网站登录状态</li>
<li>在未登出A网站的情况下, 访问了危险网站B</li>
<li>B网站页面中, 通过内嵌的js向A某个url发出请求</li>
<li>既然是访问A页面, 浏览器自动携带由网站A的Cookie</li>
<li>A并不清楚该请求来自何处, 但拥有正确的Cookie, 所以视为用户的操作</li>
<li>该危险请求被A所接受, B成功伪造用户身份, 成功让A网站执行了操作</li>
</ol>
<p>防御CSRF攻击主要可以从两个方面入手, 客户端和服务器端.</p>
<hr>
<h4 id="客户端的防御"><a href="#客户端的防御" class="headerlink" title="客户端的防御"></a>客户端的防御</h4><p>从客户端来说, 用户主要通过浏览器进行对网站的访问, 因此出于安全方面的考虑, 浏览器默认对跨域请求做出限制, 拦截掉所有不同源的请求. </p>
<p>同源策略:</p>
<p>什么是同源?<br>协议, 域名, 端口均相同, 就是同源, 三者任一不同, 则为跨域</p>
<p>如何做出限制?</p>
<ul>
<li>DOM层面:不同源的js或document, 不可读取或设置当前DOM的属性</li>
<li>Cookie和XMLHttprequest层面: 浏览器直接拦截当前页面中Ajax的跨域请求,  对于同源的Ajax请求, 不可携带与本网站不同源的Cookie</li>
<li><code>&lt;script&gt;&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;</code>等带有src属性的标签不受该限制</li>
<li>其他插件的同源策略</li>
</ul>
<p>在以上的例子中, 在B网站页面中内嵌的js对与其不同源的A网站发起的请求被浏览器拦截, 因此也就无法完成伪造请求. </p>
<hr>
<h4 id="服务器端的防御"><a href="#服务器端的防御" class="headerlink" title="服务器端的防御"></a>服务器端的防御</h4><p>从服务器端来说, 主要方案是在客户端页面增加伪随机数, 并在验证时需要验证该伪随机数</p>
<ol>
<li>所有表单包含同一个伪随机数, 且该随机数为一直不变, 例如可以根据用户的cookie算出, 因为B无法访问A在客户端设置的Cookie, 所以B不可能得知正确的伪随机数</li>
<li>每个表单都包含不同的伪随机数, 该伪随机数每次都在变化, 并将每次的伪随机数都保存在服务器端, 并添加一份到表单的隐藏字段中, 只有包含对应的伪随机数的post请求提交到服务器端时, 该请求才被接受</li>
<li>验证码, 用以保证用户的敏感操作需要手动进行.</li>
</ol>
<p>当然, 考虑到用户可能每次都要请求多个表单, 该伪随机数必须支持多个表单并行提交, 而非每次只接受最后一次请求的表单的提交请求. </p>
<hr>
<h4 id="Django的CSRF验证"><a href="#Django的CSRF验证" class="headerlink" title="Django的CSRF验证"></a>Django的CSRF验证</h4><p>Django的csrftoken放置于cookie的<code>csrftoken</code>字段中, 因此任何其他网站不可以访问到csrftoken.</p>
<p>在用户发起请求时, 先访问当前域的cookie, 获得csrftoken, 然后将其包含在表单数据中, 或放置于某个HTTP头中(取决于Django的<code>CSRF_HEADER_NAME</code>设置项).</p>
<p>如果使用Django Template, 则该字段在初始化时就作为隐藏字段被包含在表单中, 在提交时会随之提交.</p>
<hr>
<h4 id="前后端分离项目如何自动包含csrf"><a href="#前后端分离项目如何自动包含csrf" class="headerlink" title="前后端分离项目如何自动包含csrf?"></a>前后端分离项目如何自动包含csrf?</h4><p>例如使用axios, 仅需设置如下两行:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.xsrfCookieName = <span class="string">'csrftoken'</span></span><br><span class="line">axios.defaults.xsrfHeaderName = <span class="string">"X-CSRFToken"</span></span><br></pre></td></tr></table></figure>

<p>前者设置axios应当从cookies获得csrftoken的字段名, 后者则是应当将csrftoken作为哪个HTTP头中发送.</p>
<p>后者的设置值具体可能还要参考Django的<a href="https://docs.djangoproject.com/en/2.2/ref/settings/#csrf-header-name" target="_blank" rel="noopener"><code>CSRF_HEADER_NAME</code></a>设置项.</p>
<p>这样, 在每个发送请求时, axios都会自动获取csrftoken, 并自动包含csrftoken.</p>
<hr>
<h4 id="在跨域请求时-如何解决csrf问题"><a href="#在跨域请求时-如何解决csrf问题" class="headerlink" title="在跨域请求时, 如何解决csrf问题?"></a>在<strong>跨域</strong>请求时, 如何解决csrf问题?</h4><p>跨域时可以指定跨域请求<strong>携带</strong>外域的cookie, 但在当前域内不可以<strong>访问</strong>该cookie, 因此也无法获取该cookie中包含的csrftoken.</p>
<p>即, 跨域请求不可能从cookie中获得csrftoken, 任何获取外域cookie的行为都被浏览器阻止.</p>
<p>如果必须开启CSRF验证, 则需要后端给出csrf接口, 跨域请求需要先访问该接口获得csrftoken, 该csrftoken应当包含在响应的body部分, 而非放置在cookie中.</p>
<p>获取到csrftoken后, 将其包含在表单或HTTP头中发起跨域请求.</p>
]]></content>
      <tags>
        <tag>CSRF</tag>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>python多继承协同任务</title>
    <url>/2019/06/01/python%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%8D%8F%E5%90%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>理解了python的MRO之后, 我们就可以更加准确地使用super()函数, 以及使用super()完成<strong>多继承协同任务</strong></p>
<p>super().method()是调用父类中的方法, 这个搜索顺序按照MRO从前向后进行.</p>
<a id="more"></a>

<p><code>super([type][, object-or-type])</code></p>
<p>根据官方文档, <code>super</code>函数返回一个委托类<code>type</code>的父类或者兄弟类方法调用的代理对象. <code>super</code>函数用来调用已经在子类中重写过的父类方法. </p>
<p>这句话其实很难看明白, 为什么除了父类还可能是兄弟类?</p>
<p>要理解这句话, 先谈谈<code>super</code>的参数的传入方式不同带来的不同之处</p>
<p>常见的是直接调用<code>super()</code>,这其实是<code>super(type, obj)</code>的简写方式, 将当前的类传入<code>type</code>参数, 同时将实例对象传入<code>type-or-object</code>参数, 这两个实参必须确保<code>isinstance(obj, type)</code>为<code>True</code>. </p>
<p>使用该方法调用的<code>super</code>函数返回的代理类是<code>obj</code>所属类的MRO中, 排在type之后的下一个父类. </p>
<p>示例:<br>类的继承结构如下<br> <img src="https://img2018.cnblogs.com/blog/1249301/201905/1249301-20190525170912709-1726985906.png" alt></p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>类C的MRO为[C, A, B, object]</p>
<p>现在我们为其添加一个方法<code>x()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run A.x'</span>)</span><br><span class="line">		super().x()</span><br><span class="line">		print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run B.x'</span>)</span><br><span class="line">		print(self)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run C.x'</span>)</span><br><span class="line">		super().x()</span><br><span class="line">		print(self)</span><br><span class="line"></span><br><span class="line">C().x()</span><br></pre></td></tr></table></figure>

<p>该方法最先被调用时是作为C的实例方法, 根据MRO, 我们很清楚, 下一步它会调用其MRO父类中的同名方法, 即A中的x()方法, 但是, 我们在A的x()方法中再次使用了super(), 这时候会怎么样呢?</p>
<p>查看结果输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">run C.x</span><br><span class="line">run A.x</span><br><span class="line">run B.x</span><br><span class="line">&lt;__main__.C object at <span class="number">0x000002B5041BB710</span>&gt;</span><br><span class="line">&lt;__main__.C object at <span class="number">0x000002B5041BB710</span>&gt;</span><br><span class="line">&lt;__main__.C object at <span class="number">0x000002B5041BB710</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在调用了A中的<code>x()</code>方法之后, 下一个调用的是B中的<code>x()</code>方法, 在继承结构中, 类A和类B互为兄弟关系, <code>super()</code>在A中调用的时候, 最终却调用其兄弟的同名方法, 这就是之前说的, <em><code>super</code>函数返回一个委托类<code>type</code>的父类或者兄弟类方法调用的代理对象</em>. </p>
<p>那么, 为什么?<br>根据<code>print(self)</code>的输出, 所有在这些<code>super()</code>的调用过程中, self参数传入的是同一个obj, 就是我们初始化的<code>C()</code>, 在内存中位置为<strong>0x000002B5041BB710</strong>的对象. </p>
<p>之前已经说过, <code>super()</code>是<code>super(type, obj)</code>的简写, 在调用<code>super()</code>时, <code>type</code>参数传入的是当前的类, 而<code>obj</code>参数则是默认传入当前的实例对象, 在<code>super()</code>的后续调用中, <code>obj</code>一直未变, 而实际传入的<code>class</code>是动态变化.</p>
<p>即, 在首次调用时, MRO就已经被确定, 是<code>obj</code>所属类(即C)的MRO, 因此<code>class</code>参数的作用就是从已确定的MRO中找到位于其后紧邻的类, 作为再次调用<code>super()</code>时查找该方法的下一个类. </p>
<p>因此, <code>super</code>函数这一部分的核心逻辑应该为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(class, obj)</span>:</span></span><br><span class="line">    mro_list = obj.__class__.mro()</span><br><span class="line">    next_parent_class = mro_list[mro_list.index(<span class="class"><span class="keyword">class</span>)+1]</span></span><br><span class="line"><span class="class">    <span class="title">return</span> <span class="title">next_parent_class</span></span></span><br></pre></td></tr></table></figure>

<p>这就是为什么必须保证<code>isinstance(obj, type)</code>为<code>True</code>的原因, 如果不是, 那么可能<code>type</code>就不存在于<code>obj.__class__</code>的MRO列表中, 该算法就无法正确找到下一个应当被查找的类. </p>
<p>因此, 如果我们在某个类的父类中按照其MRO顺序, 每个父类都写一个同名方法, 同时每个该方法中都继续调用<code>super()</code>, 直到在MRO列表<code>object</code>之前的最后一个类的同名方法中不再调用<code>super()</code>, 那么在调用该方法时, 会在各个父类中按照MRO列表的顺序依次被调用, </p>
<p>这个过程中存在数据的传递, 代表它们之间可以<strong>共享</strong>某些数据, 这就实现了多继承协同工作. </p>
<hr>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>继承结构如下图<br><img src="https://img2018.cnblogs.com/blog/1249301/201905/1249301-20190525173624849-2039140699.png" alt></p>
<p>我们试图达到的目的如下:</p>
<ol>
<li>一个类<code>Final</code>继承<code>Header</code>以获得属性<code>header</code></li>
<li>通过混合其他类来快捷地修饰<code>header</code>属性, 例如继承类<code>Mixin1</code>会为<code>header</code>属性(其数据类型为列表)追加数据<code>data1</code>,而继承类<code>Minix2</code>则会为<code>header</code>属性的头部添加元素<code>data2</code>,注意, 因为这些操作并不冲突, 这些行为都不该相互覆盖. </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minix1</span>:</span></span><br><span class="line">	<span class="string">"""该混合类为header列表末尾添加data1"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run Minix1.get_header'</span>)</span><br><span class="line">		ctx = super().get_header()</span><br><span class="line">		ctx.append(<span class="string">'data1'</span>)</span><br><span class="line">		<span class="keyword">return</span> ctx</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minix2</span>:</span></span><br><span class="line">	<span class="string">"""该混合类为header列表头部添加data2"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run Minix2.get_header'</span>)</span><br><span class="line">		ctx = super().get_header()</span><br><span class="line">		ctx.insert(<span class="number">0</span>, <span class="string">'data2'</span>)</span><br><span class="line">		<span class="keyword">return</span> ctx</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span>:</span></span><br><span class="line">	header = []</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'run Headers.get_header'</span>)</span><br><span class="line">		<span class="keyword">return</span> self.header <span class="keyword">if</span> self.header <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span><span class="params">(Minix1, Minix2, Header)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> super().get_header()</span><br></pre></td></tr></table></figure>

<p>当然, 我们可以定义更多的混合类, 并从中选取所需的类来快速得到想要的<code>header</code>属性, 在这个例子中, 这两个混合类已经足够说明问题. </p>
<p>我们现在使用类C的<code>get_header()</code>方法来得到其<code>header</code>属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(Final.mro())</span><br><span class="line"><span class="comment">#[Final, Minix1, Minix2, Header, object]</span></span><br><span class="line">header = Final().get_header()</span><br><span class="line"><span class="comment">#run Minix1.get_header</span></span><br><span class="line"><span class="comment">#run Minix2.get_header</span></span><br><span class="line"><span class="comment">#run Headers.get_header</span></span><br><span class="line">print(header)</span><br><span class="line"><span class="comment">#['data2', 'data1']</span></span><br></pre></td></tr></table></figure>

<p>这样, 我们就实现了多继承<strong>协同</strong>工作的目标, 通过混合不同个类, 模块化地修改<strong>同一个</strong>属性.</p>
<p>而这种工作方法, 通过单纯的重写某个方法根本无法实现的, 因为重写任何方法, 它会在MRO列表中找到最优先(也就是最靠前)的拥有同名方法的类, 然后调用该方法, 并且终止检索, 某项属性仅仅会被<strong>一个</strong>方法所影响. </p>
<p>相关文章或参考:<br><a href="https://www.cnblogs.com/crazyrunning/p/7095014.html" target="_blank" rel="noopener">Python进阶-继承中的MRO与super</a><br><a href="https://blog.csdn.net/weixin_34267123/article/details/89545060" target="_blank" rel="noopener">python 继承与多重继承</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>MRO</tag>
        <tag>super()</tag>
      </tags>
  </entry>
  <entry>
    <title>MRO及C3线性化算法</title>
    <url>/2019/06/01/python%20MRO%E5%8F%8AC3%E7%BA%BF%E6%80%A7%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Python中的方法解析顺序(Method Resolution Order , MRO)采用C3线性化算法来确定.</p>
<a id="more"></a>

<p>一个类的MRO应当如下确定:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[object] = [object]</span><br><span class="line">L[C(B1…BN)] = [C] + merge(L[B1]…L[BN], [B1, … ,BN])</span><br></pre></td></tr></table></figure>

<p>merge函数接收一组列表, 按照如下方式输出一个列表：</p>
<ol>
<li>检查第一个列表的头元素（如 L[B1] 的头）, 记作 H. </li>
<li>若 H 未出现在其它列表的尾部, 则将其输出, 并将其从所有列表中删除, 然后回到步骤1；否则, 取出下一个列表的头部记作 H, 继续该步骤. </li>
<li>重复上述步骤, 直至列表为空或者不能再找出可以输出的元素. 如果是前一种情况, 则算法结束；如果是后一种情况, 说明无法构建继承关系, Python 会抛出异常. </li>
</ol>
<hr>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>继承关系如下图<br><img src="https://img2018.cnblogs.com/blog/1249301/201905/1249301-20190524235050394-577481731.png" alt></p>
<p>根据上述C3算法的步骤来计算其MRO</p>
<p>首先计算B1的MRO:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[B1(A1,A2)] = [B1] + merge(L[A1], L(A2), [A1, A2])</span><br><span class="line">             = [B1] + merge([A1,Obj], [A2,Obj], [A1,A2])</span><br><span class="line">             = [B1, A1] + merge([Obj], [A2,Obj], [A2])</span><br><span class="line">             = [B1, A1, A2] + merge([Obj], [Obj])</span><br><span class="line">             = [B1, A1, A2, Obj]</span><br></pre></td></tr></table></figure>

<p>同理,计算B2的MRO(过程略):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[B2(A3)] = [B2, A3, Obj]</span><br></pre></td></tr></table></figure>

<p>最终计算并得到C的MRO</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[C(B1,B2)] = [C] + merge(L[B1(A1,A2)], L[B2(A3)], [B1,B2])</span><br><span class="line">            = [C] + merge([B1, A1, A2, Obj], [B2, A3, Obj], [B1,B2])</span><br><span class="line">            = [C, B1] + merge([A1, A2, Obj], [B2, A3, Obj], [B2])</span><br><span class="line">            = [C, B1, A1] + merge([A2, Obj], [B2, A3, Obj], [B2])</span><br><span class="line">            = [C, B1, A1, A2] + merge([Obj], [B2, A3, Obj], [B2])</span><br><span class="line">            = [C, B1, A1, A2, B2] +merge([Obj], [A3, Obj])</span><br><span class="line">            = [C, B1, A1, A2, B2, A3] +merge([Obj], [Obj])</span><br><span class="line">            = [C, B1, A1, A2, B2, A3, Obj]</span><br></pre></td></tr></table></figure>

<p>根据C3算法成功构建了MRO, 所以这个类的继承关系是被允许的, 而且根据MRO可以明确地指出应当如何去查找其父类的属性/方法, 即按照MRO列表由前向后的顺序来查找. </p>
<p>当然, 我们完全没有必要去计算这个序列, 直接使用类方法<code>.mro()</code>即可查看该类的MRO:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.mro()</span><br><span class="line"></span><br><span class="line">[&lt;class '__main__.C'&gt;, &lt;class '__main__.B1'&gt;, &lt;class '__main__.A1'&gt;, &lt;class '__main__.A2'&gt;, &lt;class '__main__.B2'&gt;, &lt;class '__main__.A3'&gt;, &lt;class 'object'&gt;]</span><br></pre></td></tr></table></figure>

<p>与我们计算的结果是相同的. </p>
<p>正确理解MRO是使用多重继承和super()完成多继承类协作任务的基础.</p>
<hr>
<p>参考:  </p>
<p><a href="https://www.cnblogs.com/whatisfantasy/p/6046991.html" target="_blank" rel="noopener">Python的方法解析顺序(MRO)[转]</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>MRO</tag>
      </tags>
  </entry>
  <entry>
    <title>Django信号系统</title>
    <url>/2019/03/17/Django%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="内置信号"><a href="#内置信号" class="headerlink" title="内置信号"></a>内置信号</h3><p>模型相关的内置信号都在<code>django.db.models.signals</code>中定义</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>发送时机</th>
</tr>
</thead>
<tbody><tr>
<td>pre_save</td>
<td>在save之前发送</td>
</tr>
<tr>
<td>pre_delete</td>
<td>在delete之前发送</td>
</tr>
<tr>
<td>post_save</td>
<td>在save之后发送</td>
</tr>
<tr>
<td>post_delete</td>
<td>在delete之后发送</td>
</tr>
<tr>
<td>m2m_changed</td>
<td>在manytomany表改动后发送</td>
</tr>
</tbody></table>
<a id="more"></a>

<p>请求相关的内置信号定义在<code>django.core.signals</code>中的信号</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>发送时机</th>
</tr>
</thead>
<tbody><tr>
<td>request_start</td>
<td>在接收请求之时发送</td>
</tr>
<tr>
<td>request_finished</td>
<td>在完成请求时发送</td>
</tr>
<tr>
<td>got_request_exception</td>
<td>在请求触发异常时发送</td>
</tr>
</tbody></table>
<p>完整的信号查阅<a href="https://docs.djangoproject.com/en/2.2/ref/signals/" target="_blank" rel="noopener">官方文档</a></p>
<hr>
<h3 id="信号接收的命名关键字参数"><a href="#信号接收的命名关键字参数" class="headerlink" title="信号接收的命名关键字参数"></a>信号接收的命名关键字参数</h3><p>除了有限的几个关键字参数, 每种信号所能接收的关键字参数不同, 而自定义信号则需要自己定义可接收的关键字参数</p>
<p>模型信号通用的命名关键字参数包括</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>sender</td>
<td>Model</td>
<td>触发信号的模型</td>
</tr>
<tr>
<td>instance</td>
<td>Object</td>
<td>实际触发信号的实例</td>
</tr>
<tr>
<td>using</td>
<td>字符串</td>
<td>使用的非默认数据库的别名</td>
</tr>
</tbody></table>
<p>pre_save信号额外接收的命名关键字参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>raw</td>
<td>布尔型</td>
<td>是否按照显示的方式保存(不查询/修改其他记录)</td>
</tr>
<tr>
<td>update_fields</td>
<td>Set/None</td>
<td>修改的字段集合或者None</td>
</tr>
</tbody></table>
<p>post_save信号额外接收的命名关键字参数在pre_save的基础上再多一个</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>created</td>
<td>布尔型</td>
<td>是否成功创建了该记录</td>
</tr>
</tbody></table>
<p>pre_delete&amp;post_delete不接收额外的命名关键字参数</p>
<p>而request_started接收的关键字参数包括</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>sender</td>
<td>WSgiHandler</td>
<td>处理该请求的Handler</td>
</tr>
<tr>
<td>environ</td>
<td>字典</td>
<td>为该请求提供的environ</td>
</tr>
</tbody></table>
<p>request_finish则只接收sender关键字参数, 数据类型和含义与request_start相同</p>
<hr>
<h3 id="信号相关代码位置"><a href="#信号相关代码位置" class="headerlink" title="信号相关代码位置"></a>信号相关代码位置</h3><p>一般而言, 对于简单的信号, 直接定义在关联的<code>models.py</code>中即可.</p>
<p>而比较正式的情况, 应当定义在单独的<code>signals</code>模块中, 然后在app.py添加代码确保该模块被加载, 比较合适.</p>
<p>如果自定义信号, 应当在singals的<strong>init</strong>.py中进行定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yourapp/signals___init__.py</span></span><br><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line"></span><br><span class="line">task_generate_pre_save = django.dispatch.Signal(providing_args=[<span class="string">"task"</span>])</span><br></pre></td></tr></table></figure>

<p>定义回调并绑定信号(未使用自定义信号)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yourapp/signals/handlers.py</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> MyModel</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(pre_save, sender=MyModel)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在apps.py中使用ready方法来确保该app在初始化之后加载该signals模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yourapp/apps.py</span></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasksConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">'tasks'</span></span><br><span class="line">    verbose_name = <span class="string">"Tasks"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> yourproject.yourapp.signals.handlers</span><br></pre></td></tr></table></figure>

<p>目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apps.py</span><br><span class="line">signals</span><br><span class="line">  __init__.py</span><br><span class="line">  handlers.py</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="定义处理函数"><a href="#定义处理函数" class="headerlink" title="定义处理函数"></a>定义处理函数</h3><p>一个处理信号的函数应当接收一个sender参数, 并接受任意关键字参数, 信号所提供的关键字参数会传入该函数中以供使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(sender, **kwargs)</span></span></span><br><span class="line"><span class="function">	...</span></span><br><span class="line">	xxx = kwargs['xxx']</span><br></pre></td></tr></table></figure>

<p>在完成定义后使用signal.connect或者在定义时使用装饰器<code>@receiver</code>与特定信号绑定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre_save.connect(handler, sender=<span class="string">'xxx'</span>)</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="meta">@receiver(sender='xxx')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">	instance = kwargs.get(<span class="string">'instance'</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h3><p>一个信号是<code>django.dispatch.Signal</code>的实例, 因此初始化一个Signal类即可</p>
<p>签名<code>class Signal(providing_args=list)</code></p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line">new_signal = django.dispatch.Signal(providing_args=[<span class="string">"task"</span>, <span class="string">"size"</span>, <span class="string">"time"</span>])</span><br></pre></td></tr></table></figure>

<p>使用该信号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(new_signal, )</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/2719038/where-should-signal-handlers-live-in-a-django-project" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <tags>
        <tag>Django</tag>
        <tag>Django信号系统</tag>
      </tags>
  </entry>
  <entry>
    <title>python元编程</title>
    <url>/2019/01/07/python%E5%85%83%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<blockquote>
<p>元编程是一种编写计算机程序的技术, 这些程序可以将自己看做数据, 因此可以在运行时可以对它进行内省, 生成, 修改. </p>
</blockquote>
<p>因此我们可以区分Python元编程的两种主要方法</p>
<ol>
<li>专注于语言对基本元素(函数, 类, 类型)内省的能力和对运行时创建或修改的能力</li>
<li>允许程序直接处理代码本身, 例如原始的纯文本格式, 或是抽象语法树(AST)</li>
</ol>
<a id="more"></a>

<p>在python中与之相关的工具有:</p>
<p>第一类方法:</p>
<ul>
<li>装饰器, 允许向现有函数、方法、类中添加附加功能. </li>
<li>类的特殊方法/属性, 允许修改实例的创建过程, 或是访问和修改类/实例的属性. </li>
<li>元类, 允许完全重新设计python面向对象编程范式的实现</li>
</ul>
<p>第二类方法:</p>
<ul>
<li>动态代码生成相关</li>
</ul>
<hr>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>一个装饰器, 接收一个函数, 并返回一个新的函数. </p>
<p>未嵌套装饰器的大概定义如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">warpper</span><span class="params">(*args,**kw)</span>:</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">   rerurn warpper</span><br></pre></td></tr></table></figure>

<p>装饰器语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>等同于 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func = decorator(func)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一个装饰器函数至少接收一个函数参数func, 并在内部定义新函数warpper, 在warpper的函数体中调用func函数以完成func原本的功能, 并将func的返回值作为自己的返回值, 然后还可以添加其他代码完成额外功能, 最后将warpper函数返回,并赋值给原函数名</p>
<p>&emsp;&emsp;注意装饰器语法完全等同于<code>func = decorator(func)</code>, 现在func这个变量名已经指向了新函数warpper,即增强版的func, 在完成func原本的功能之余, 还增加了新的特性. 为了保证warpper函数可以接收任何类型和任意数量的参数, 其参数定义为<code>(*args, **kwargs)</code>, 并解构传递至func中. </p>
<p>&emsp;&emsp;我们的目的是让warpper函数完美替代原本的func, 现在func变量指向了warpper函数, 但是warpper的一些元数据未改变, 例如<code>__name__</code>属性仍然为”warpper”而不是”func”, 即<code>func.__name__ = warpper</code>.</p>
<p> 这显然是不合适的. 为了使warpper函数<strong>看起来</strong>完全就是func, <code>functools</code>模块中提供了一个装饰器<code>@functools.warps</code>, 该装饰器接收一个额外的参数, 该参数应当传入一个函数, 该装饰器会将被装饰的函数的所有元属性更改为与额外参数(另一个函数)完全相同. </p>
<p>所以一个典型的自定义装饰器应当如下形式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">	@functools.warps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wapper</span><span class="params">(*args,**kws)</span>:</span></span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">return</span> func(*args,**kws)</span><br><span class="line"><span class="keyword">return</span> wapper</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="类的特殊方法"><a href="#类的特殊方法" class="headerlink" title="类的特殊方法"></a>类的特殊方法</h2><h4 id="使用new方法来覆写实例创建过程"><a href="#使用new方法来覆写实例创建过程" class="headerlink" title="使用new方法来覆写实例创建过程"></a>使用<strong>new</strong>方法来覆写实例创建过程</h4><p>在类的实例化过程中, <code>__init__</code>是一个实例方法, 它接收一个实例(<code>self</code>), 并将其初始化</p>
<p>而<strong>创建</strong>该类实例的是另一个方法, <code>__new__</code>方法</p>
<ol>
<li><code>__new__</code>方法是用来创建实例的静态方法, 因为其特殊性, 所以无需使用<code>@staticmethod</code>来声明. </li>
<li><code>__new__</code>方法至少接收一个<code>cls</code>参数, 代表当前类</li>
<li><code>__new__</code>方法必须返回一个实例, 否则实例不会被创建</li>
<li><code>__new__</code>方法一般返回当前类的实例, 但也可以返回其他类的实例</li>
<li><code>__new__</code>方法如果返回的不是当前类的实例, <code>__init__</code>方法不会被调用</li>
</ol>
<p>如果要覆写<code>__new__</code>, 一般使用<code>super().__new__()</code>来获取实际生成的实例, 并在完成自定义逻辑后将其返回. 例如实现单例模式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">	_instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">			cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line">		<span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<p><em>以上单例模式的实现有两个重要缺陷:线程不安全以及子类实例化异常</em><br><em>在python中实现单例模式应该直接使用模块的单例性, 将模块级变量定义为需要单例的类的实例</em></p>
<hr>
<h4 id="其他可以访问类-实例属性的一些方法"><a href="#其他可以访问类-实例属性的一些方法" class="headerlink" title="其他可以访问类/实例属性的一些方法"></a>其他可以访问类/实例属性的一些方法</h4><p>内置函数<code>dir()</code>和<code>vars()</code></p>
<ul>
<li><p>dir(cls) 返回继承自基类的和自己的所有属性的列表</p>
</li>
<li><p>dir(obj) 返回实例和从类中继承的所有属性的列表</p>
</li>
<li><p>vars(cls) 返回类<strong>自己的</strong>所有属性的键和值, 与实际属性相关联, 写有效</p>
</li>
<li><p>vars(obj) 返回实例<strong>自己的</strong>所有属性的键和值, 与实际属性相关联, 写有效</p>
</li>
</ul>
<p>类和实例的属性</p>
<ul>
<li><code>cls.__dict__</code> 一个字典, 包含类<strong>自己的</strong>所有属性的键和值, 与实际属性相关联, 写有效</li>
<li><code>obj.__dict__</code> 一个字典, 包含实例<strong>自己的</strong>所有属性的键和值, 与实际属性相关联, 写有效</li>
</ul>
<p>实际上, <code>vars</code>调用就是返回<code>__dict__</code>属性的值</p>
<hr>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>元类(metaclass)是一个python特性. </p>
<p>元类是定义其他类的原型. 在python中一切皆对象, 所以定义了实例对象的类本身, 也是对象. 因此, 如果它也是对象, 那么一定有与之相关联的类, 事实上, 所有类定义的基类都是内置的<code>type</code>类. </p>
<blockquote>
<p>普通类是type的<strong>实例</strong>, 而元类是type的<strong>子类</strong>. </p>
</blockquote>
<p>一个<strong>继承</strong>而不是实例化自<code>type</code>的类, 我们称之为元类(metaclass)</p>
<p>一般语法:</p>
<p><code>type()</code>可以作为<code>class</code>语句的动态等效. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">klass = type(<span class="string">'MyClass'</span>, (object, ), &#123;<span class="string">'method'</span>:method&#125;)</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">klass</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>元类中有四个方法需要关注:</p>
<ol>
<li><code>__prepare__(mcs, name, bases, **kwargs)</code> 返回一个空的命名空间</li>
<li><code>__new__(mcs, name, bases, namespace, **kwargs)</code> 创建一个类</li>
<li><code>__init__(cls, name, bases, namespace, **kwargs)</code> 初始化一个类</li>
<li><code>__call__(cls, *args, **kwargs)</code> 让一个类成为<code>callable</code></li>
</ol>
<p>参数解释:</p>
<ul>
<li><code>mcs</code> 指元类本身, 调用此参数的方法接收的是元类本身</li>
<li><code>cls</code> 指创建的类, 接收此参数的方法时对类的操作方法</li>
<li><code>name</code> 指要创建的类的<strong>name</strong>属性</li>
<li><code>bases</code> 要创建的类的父类, 元组</li>
<li><code>namespace</code> 命名空间, 即attrs</li>
</ul>
<hr>
<h3 id="动态代码生成"><a href="#动态代码生成" class="headerlink" title="动态代码生成"></a>动态代码生成</h3><ol>
<li><code>ecec(object, globals, locals)</code>: 用于手动执行代码</li>
<li><code>eval(expression, globals, locals)</code>：用于求值</li>
<li><code>complie(source, filename, mode)</code>：编译任意Python代码</li>
</ol>
<p>Python语法首先被转换为抽象语法树(Abstract Syntax Tree, AST),然后被编译为字节码. 抽象语法树是对源代码抽象语法结构的一种树状表示. 使用内置的ast模块可以得到Python代码的原始AST, 在传递给<code>complie()</code> 调用之前, 可以对AST进行修改, 以便向现有语法中添加新的语义. 也可以使用纯人工方式创建AST, 不需要解析任何源码, 这样就可以为自定义的领域特定语言创建Python字节码. </p>
]]></content>
      <tags>
        <tag>元编程</tag>
      </tags>
  </entry>
</search>
